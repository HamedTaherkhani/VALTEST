{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "difficulty": 3, "func_name": "findMedianSortedArrays", "description": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively,\nreturn the median of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.53}, {"type": "if", "start": 28, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.51}, {"type": "else", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.49}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.92}, {"type": "else", "start": 35, "end": 36, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [16, 29, 30, 32, 34, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      log_function('BRANCH #1: Covered if branch at line 15-16\\n')\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      log_function('LOOP #1: Entered while loop at line 21-37\\n')\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        log_function('BRANCH #2: Covered if branch at line 28-32\\n')\n        if (n1 + n2) % 2 == 0:\n          log_function('BRANCH #3: Covered if branch at line 29-30\\n')\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          log_function('BRANCH #4: Covered else branch at line 31-32\\n')\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        log_function('BRANCH #5: Covered elif branch at line 33-34\\n')\n        r = partition1 - 1\n      else:\n        log_function('BRANCH #6: Covered else branch at line 35-36\\n')\n        l = partition1 + 1\n\ndef log_function(info_str):\n    with open(\"test_logs/Median of Two Sorted Arrays.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered while loop at line 21-37\n", "BRANCH #6: Covered else branch at line 35-36\n", "LOOP #1: Entered while loop at line 21-37\n", "BRANCH #2: Covered if branch at line 28-32\n", "BRANCH #4: Covered else branch at line 31-32\n"], ["LOOP #1: Entered while loop at line 21-37\n", "BRANCH #6: Covered else branch at line 35-36\n", "LOOP #1: Entered while loop at line 21-37\n", "BRANCH #2: Covered if branch at line 28-32\n", "BRANCH #3: Covered if branch at line 29-30\n"]], "sampled_condition_paths": [["Line 21: (l <= r)", "Line 28: NOT (maxLeft1 <= minRight2 and maxLeft2 <= minRight1)", "Line 33: NOT (maxLeft1 > minRight2)", "Line 35: ", "Line 21: (l <= r)", "Line 28: (maxLeft1 <= minRight2 and maxLeft2 <= minRight1)", "Line 29: NOT ((n1 + n2) % 2 == 0)", "Line 31: "], ["Line 21: (l <= r)", "Line 28: NOT (maxLeft1 <= minRight2 and maxLeft2 <= minRight1)", "Line 33: NOT (maxLeft1 > minRight2)", "Line 35: ", "Line 21: (l <= r)", "Line 28: (maxLeft1 <= minRight2 and maxLeft2 <= minRight1)", "Line 29: ((n1 + n2) % 2 == 0)"]]}
{"task_num": 10, "task_title": "Regular Expression Matching", "difficulty": 3, "func_name": "isMatch", "description": "Given an input string `s` and a pattern `p`, implement regular expression\nmatching with support for `'.'` and `'*'` where:\n\n* `'.'` Matches any single character.\u200b\u200b\u200b\u200b\n* `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.02}, {"type": "if", "start": 27, "end": 30, "difficulty": 2, "eg_cov_prob": 0.26}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [23, 28, 29, 30, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      log_function('LOOP #1: Entered for loop at line 21-24\\n')\n      if c == '*' and dp[0][j - 1]:\n        log_function('BRANCH #1: Covered if branch at line 22-23\\n')\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      log_function('LOOP #2: Entered for loop at line 25-33\\n')\n      for j in range(n):\n        log_function('LOOP #3: Entered for loop at line 26-33\\n')\n        if p[j] == '*':\n          log_function('BRANCH #2: Covered if branch at line 27-30\\n')\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          log_function('BRANCH #3: Covered elif branch at line 31-32\\n')\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n\ndef log_function(info_str):\n    with open(\"test_logs/Regular Expression Matching.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #2: Covered if branch at line 27-30\n", "LOOP #2: Entered for loop at line 25-33\n"], ["LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #2: Covered if branch at line 27-30\n"], ["LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n", "LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n"], ["LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n", "LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n"]], "sampled_condition_paths": [["Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))", "Line 26: (j in range(n))", "Line 27: (p[j] == '*')", "Line 25: (i in range(m))"], ["Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))", "Line 26: (j in range(n))", "Line 27: (p[j] == '*')"], ["Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))", "Line 25: (i in range(m))", "Line 26: (j in range(n))"], ["Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))", "Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))"]]}
{"task_num": 15, "task_title": "3Sum", "difficulty": 2, "func_name": "threeSum", "description": "Given an integer array nums, return all the triplets `[nums[i], nums[j],\nnums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] +\nnums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.83}, {"type": "if", "start": 28, "end": 35, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 22, 29, 30, 31, 32, 33, 34, 35, 37, 39], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      log_function('LOOP #1: Entered for loop at line 20-40\\n')\n      if i > 0 and nums[i] == nums[i - 1]:\n        log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        log_function('LOOP #2: Entered while loop at line 26-40\\n')\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          log_function('BRANCH #3: Covered if branch at line 28-35\\n')\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            log_function('LOOP #3: Entered while loop at line 32-33\\n')\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            log_function('LOOP #4: Entered while loop at line 34-35\\n')\n            r -= 1\n        elif summ < 0:\n          log_function('BRANCH #4: Covered elif branch at line 36-37\\n')\n          l += 1\n        else:\n          log_function('BRANCH #5: Covered else branch at line 38-39\\n')\n          r -= 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/3Sum.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 26-40\n", "BRANCH #3: Covered if branch at line 28-35\n", "LOOP #1: Entered for loop at line 20-40\n", "BRANCH #2: Covered if branch at line 21-22\n", "LOOP #1: Entered for loop at line 20-40\n"], ["LOOP #1: Entered for loop at line 20-40\n", "LOOP #2: Entered while loop at line 26-40\n", "BRANCH #5: Covered else branch at line 38-39\n"], ["LOOP #1: Entered for loop at line 20-40\n", "LOOP #2: Entered while loop at line 26-40\n", "BRANCH #3: Covered if branch at line 28-35\n"], ["BRANCH #4: Covered elif branch at line 36-37\n", "LOOP #2: Entered while loop at line 26-40\n", "BRANCH #4: Covered elif branch at line 36-37\n", "LOOP #2: Entered while loop at line 26-40\n", "BRANCH #4: Covered elif branch at line 36-37\n"]], "sampled_condition_paths": [["Line 26: (l < r)", "Line 28: (summ == 0)", "Line 20: (i in range(len(nums) - 2))", "Line 21: (i > 0 and nums[i] == nums[i - 1])", "Line 20: (i in range(len(nums) - 2))"], ["Line 20: (i in range(len(nums) - 2))", "Line 26: (l < r)", "Line 28: NOT (summ == 0)", "Line 36: NOT (summ < 0)", "Line 38: "], ["Line 20: (i in range(len(nums) - 2))", "Line 26: (l < r)", "Line 28: (summ == 0)"], ["Line 28: NOT (summ == 0)", "Line 36: (summ < 0)", "Line 26: (l < r)", "Line 28: NOT (summ == 0)", "Line 36: (summ < 0)", "Line 26: (l < r)", "Line 28: NOT (summ == 0)", "Line 36: (summ < 0)"]]}
{"task_num": 44, "task_title": "Wildcard Matching", "difficulty": 3, "func_name": "isMatch", "description": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern\nmatching with support for `'?'` and `'*'` where:\n\n* `'?'` Matches any single character.\n* `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 27, "end": 30, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 28, 29, 30, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      log_function('LOOP #1: Entered for loop at line 21-24\\n')\n      if c == '*':\n        log_function('BRANCH #1: Covered if branch at line 22-23\\n')\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      log_function('LOOP #2: Entered for loop at line 25-33\\n')\n      for j in range(n):\n        log_function('LOOP #3: Entered for loop at line 26-33\\n')\n        if p[j] == '*':\n          log_function('BRANCH #2: Covered if branch at line 27-30\\n')\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          log_function('BRANCH #3: Covered elif branch at line 31-32\\n')\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n\ndef log_function(info_str):\n    with open(\"test_logs/Wildcard Matching.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 21-24\n", "LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n", "LOOP #3: Entered for loop at line 26-33\n"], ["LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n", "LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n"], ["LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #3: Covered elif branch at line 31-32\n", "LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n"], ["BRANCH #1: Covered if branch at line 22-23\n", "LOOP #2: Entered for loop at line 25-33\n", "LOOP #3: Entered for loop at line 26-33\n", "BRANCH #2: Covered if branch at line 27-30\n", "LOOP #2: Entered for loop at line 25-33\n"]], "sampled_condition_paths": [["Line 21: (j, c in enumerate(p))", "Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))", "Line 26: (j in range(n))"], ["Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))", "Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))"], ["Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 27: NOT (p[j] == '*')", "Line 31: (isMatch(i, j))", "Line 25: (i in range(m))", "Line 26: (j in range(n))"], ["Line 22: (c == '*')", "Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 27: (p[j] == '*')", "Line 25: (i in range(m))"]]}
{"task_num": 54, "task_title": "Spiral Matrix", "difficulty": 2, "func_name": "spiralOrder", "description": "Given an `m x n` `matrix`, return all elements of the `matrix` in spiral\norder.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      log_function('LOOP #1: Entered while loop at line 24-45\\n')\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        log_function('LOOP #2: Entered while loop at line 26-28\\n')\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        log_function('LOOP #3: Entered while loop at line 30-32\\n')\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        log_function('LOOP #4: Entered while loop at line 34-36\\n')\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        log_function('LOOP #5: Entered while loop at line 38-40\\n')\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Spiral Matrix.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 26-28\n", "LOOP #2: Entered while loop at line 26-28\n", "LOOP #2: Entered while loop at line 26-28\n", "LOOP #3: Entered while loop at line 30-32\n", "LOOP #4: Entered while loop at line 34-36\n"], ["LOOP #4: Entered while loop at line 34-36\n", "LOOP #5: Entered while loop at line 38-40\n", "LOOP #1: Entered while loop at line 24-45\n", "LOOP #2: Entered while loop at line 26-28\n", "LOOP #2: Entered while loop at line 26-28\n"], ["LOOP #2: Entered while loop at line 26-28\n", "LOOP #3: Entered while loop at line 30-32\n", "LOOP #4: Entered while loop at line 34-36\n", "LOOP #4: Entered while loop at line 34-36\n", "LOOP #4: Entered while loop at line 34-36\n"], ["LOOP #4: Entered while loop at line 34-36\n", "LOOP #4: Entered while loop at line 34-36\n", "LOOP #4: Entered while loop at line 34-36\n", "LOOP #5: Entered while loop at line 38-40\n", "LOOP #1: Entered while loop at line 24-45\n"]], "sampled_condition_paths": [["Line 26: (j <= c2 and len(ans) < m * n)", "Line 26: (j <= c2 and len(ans) < m * n)", "Line 26: (j <= c2 and len(ans) < m * n)", "Line 30: (i <= r2 - 1 and len(ans) < m * n)", "Line 34: (j >= c1 and len(ans) < m * n)"], ["Line 34: (j >= c1 and len(ans) < m * n)", "Line 38: (i >= r1 + 1 and len(ans) < m * n)", "Line 24: (len(ans) < m * n)", "Line 26: (j <= c2 and len(ans) < m * n)", "Line 26: (j <= c2 and len(ans) < m * n)"], ["Line 26: (j <= c2 and len(ans) < m * n)", "Line 30: (i <= r2 - 1 and len(ans) < m * n)", "Line 34: (j >= c1 and len(ans) < m * n)", "Line 34: (j >= c1 and len(ans) < m * n)", "Line 34: (j >= c1 and len(ans) < m * n)"], ["Line 34: (j >= c1 and len(ans) < m * n)", "Line 34: (j >= c1 and len(ans) < m * n)", "Line 34: (j >= c1 and len(ans) < m * n)", "Line 38: (i >= r1 + 1 and len(ans) < m * n)", "Line 24: (len(ans) < m * n)"]]}
{"task_num": 65, "task_title": "Valid Number", "difficulty": 3, "func_name": "isNumber", "description": "A valid number can be split up into these components (in order):\n\n1. A decimal number or an integer.\n2. (Optional) An `'e'` or `'E'`, followed by an integer.\n\nA decimal number can be split up into these components (in order):\n\n1. (Optional) A sign character (either `'+'` or `'-'`).\n2. One of the following formats: \n1. One or more digits, followed by a dot `'.'`.\n2. One or more digits, followed by a dot `'.'`, followed by one or more digits.\n3. A dot `'.'`, followed by one or more digits.\n\nAn integer can be split up into these components (in order):\n\n1. (Optional) A sign character (either `'+'` or `'-'`).\n2. One or more digits.\n\nFor example, all the following are valid numbers: `[\"2\", \"0089\", \"-0.1\",\n\"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\",\n\"-123.456e789\"]`, while the following are not valid numbers: `[\"abc\", \"1a\",\n\"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]`.\n\nGiven a string `s`, return `true` if `s` is a valid number.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 2, "eg_cov_prob": 0.02}, {"type": "if", "start": 22, "end": 25, "difficulty": 2, "eg_cov_prob": 0.24}, {"type": "if", "start": 23, "end": 24, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 26, "end": 30, "difficulty": 2, "eg_cov_prob": 0.37}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.11}, {"type": "if", "start": 31, "end": 34, "difficulty": 2, "eg_cov_prob": 0.29}, {"type": "else", "start": 35, "end": 38, "difficulty": 1, "eg_cov_prob": 0.85}, {"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 1, "eg_cov_prob": 0.43}], "target_lines": [15, 23, 24, 25, 27, 28, 29, 30, 32, 33, 34, 36, 37, 38], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      log_function('BRANCH #1: Covered if branch at line 14-15\\n')\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      log_function('LOOP #1: Entered for loop at line 21-39\\n')\n      if c == '.':\n        log_function('BRANCH #2: Covered if branch at line 22-25\\n')\n        if seenDot or seenE:\n          log_function('BRANCH #3: Covered if branch at line 23-24\\n')\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        log_function('BRANCH #4: Covered elif branch at line 26-30\\n')\n        if seenE or not seenNum:\n          log_function('BRANCH #5: Covered if branch at line 27-28\\n')\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        log_function('BRANCH #6: Covered elif branch at line 31-34\\n')\n        if i > 0 and s[i - 1] not in 'eE':\n          log_function('BRANCH #7: Covered if branch at line 32-33\\n')\n          return False\n        seenNum = False\n      else:\n        log_function('BRANCH #8: Covered else branch at line 35-38\\n')\n        if not c.isdigit():\n          log_function('BRANCH #9: Covered if branch at line 36-37\\n')\n          return False\n        seenNum = True\n\n    return seenNum\n\ndef log_function(info_str):\n    with open(\"test_logs/Valid Number.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 21-39\n", "BRANCH #8: Covered else branch at line 35-38\n"], ["LOOP #1: Entered for loop at line 21-39\n", "BRANCH #4: Covered elif branch at line 26-30\n", "BRANCH #5: Covered if branch at line 27-28\n"], ["LOOP #1: Entered for loop at line 21-39\n", "BRANCH #2: Covered if branch at line 22-25\n"]], "sampled_condition_paths": [["Line 21: (i, c in enumerate(s))", "Line 22: NOT (c == '.')", "Line 26: NOT (c == 'e' or c == 'E')", "Line 31: NOT (c in '+-')", "Line 35: "], ["Line 21: (i, c in enumerate(s))", "Line 22: NOT (c == '.')", "Line 26: (c == 'e' or c == 'E')", "Line 27: (seenE or not seenNum)"], ["Line 21: (i, c in enumerate(s))", "Line 22: (c == '.')"]]}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "difficulty": 2, "func_name": "setZeroes", "description": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire\nrow and column to `0`'s.\n\nYou must do it in place.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 20, "end": 22, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [21, 22, 27, 30, 33, 34], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      log_function('LOOP #1: Entered for loop at line 18-23\\n')\n      for j in range(1, n):\n        log_function('LOOP #2: Entered for loop at line 19-23\\n')\n        if matrix[i][j] == 0:\n          log_function('BRANCH #1: Covered if branch at line 20-22\\n')\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      log_function('LOOP #3: Entered for loop at line 24-28\\n')\n      for j in range(1, n):\n        log_function('LOOP #4: Entered for loop at line 25-28\\n')\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          log_function('BRANCH #2: Covered if branch at line 26-27\\n')\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      log_function('BRANCH #3: Covered if branch at line 29-30\\n')\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      log_function('BRANCH #4: Covered if branch at line 32-34\\n')\n      for row in matrix:\n        log_function('LOOP #5: Entered for loop at line 33-35\\n')\n        row[0] = 0\n\ndef log_function(info_str):\n    with open(\"test_logs/Set Matrix Zeroes.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 29-30\n", "BRANCH #4: Covered if branch at line 32-34\n", "LOOP #5: Entered for loop at line 33-35\n", "LOOP #5: Entered for loop at line 33-35\n", "LOOP #5: Entered for loop at line 33-35\n"], ["LOOP #1: Entered for loop at line 18-23\n", "LOOP #2: Entered for loop at line 19-23\n", "LOOP #2: Entered for loop at line 19-23\n", "LOOP #3: Entered for loop at line 24-28\n", "LOOP #4: Entered for loop at line 25-28\n"], ["BRANCH #2: Covered if branch at line 26-27\n", "LOOP #4: Entered for loop at line 25-28\n", "BRANCH #2: Covered if branch at line 26-27\n", "LOOP #3: Entered for loop at line 24-28\n", "LOOP #4: Entered for loop at line 25-28\n"], ["LOOP #4: Entered for loop at line 25-28\n", "LOOP #4: Entered for loop at line 25-28\n", "LOOP #4: Entered for loop at line 25-28\n", "BRANCH #2: Covered if branch at line 26-27\n", "BRANCH #3: Covered if branch at line 29-30\n"]], "sampled_condition_paths": [["Line 29: (shouldFillFirstRow)", "Line 32: (shouldFillFirstCol)", "Line 33: (row in matrix)", "Line 33: (row in matrix)", "Line 33: (row in matrix)"], ["Line 18: (i in range(1, m))", "Line 19: (j in range(1, n))", "Line 19: (j in range(1, n))", "Line 24: (i in range(1, m))", "Line 25: (j in range(1, n))"], ["Line 26: (matrix[i][0] == 0 or matrix[0][j] == 0)", "Line 25: (j in range(1, n))", "Line 26: (matrix[i][0] == 0 or matrix[0][j] == 0)", "Line 24: (i in range(1, m))", "Line 25: (j in range(1, n))"], ["Line 25: (j in range(1, n))", "Line 25: (j in range(1, n))", "Line 25: (j in range(1, n))", "Line 26: (matrix[i][0] == 0 or matrix[0][j] == 0)", "Line 29: (shouldFillFirstRow)"]]}
{"task_num": 97, "task_title": "Interleaving String", "difficulty": 2, "func_name": "isInterleave", "description": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an\ninterleaving of `s1` and `s2`.\n\nAn interleaving of two strings `s` and `t` is a configuration where `s` and\n`t` are divided into `n` and `m` substrings respectively, such that:\n\n* `s = s1 + s2 + ... + sn`\n* `t = t1 + t2 + ... + tm`\n* `|n - m| <= 1`\n* The interleaving is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\nNote: `a + b` is the concatenation of strings `a` and `b`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [16], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      log_function('BRANCH #1: Covered if branch at line 15-16\\n')\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      log_function('LOOP #1: Entered for loop at line 19-20\\n')\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      log_function('LOOP #2: Entered for loop at line 23-25\\n')\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      log_function('LOOP #3: Entered for loop at line 26-28\\n')\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      log_function('LOOP #4: Entered for loop at line 29-32\\n')\n      for j in range(1, n + 1):\n        log_function('LOOP #5: Entered for loop at line 30-32\\n')\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n\ndef log_function(info_str):\n    with open(\"test_logs/Interleaving String.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #5: Entered for loop at line 30-32\n", "LOOP #5: Entered for loop at line 30-32\n", "LOOP #5: Entered for loop at line 30-32\n", "LOOP #5: Entered for loop at line 30-32\n", "LOOP #5: Entered for loop at line 30-32\n"], ["LOOP #1: Entered for loop at line 19-20\n"], ["LOOP #3: Entered for loop at line 26-28\n", "LOOP #4: Entered for loop at line 29-32\n", "LOOP #5: Entered for loop at line 30-32\n", "LOOP #5: Entered for loop at line 30-32\n", "LOOP #5: Entered for loop at line 30-32\n"]], "sampled_condition_paths": [["Line 30: (j in range(1, n + 1))", "Line 30: (j in range(1, n + 1))", "Line 30: (j in range(1, n + 1))", "Line 30: (j in range(1, n + 1))", "Line 30: (j in range(1, n + 1))"], ["Line 19: (_ in range(m + 1))"], ["Line 26: (j in range(1, n + 1))", "Line 29: (i in range(1, m + 1))", "Line 30: (j in range(1, n + 1))", "Line 30: (j in range(1, n + 1))", "Line 30: (j in range(1, n + 1))"]]}
{"task_num": 126, "task_title": "Word Ladder II", "difficulty": 3, "func_name": "findLadders", "description": "A transformation sequence from word `beginWord` to word `endWord` using a\ndictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... ->\nsk` such that:\n\n* Every adjacent pair of words differs by a single letter.\n* Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n* `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`,\nreturn all the shortest transformation sequences from `beginWord` to\n`endWord`, or an empty list if no such sequence exists. Each sequence should\nbe returned as a list of the words `[beginWord, s1, s2, ..., sk]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 48, "end": 49, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 54, "end": 56, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 57, "end": 58, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 46, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 60, "end": 63, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 40, "end": 42, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [18, 22, 37, 39, 41, 42, 46, 49, 55, 56, 58, 61, 62, 63], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        log_function('LOOP #1: Entered for loop at line 16-18\\n')\n        if a[i] != b[i]:\n          log_function('BRANCH #1: Covered if branch at line 17-18\\n')\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      log_function('LOOP #2: Entered while loop at line 30-47\\n')\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        log_function('LOOP #3: Entered for loop at line 33-47\\n')\n        word = q.popleft()\n        for item in wordList:\n          log_function('LOOP #4: Entered for loop at line 35-44\\n')\n          if item in visited:\n            log_function('BRANCH #3: Covered if branch at line 36-37\\n')\n            continue\n          if not connected(word, item):\n            log_function('BRANCH #4: Covered if branch at line 38-39\\n')\n            continue\n          if item == endWord:\n            log_function('BRANCH #5: Covered if branch at line 40-42\\n')\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          log_function('BRANCH #6: Covered if branch at line 45-46\\n')\n          break\n\n    if not find:\n      log_function('BRANCH #7: Covered if branch at line 48-49\\n')\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        log_function('BRANCH #8: Covered if branch at line 54-56\\n')\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        log_function('BRANCH #9: Covered if branch at line 57-58\\n')\n        return\n      for item in nodes[level]:\n        log_function('LOOP #5: Entered for loop at line 59-64\\n')\n        if connected(item, word):\n          log_function('BRANCH #10: Covered if branch at line 60-63\\n')\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Word Ladder II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #4: Covered if branch at line 38-39\n", "LOOP #4: Entered for loop at line 35-44\n", "LOOP #1: Entered for loop at line 16-18\n", "BRANCH #1: Covered if branch at line 17-18\n", "LOOP #1: Entered for loop at line 16-18\n"], ["LOOP #1: Entered for loop at line 16-18\n", "BRANCH #10: Covered if branch at line 60-63\n", "LOOP #5: Entered for loop at line 59-64\n", "LOOP #1: Entered for loop at line 16-18\n", "LOOP #1: Entered for loop at line 16-18\n"], ["BRANCH #2: Covered if branch at line 21-22\n"]], "sampled_condition_paths": [["Line 38: (not connected(word, item))", "Line 35: (item in wordList)", "Line 16: (i in range(len(a)))", "Line 17: (a[i] != b[i])", "Line 16: (i in range(len(a)))"], ["Line 16: (i in range(len(a)))", "Line 60: (connected(item, word))", "Line 59: (item in nodes[level])", "Line 16: (i in range(len(a)))", "Line 16: (i in range(len(a)))"], ["Line 21: (endWord not in wordList)"]]}
{"task_num": 130, "task_title": "Surrounded Regions", "difficulty": 2, "func_name": "solve", "description": "Given an `m x n` matrix `board` containing `'X'` and `'O'`, capture all\nregions that are 4-directionally surrounded by `'X'`.\n\nA region is captured by flipping all `'O'`s into `'X'`s in that surrounded\nregion.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 23, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 24, 25, 26, 34, 36, 43, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 21-27\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 22-27\\n')\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          log_function('BRANCH #2: Covered if branch at line 23-26\\n')\n          if board[i][j] == 'O':\n            log_function('BRANCH #3: Covered if branch at line 24-26\\n')\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      log_function('LOOP #3: Entered while loop at line 28-39\\n')\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        log_function('LOOP #4: Entered for loop at line 30-39\\n')\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          log_function('BRANCH #4: Covered if branch at line 33-34\\n')\n          continue\n        if board[x][y] != 'O':\n          log_function('BRANCH #5: Covered if branch at line 35-36\\n')\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      log_function('LOOP #5: Entered for loop at line 40-46\\n')\n      for i, c in enumerate(row):\n        log_function('LOOP #6: Entered for loop at line 41-46\\n')\n        if c == '*':\n          log_function('BRANCH #6: Covered if branch at line 42-43\\n')\n          row[i] = 'O'\n        else:\n          log_function('BRANCH #7: Covered else branch at line 44-45\\n')\n          row[i] = 'X'\n\ndef log_function(info_str):\n    with open(\"test_logs/Surrounded Regions.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 22-27\n", "BRANCH #2: Covered if branch at line 23-26\n", "LOOP #1: Entered for loop at line 21-27\n", "LOOP #2: Entered for loop at line 22-27\n", "BRANCH #2: Covered if branch at line 23-26\n"], ["LOOP #2: Entered for loop at line 22-27\n", "BRANCH #2: Covered if branch at line 23-26\n", "LOOP #5: Entered for loop at line 40-46\n", "LOOP #6: Entered for loop at line 41-46\n", "BRANCH #7: Covered else branch at line 44-45\n"], ["LOOP #2: Entered for loop at line 22-27\n", "BRANCH #2: Covered if branch at line 23-26\n", "LOOP #2: Entered for loop at line 22-27\n", "BRANCH #2: Covered if branch at line 23-26\n", "LOOP #2: Entered for loop at line 22-27\n"]], "sampled_condition_paths": [["Line 22: (j in range(n))", "Line 23: (i * j == 0 or i == m - 1 or j == n - 1)", "Line 21: (i in range(m))", "Line 22: (j in range(n))", "Line 23: (i * j == 0 or i == m - 1 or j == n - 1)"], ["Line 22: (j in range(n))", "Line 23: (i * j == 0 or i == m - 1 or j == n - 1)", "Line 40: (row in board)", "Line 41: (i, c in enumerate(row))", "Line 42: NOT (c == '*')", "Line 44: "], ["Line 22: (j in range(n))", "Line 23: (i * j == 0 or i == m - 1 or j == n - 1)", "Line 22: (j in range(n))", "Line 23: (i * j == 0 or i == m - 1 or j == n - 1)", "Line 22: (j in range(n))"]]}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "difficulty": 3, "func_name": "minCut", "description": "Given a string `s`, partition `s` such that every substring of the partition\nis a palindrome.\n\nReturn the minimum cuts needed for a palindrome partitioning of `s`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "blocks": [{"type": "if", "start": 26, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 28, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      log_function('LOOP #1: Entered for loop at line 15-16\\n')\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      log_function('LOOP #2: Entered for loop at line 19-24\\n')\n      i = 0\n      for j in range(l - 1, n):\n        log_function('LOOP #3: Entered for loop at line 21-24\\n')\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      log_function('LOOP #4: Entered for loop at line 25-33\\n')\n      if isPalindrome[0][i]:\n        log_function('BRANCH #1: Covered if branch at line 26-28\\n')\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        log_function('LOOP #5: Entered for loop at line 30-33\\n')\n        if isPalindrome[j + 1][i]:\n          log_function('BRANCH #2: Covered if branch at line 31-32\\n')\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n\ndef log_function(info_str):\n    with open(\"test_logs/Palindrome Partitioning II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 21-24\n", "LOOP #3: Entered for loop at line 21-24\n", "LOOP #2: Entered for loop at line 19-24\n", "LOOP #3: Entered for loop at line 21-24\n", "LOOP #4: Entered for loop at line 25-33\n"], ["LOOP #3: Entered for loop at line 21-24\n", "LOOP #4: Entered for loop at line 25-33\n", "BRANCH #1: Covered if branch at line 26-28\n", "LOOP #4: Entered for loop at line 25-33\n", "LOOP #5: Entered for loop at line 30-33\n"], ["LOOP #2: Entered for loop at line 19-24\n", "LOOP #3: Entered for loop at line 21-24\n", "LOOP #4: Entered for loop at line 25-33\n", "BRANCH #1: Covered if branch at line 26-28\n", "LOOP #4: Entered for loop at line 25-33\n"], ["LOOP #1: Entered for loop at line 15-16\n", "LOOP #4: Entered for loop at line 25-33\n", "BRANCH #1: Covered if branch at line 26-28\n"]], "sampled_condition_paths": [["Line 21: (j in range(l - 1, n))", "Line 21: (j in range(l - 1, n))", "Line 19: (l in range(2, n + 1))", "Line 21: (j in range(l - 1, n))", "Line 25: (i in range(n))"], ["Line 21: (j in range(l - 1, n))", "Line 25: (i in range(n))", "Line 26: (isPalindrome[0][i])", "Line 25: (i in range(n))", "Line 30: (j in range(i))"], ["Line 19: (l in range(2, n + 1))", "Line 21: (j in range(l - 1, n))", "Line 25: (i in range(n))", "Line 26: (isPalindrome[0][i])", "Line 25: (i in range(n))"], ["Line 15: (_ in range(n))", "Line 25: (i in range(n))", "Line 26: (isPalindrome[0][i])"]]}
{"task_num": 218, "task_title": "The Skyline Problem", "difficulty": 3, "func_name": "getSkyline", "description": "A city's skyline is the outer contour of the silhouette formed by all the\nbuildings in that city when viewed from a distance. Given the locations and\nheights of all the buildings, return the skyline formed by these buildings\ncollectively.\n\nThe geometric information of each building is given in the array `buildings`\nwhere `buildings[i] = [lefti, righti, heighti]`:\n\n* `lefti` is the x coordinate of the left edge of the `ith` building.\n* `righti` is the x coordinate of the right edge of the `ith` building.\n* `heighti` is the height of the `ith` building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely\nflat surface at height `0`.\n\nThe skyline should be represented as a list of \"key points\" sorted by their\nx-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left\nendpoint of some horizontal segment in the skyline except the last point in\nthe list, which always has a y-coordinate `0` and is used to mark the\nskyline's termination where the rightmost building ends. Any ground between\nthe leftmost and rightmost buildings should be part of the skyline's contour.\n\nNote: There must be no consecutive horizontal lines of equal height in the\noutput skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is\nnot acceptable; the three lines of height 5 should be merged into one in the\nfinal output as such: `[...,[2 3],[4 5],[12 7],...]`\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 16, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 54, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 55, "end": 56, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 36, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [15, 17, 18, 33, 34, 35, 37, 38, 39, 53, 54, 56], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      log_function('BRANCH #1: Covered if branch at line 14-15\\n')\n      return []\n    if n == 1:\n      log_function('BRANCH #2: Covered if branch at line 16-18\\n')\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      log_function('LOOP #1: Entered while loop at line 31-40\\n')\n      if left[i][0] < right[j][0]:\n        log_function('BRANCH #3: Covered if branch at line 32-35\\n')\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        log_function('BRANCH #4: Covered else branch at line 36-39\\n')\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      log_function('LOOP #2: Entered while loop at line 41-44\\n')\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      log_function('LOOP #3: Entered while loop at line 45-48\\n')\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      log_function('BRANCH #5: Covered if branch at line 52-54\\n')\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      log_function('BRANCH #6: Covered if branch at line 55-56\\n')\n      return\n    ans.append([x, y])\n\ndef log_function(info_str):\n    with open(\"test_logs/The Skyline Problem.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 16-18\n", "LOOP #1: Entered while loop at line 31-40\n", "BRANCH #3: Covered if branch at line 32-35\n", "LOOP #1: Entered while loop at line 31-40\n", "BRANCH #4: Covered else branch at line 36-39\n"], ["LOOP #1: Entered while loop at line 31-40\n", "BRANCH #4: Covered else branch at line 36-39\n", "BRANCH #6: Covered if branch at line 55-56\n", "LOOP #1: Entered while loop at line 31-40\n", "BRANCH #3: Covered if branch at line 32-35\n"], ["LOOP #1: Entered while loop at line 31-40\n", "BRANCH #4: Covered else branch at line 36-39\n", "LOOP #2: Entered while loop at line 41-44\n", "BRANCH #2: Covered if branch at line 16-18\n", "BRANCH #2: Covered if branch at line 16-18\n"], ["BRANCH #4: Covered else branch at line 36-39\n", "LOOP #2: Entered while loop at line 41-44\n", "BRANCH #2: Covered if branch at line 16-18\n", "BRANCH #2: Covered if branch at line 16-18\n", "BRANCH #2: Covered if branch at line 16-18\n"]], "sampled_condition_paths": [["Line 16: (n == 1)", "Line 31: (i < len(left) and j < len(right))", "Line 32: (left[i][0] < right[j][0])", "Line 31: (i < len(left) and j < len(right))", "Line 32: NOT (left[i][0] < right[j][0])", "Line 36: "], ["Line 31: (i < len(left) and j < len(right))", "Line 32: NOT (left[i][0] < right[j][0])", "Line 36: ", "Line 55: (ans and ans[-1][1] == y)", "Line 31: (i < len(left) and j < len(right))", "Line 32: (left[i][0] < right[j][0])"], ["Line 31: (i < len(left) and j < len(right))", "Line 32: NOT (left[i][0] < right[j][0])", "Line 36: ", "Line 41: (i < len(left))", "Line 16: (n == 1)", "Line 16: (n == 1)"], ["Line 32: NOT (left[i][0] < right[j][0])", "Line 36: ", "Line 41: (i < len(left))", "Line 16: (n == 1)", "Line 16: (n == 1)", "Line 16: (n == 1)"]]}
{"task_num": 227, "task_title": "Basic Calculator II", "difficulty": 2, "func_name": "calculate", "description": "Given a string `s` which represents an expression, evaluate this expression\nand return its value.\n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate\nresults will be in the range of `[-231, 231 - 1]`.\n\nNote: You are not allowed to use any built-in function which evaluates strings\nas mathematical expressions, such as `eval()`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 23, 24, 25, 26, 27, 28, 29, 31, 32, 33], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      log_function('LOOP #1: Entered for loop at line 18-34\\n')\n      if c.isdigit():\n        log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        log_function('BRANCH #2: Covered if branch at line 21-33\\n')\n        if op == '+' or op == '-':\n          log_function('BRANCH #3: Covered if branch at line 22-24\\n')\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          log_function('BRANCH #4: Covered elif branch at line 25-26\\n')\n          prevNum = prevNum * currNum\n        elif op == '/':\n          log_function('BRANCH #5: Covered elif branch at line 27-31\\n')\n          if prevNum < 0:\n            log_function('BRANCH #6: Covered if branch at line 28-29\\n')\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            log_function('BRANCH #7: Covered else branch at line 30-31\\n')\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n\ndef log_function(info_str):\n    with open(\"test_logs/Basic Calculator II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 18-34\n", "BRANCH #1: Covered if branch at line 19-20\n", "LOOP #1: Entered for loop at line 18-34\n", "LOOP #1: Entered for loop at line 18-34\n", "BRANCH #2: Covered if branch at line 21-33\n"], ["BRANCH #1: Covered if branch at line 19-20\n", "LOOP #1: Entered for loop at line 18-34\n", "BRANCH #2: Covered if branch at line 21-33\n", "BRANCH #3: Covered if branch at line 22-24\n", "LOOP #1: Entered for loop at line 18-34\n"], ["BRANCH #1: Covered if branch at line 19-20\n", "LOOP #1: Entered for loop at line 18-34\n", "BRANCH #2: Covered if branch at line 21-33\n", "BRANCH #5: Covered elif branch at line 27-31\n", "BRANCH #7: Covered else branch at line 30-31\n"], ["LOOP #1: Entered for loop at line 18-34\n", "BRANCH #1: Covered if branch at line 19-20\n", "LOOP #1: Entered for loop at line 18-34\n", "BRANCH #2: Covered if branch at line 21-33\n", "BRANCH #3: Covered if branch at line 22-24\n"]], "sampled_condition_paths": [["Line 18: (i, c in enumerate(s))", "Line 19: (c.isdigit())", "Line 18: (i, c in enumerate(s))", "Line 18: (i, c in enumerate(s))", "Line 21: (not c.isdigit() and c != ' ' or i == len(s) - 1)"], ["Line 19: (c.isdigit())", "Line 18: (i, c in enumerate(s))", "Line 21: (not c.isdigit() and c != ' ' or i == len(s) - 1)", "Line 22: (op == '+' or op == '-')", "Line 18: (i, c in enumerate(s))"], ["Line 19: (c.isdigit())", "Line 18: (i, c in enumerate(s))", "Line 21: (not c.isdigit() and c != ' ' or i == len(s) - 1)", "Line 22: NOT (op == '+' or op == '-')", "Line 25: NOT (op == '*')", "Line 27: (op == '/')", "Line 28: NOT (prevNum < 0)", "Line 30: "], ["Line 18: (i, c in enumerate(s))", "Line 19: (c.isdigit())", "Line 18: (i, c in enumerate(s))", "Line 21: (not c.isdigit() and c != ' ' or i == len(s) - 1)", "Line 22: (op == '+' or op == '-')"]]}
{"task_num": 289, "task_title": "Game of Life", "difficulty": 2, "func_name": "gameOfLife", "description": "According to Wikipedia's article: \"The Game of Life, also known simply as\nLife, is a cellular automaton devised by the British mathematician John Horton\nConway in 1970.\"\n\nThe board is made up of an `m x n` grid of cells, where each cell has an\ninitial state: live (represented by a `1`) or dead (represented by a `0`).\nEach cell interacts with its eight neighbors (horizontal, vertical, diagonal)\nusing the following four rules (taken from the above Wikipedia article):\n\n1. Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2. Any live cell with two or three live neighbors lives on to the next generation.\n3. Any live cell with more than three live neighbors dies, as if by over-population.\n4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every\ncell in the current state, where births and deaths occur simultaneously. Given\nthe current state of the `m x n` grid `board`, return the next state.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [24, 27], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 16-28\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 17-28\\n')\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          log_function('LOOP #3: Entered for loop at line 19-22\\n')\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            log_function('LOOP #4: Entered for loop at line 20-22\\n')\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          log_function('BRANCH #1: Covered if branch at line 23-24\\n')\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          log_function('BRANCH #2: Covered if branch at line 26-27\\n')\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      log_function('LOOP #5: Entered for loop at line 29-32\\n')\n      for j in range(n):\n        log_function('LOOP #6: Entered for loop at line 30-32\\n')\n        board[i][j] >>= 1\n\ndef log_function(info_str):\n    with open(\"test_logs/Game of Life.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 19-22\n", "LOOP #4: Entered for loop at line 20-22\n", "LOOP #4: Entered for loop at line 20-22\n", "LOOP #5: Entered for loop at line 29-32\n", "LOOP #6: Entered for loop at line 30-32\n"], ["LOOP #4: Entered for loop at line 20-22\n", "LOOP #4: Entered for loop at line 20-22\n", "BRANCH #1: Covered if branch at line 23-24\n", "LOOP #2: Entered for loop at line 17-28\n", "LOOP #3: Entered for loop at line 19-22\n"], ["LOOP #3: Entered for loop at line 19-22\n", "LOOP #4: Entered for loop at line 20-22\n", "LOOP #4: Entered for loop at line 20-22\n", "BRANCH #2: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 17-28\n"], ["BRANCH #1: Covered if branch at line 23-24\n", "LOOP #2: Entered for loop at line 17-28\n", "LOOP #3: Entered for loop at line 19-22\n", "LOOP #4: Entered for loop at line 20-22\n", "LOOP #4: Entered for loop at line 20-22\n"]], "sampled_condition_paths": [["Line 19: (x in range(max(0, i - 1), min(m, i + 2)))", "Line 20: (y in range(max(0, j - 1), min(n, j + 2)))", "Line 20: (y in range(max(0, j - 1), min(n, j + 2)))", "Line 29: (i in range(m))", "Line 30: (j in range(n))"], ["Line 20: (y in range(max(0, j - 1), min(n, j + 2)))", "Line 20: (y in range(max(0, j - 1), min(n, j + 2)))", "Line 23: (board[i][j] == 1 and (ones == 3 or ones == 4))", "Line 17: (j in range(n))", "Line 19: (x in range(max(0, i - 1), min(m, i + 2)))"], ["Line 19: (x in range(max(0, i - 1), min(m, i + 2)))", "Line 20: (y in range(max(0, j - 1), min(n, j + 2)))", "Line 20: (y in range(max(0, j - 1), min(n, j + 2)))", "Line 26: (board[i][j] == 0 and ones == 3)", "Line 17: (j in range(n))"], ["Line 23: (board[i][j] == 1 and (ones == 3 or ones == 4))", "Line 17: (j in range(n))", "Line 19: (x in range(max(0, i - 1), min(m, i + 2)))", "Line 20: (y in range(max(0, j - 1), min(n, j + 2)))", "Line 20: (y in range(max(0, j - 1), min(n, j + 2)))"]]}
{"task_num": 310, "task_title": "Minimum Height Trees", "difficulty": 2, "func_name": "findMinHeightTrees", "description": "A tree is an undirected graph in which any two vertices are connected by\nexactly one path. In other words, any connected graph without simple cycles is\na tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n -\n1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected\nedge between the two nodes `ai` and `bi` in the tree, you can choose any node\nof the tree as the root. When you select a node `x` as the root, the result\ntree has height `h`. Among all possible rooted trees, those with minimum\nheight (i.e. `min(h)`) are called minimum height trees (MHTs).\n\nReturn a list of all MHTs' root labels. You can return the answer in any\norder.\n\nThe height of a rooted tree is the number of edges on the longest downward\npath between the root and a leaf.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 25, 34], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 19-22\\n')\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      log_function('LOOP #2: Entered for loop at line 23-26\\n')\n      if len(children) == 1:\n        log_function('BRANCH #2: Covered if branch at line 24-25\\n')\n        ans.append(label)\n\n    while n > 2:\n      log_function('LOOP #3: Entered while loop at line 27-36\\n')\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        log_function('LOOP #4: Entered for loop at line 30-34\\n')\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          log_function('BRANCH #3: Covered if branch at line 33-34\\n')\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Height Trees.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered while loop at line 27-36\n", "LOOP #4: Entered for loop at line 30-34\n", "LOOP #4: Entered for loop at line 30-34\n", "BRANCH #3: Covered if branch at line 33-34\n", "LOOP #4: Entered for loop at line 30-34\n"], ["LOOP #2: Entered for loop at line 23-26\n", "BRANCH #2: Covered if branch at line 24-25\n", "LOOP #2: Entered for loop at line 23-26\n", "BRANCH #2: Covered if branch at line 24-25\n", "LOOP #2: Entered for loop at line 23-26\n"], ["LOOP #2: Entered for loop at line 23-26\n", "BRANCH #2: Covered if branch at line 24-25\n", "LOOP #2: Entered for loop at line 23-26\n", "LOOP #2: Entered for loop at line 23-26\n", "BRANCH #2: Covered if branch at line 24-25\n"], ["LOOP #2: Entered for loop at line 23-26\n", "LOOP #2: Entered for loop at line 23-26\n", "BRANCH #2: Covered if branch at line 24-25\n", "LOOP #3: Entered while loop at line 27-36\n", "LOOP #4: Entered for loop at line 30-34\n"]], "sampled_condition_paths": [["Line 27: (n > 2)", "Line 30: (leaf in ans)", "Line 30: (leaf in ans)", "Line 33: (len(graph[u]) == 1)", "Line 30: (leaf in ans)"], ["Line 23: (label, children in graph.items())", "Line 24: (len(children) == 1)", "Line 23: (label, children in graph.items())", "Line 24: (len(children) == 1)", "Line 23: (label, children in graph.items())"], ["Line 23: (label, children in graph.items())", "Line 24: (len(children) == 1)", "Line 23: (label, children in graph.items())", "Line 23: (label, children in graph.items())", "Line 24: (len(children) == 1)"], ["Line 23: (label, children in graph.items())", "Line 23: (label, children in graph.items())", "Line 24: (len(children) == 1)", "Line 27: (n > 2)", "Line 30: (leaf in ans)"]]}
{"task_num": 327, "task_title": "Count of Range Sum", "difficulty": 3, "func_name": "countRangeSum", "description": "Given an integer array `nums` and two integers `lower` and `upper`, return the\nnumber of range sums that lie in `[lower, upper]` inclusive.\n\nRange sum `S(i, j)` is defined as the sum of the elements in `nums` between\nindices `i` and `j` inclusive, where `i <= j`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 46, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 50, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 47, 48, 49, 51, 52, 53], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      log_function('BRANCH #1: Covered if branch at line 21-22\\n')\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      log_function('LOOP #1: Entered for loop at line 33-39\\n')\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        log_function('LOOP #2: Entered while loop at line 34-35\\n')\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        log_function('LOOP #3: Entered while loop at line 36-37\\n')\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      log_function('LOOP #4: Entered while loop at line 45-54\\n')\n      if prefix[i] < prefix[j]:\n        log_function('BRANCH #2: Covered if branch at line 46-49\\n')\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        log_function('BRANCH #3: Covered else branch at line 50-53\\n')\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      log_function('LOOP #5: Entered while loop at line 55-59\\n')\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      log_function('LOOP #6: Entered while loop at line 60-64\\n')\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n\ndef log_function(info_str):\n    with open(\"test_logs/Count of Range Sum.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered while loop at line 36-37\n", "LOOP #4: Entered while loop at line 45-54\n", "BRANCH #3: Covered else branch at line 50-53\n", "LOOP #5: Entered while loop at line 55-59\n", "LOOP #1: Entered for loop at line 33-39\n"], ["BRANCH #1: Covered if branch at line 21-22\n", "LOOP #1: Entered for loop at line 33-39\n", "LOOP #3: Entered while loop at line 36-37\n", "LOOP #4: Entered while loop at line 45-54\n", "BRANCH #3: Covered else branch at line 50-53\n"]], "sampled_condition_paths": [["Line 36: (hi <= r and prefix[hi] - prefix[i] <= upper)", "Line 45: (i <= m and j <= r)", "Line 46: NOT (prefix[i] < prefix[j])", "Line 50: ", "Line 55: (i <= m)", "Line 33: (i in range(l, m + 1))"], ["Line 21: (l >= r)", "Line 33: (i in range(l, m + 1))", "Line 36: (hi <= r and prefix[hi] - prefix[i] <= upper)", "Line 45: (i <= m and j <= r)", "Line 46: NOT (prefix[i] < prefix[j])", "Line 50: "]]}
{"task_num": 335, "task_title": "Self Crossing", "difficulty": 3, "func_name": "isSelfCrossing", "description": "You are given an array of integers `distance`.\n\nYou start at the point `(0, 0)` on an X-Y plane, and you move `distance[0]`\nmeters to the north, then `distance[1]` meters to the west, `distance[2]`\nmeters to the south, `distance[3]` meters to the east, and so on. In other\nwords, after each move, your direction changes counter-clockwise.\n\nReturn `true` if your path crosses itself or `false` if it does not.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 1, "eg_cov_prob": 0.91}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.09}], "target_lines": [14, 18, 20, 22], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return False\n\n    for i in range(3, len(x)):\n      log_function('LOOP #1: Entered for loop at line 16-23\\n')\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        log_function('BRANCH #2: Covered if branch at line 17-18\\n')\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        log_function('BRANCH #3: Covered if branch at line 19-20\\n')\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        log_function('BRANCH #4: Covered if branch at line 21-22\\n')\n        return True\n\n    return False\n\ndef log_function(info_str):\n    with open(\"test_logs/Self Crossing.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 16-23\n", "BRANCH #2: Covered if branch at line 17-18\n"], ["LOOP #1: Entered for loop at line 16-23\n"]], "sampled_condition_paths": [["Line 16: (i in range(3, len(x)))", "Line 17: (x[i - 2] <= x[i] and x[i - 1] <= x[i - 3])"], ["Line 16: (i in range(3, len(x)))"]]}
{"task_num": 336, "task_title": "Palindrome Pairs", "difficulty": 3, "func_name": "palindromePairs", "description": "You are given a 0-indexed array of unique strings `words`.\n\nA palindrome pair is a pair of integers `(i, j)` such that:\n\n* `0 <= i, j < words.length`,\n* `i != j`, and\n* `words[i] + words[j]` (the concatenation of the two strings) is a palindrome.\n\nReturn an array of all the palindrome pairs of `words`.\n\nYou must write an algorithm with `O(sum of words[i].length)` runtime\ncomplexity.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "blocks": [{"type": "if", "start": 17, "end": 18, "difficulty": 1, "eg_cov_prob": 0.93}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.72}, {"type": "if", "start": 25, "end": 26, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [18, 24, 26], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      log_function('LOOP #1: Entered for loop at line 16-27\\n')\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        log_function('BRANCH #1: Covered if branch at line 17-18\\n')\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        log_function('LOOP #2: Entered for loop at line 20-27\\n')\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          log_function('BRANCH #2: Covered if branch at line 23-24\\n')\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          log_function('BRANCH #3: Covered if branch at line 25-26\\n')\n          ans.append([dict[r], i])\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Palindrome Pairs.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 20-27\n", "LOOP #2: Entered for loop at line 20-27\n", "BRANCH #2: Covered if branch at line 23-24\n", "LOOP #1: Entered for loop at line 16-27\n", "LOOP #2: Entered for loop at line 20-27\n"], ["LOOP #2: Entered for loop at line 20-27\n", "LOOP #2: Entered for loop at line 20-27\n", "LOOP #2: Entered for loop at line 20-27\n", "BRANCH #2: Covered if branch at line 23-24\n", "LOOP #1: Entered for loop at line 16-27\n"], ["LOOP #1: Entered for loop at line 16-27\n", "BRANCH #1: Covered if branch at line 17-18\n", "LOOP #2: Entered for loop at line 20-27\n", "BRANCH #3: Covered if branch at line 25-26\n", "LOOP #1: Entered for loop at line 16-27\n"]], "sampled_condition_paths": [["Line 20: (j in range(1, len(word) + 1))", "Line 20: (j in range(1, len(word) + 1))", "Line 23: (l in dict and dict[l] != i and r == r[::-1])", "Line 16: (i, word in enumerate(words))", "Line 20: (j in range(1, len(word) + 1))"], ["Line 20: (j in range(1, len(word) + 1))", "Line 20: (j in range(1, len(word) + 1))", "Line 20: (j in range(1, len(word) + 1))", "Line 23: (l in dict and dict[l] != i and r == r[::-1])", "Line 16: (i, word in enumerate(words))"], ["Line 16: (i, word in enumerate(words))", "Line 17: (\"\" in dict and dict[\"\"] != i and word == word[::-1])", "Line 20: (j in range(1, len(word) + 1))", "Line 25: (r in dict and dict[r] != i and l == l[::-1])", "Line 16: (i, word in enumerate(words))"]]}
{"task_num": 391, "task_title": "Perfect Rectangle", "difficulty": 3, "func_name": "isRectangleCover", "description": "Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]`\nrepresents an axis-aligned rectangle. The bottom-left point of the rectangle\nis `(xi, yi)` and the top-right point of it is `(ai, bi)`.\n\nReturn `true` if all the rectangles together form an exact cover of a\nrectangular region.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "blocks": [{"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 1, "eg_cov_prob": 0.47}, {"type": "else", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [29, 31, 34, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      log_function('LOOP #1: Entered for loop at line 20-32\\n')\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        log_function('LOOP #2: Entered for loop at line 27-32\\n')\n        if point in corners:\n          log_function('BRANCH #1: Covered if branch at line 28-29\\n')\n          corners.remove(point)\n        else:\n          log_function('BRANCH #2: Covered else branch at line 30-31\\n')\n          corners.add(point)\n\n    if len(corners) != 4:\n      log_function('BRANCH #3: Covered if branch at line 33-34\\n')\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      log_function('BRANCH #4: Covered if branch at line 35-36\\n')\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n\ndef log_function(info_str):\n    with open(\"test_logs/Perfect Rectangle.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 27-32\n", "BRANCH #2: Covered else branch at line 30-31\n", "LOOP #2: Entered for loop at line 27-32\n", "BRANCH #2: Covered else branch at line 30-31\n", "LOOP #1: Entered for loop at line 20-32\n"], ["BRANCH #2: Covered else branch at line 30-31\n", "LOOP #2: Entered for loop at line 27-32\n", "BRANCH #2: Covered else branch at line 30-31\n", "LOOP #1: Entered for loop at line 20-32\n", "LOOP #2: Entered for loop at line 27-32\n"], ["LOOP #1: Entered for loop at line 20-32\n", "LOOP #2: Entered for loop at line 27-32\n", "BRANCH #1: Covered if branch at line 28-29\n", "LOOP #2: Entered for loop at line 27-32\n", "BRANCH #2: Covered else branch at line 30-31\n"], ["BRANCH #1: Covered if branch at line 28-29\n", "LOOP #2: Entered for loop at line 27-32\n", "BRANCH #2: Covered else branch at line 30-31\n", "LOOP #2: Entered for loop at line 27-32\n", "BRANCH #1: Covered if branch at line 28-29\n"], ["LOOP #2: Entered for loop at line 27-32\n", "BRANCH #2: Covered else branch at line 30-31\n", "LOOP #2: Entered for loop at line 27-32\n", "BRANCH #2: Covered else branch at line 30-31\n", "LOOP #2: Entered for loop at line 27-32\n"]], "sampled_condition_paths": [["Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: NOT (point in corners)", "Line 30: ", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: NOT (point in corners)", "Line 30: ", "Line 20: (x, y, a, b in rectangles)"], ["Line 28: NOT (point in corners)", "Line 30: ", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: NOT (point in corners)", "Line 30: ", "Line 20: (x, y, a, b in rectangles)", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])"], ["Line 20: (x, y, a, b in rectangles)", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: (point in corners)", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: NOT (point in corners)", "Line 30: "], ["Line 28: (point in corners)", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: NOT (point in corners)", "Line 30: ", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: (point in corners)"], ["Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: NOT (point in corners)", "Line 30: ", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])", "Line 28: NOT (point in corners)", "Line 30: ", "Line 27: (point in [(x, y), (x, b), (a, y), (a, b)])"]]}
{"task_num": 402, "task_title": "Remove K Digits", "difficulty": 2, "func_name": "removeKdigits", "description": "Given string num representing a non-negative integer `num`, and an integer\n`k`, return the smallest possible integer after removing `k` digits from\n`num`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 30], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      log_function('LOOP #1: Entered for loop at line 19-24\\n')\n      while k > 0 and stack and stack[-1] > digit:\n        log_function('LOOP #2: Entered while loop at line 20-22\\n')\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      log_function('LOOP #3: Entered for loop at line 25-27\\n')\n      stack.pop()\n\n    for c in stack:\n      log_function('LOOP #4: Entered for loop at line 28-32\\n')\n      if c == '0' and not ans:\n        log_function('BRANCH #2: Covered if branch at line 29-30\\n')\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n\ndef log_function(info_str):\n    with open(\"test_logs/Remove K Digits.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 28-32\n", "BRANCH #2: Covered if branch at line 29-30\n", "LOOP #4: Entered for loop at line 28-32\n", "LOOP #4: Entered for loop at line 28-32\n", "LOOP #4: Entered for loop at line 28-32\n"], ["LOOP #1: Entered for loop at line 19-24\n", "LOOP #2: Entered while loop at line 20-22\n", "LOOP #1: Entered for loop at line 19-24\n", "LOOP #1: Entered for loop at line 19-24\n", "LOOP #2: Entered while loop at line 20-22\n"], ["BRANCH #1: Covered if branch at line 13-14\n"], ["LOOP #2: Entered while loop at line 20-22\n", "LOOP #1: Entered for loop at line 19-24\n", "LOOP #1: Entered for loop at line 19-24\n", "LOOP #2: Entered while loop at line 20-22\n", "LOOP #1: Entered for loop at line 19-24\n"]], "sampled_condition_paths": [["Line 28: (c in stack)", "Line 29: (c == '0' and not ans)", "Line 28: (c in stack)", "Line 28: (c in stack)", "Line 28: (c in stack)"], ["Line 19: (i, digit in enumerate(num))", "Line 20: (k > 0 and stack and stack[-1] > digit)", "Line 19: (i, digit in enumerate(num))", "Line 19: (i, digit in enumerate(num))", "Line 20: (k > 0 and stack and stack[-1] > digit)"], ["Line 13: (len(num) == k)"], ["Line 20: (k > 0 and stack and stack[-1] > digit)", "Line 19: (i, digit in enumerate(num))", "Line 19: (i, digit in enumerate(num))", "Line 20: (k > 0 and stack and stack[-1] > digit)", "Line 19: (i, digit in enumerate(num))"]]}
{"task_num": 407, "task_title": "Trapping Rain Water II", "difficulty": 3, "func_name": "trapRainWater", "description": "Given an `m x n` integer matrix `heightMap` representing the height of each\nunit cell in a 2D elevation map, return the volume of water it can trap after\nraining.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "blocks": [{"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 43, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "else", "start": 44, "end": 45, "difficulty": 1, "eg_cov_prob": 0.96}], "target_lines": [38, 40, 42, 43, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 20-25\\n')\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      log_function('LOOP #2: Entered for loop at line 26-31\\n')\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      log_function('LOOP #3: Entered while loop at line 32-47\\n')\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        log_function('LOOP #4: Entered for loop at line 34-47\\n')\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          log_function('BRANCH #1: Covered if branch at line 37-38\\n')\n          continue\n        if (x, y) in seen:\n          log_function('BRANCH #2: Covered if branch at line 39-40\\n')\n          continue\n        if heightMap[x][y] < h:\n          log_function('BRANCH #3: Covered if branch at line 41-43\\n')\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          log_function('BRANCH #4: Covered else branch at line 44-45\\n')\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Trapping Rain Water II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 34-47\n", "BRANCH #4: Covered else branch at line 44-45\n", "LOOP #4: Entered for loop at line 34-47\n", "BRANCH #2: Covered if branch at line 39-40\n", "LOOP #4: Entered for loop at line 34-47\n"], ["LOOP #4: Entered for loop at line 34-47\n", "BRANCH #2: Covered if branch at line 39-40\n", "LOOP #4: Entered for loop at line 34-47\n", "BRANCH #1: Covered if branch at line 37-38\n", "LOOP #3: Entered while loop at line 32-47\n"], ["BRANCH #2: Covered if branch at line 39-40\n", "LOOP #4: Entered for loop at line 34-47\n", "BRANCH #2: Covered if branch at line 39-40\n", "LOOP #4: Entered for loop at line 34-47\n", "BRANCH #2: Covered if branch at line 39-40\n"], ["LOOP #3: Entered while loop at line 32-47\n", "LOOP #4: Entered for loop at line 34-47\n", "BRANCH #1: Covered if branch at line 37-38\n", "LOOP #4: Entered for loop at line 34-47\n", "BRANCH #2: Covered if branch at line 39-40\n"]], "sampled_condition_paths": [["Line 34: (dx, dy in dirs)", "Line 41: NOT (heightMap[x][y] < h)", "Line 44: ", "Line 34: (dx, dy in dirs)", "Line 39: ((x, y) in seen)", "Line 34: (dx, dy in dirs)"], ["Line 34: (dx, dy in dirs)", "Line 39: ((x, y) in seen)", "Line 34: (dx, dy in dirs)", "Line 37: (x < 0 or x == m or y < 0 or y == n)", "Line 32: (minHeap)"], ["Line 39: ((x, y) in seen)", "Line 34: (dx, dy in dirs)", "Line 39: ((x, y) in seen)", "Line 34: (dx, dy in dirs)", "Line 39: ((x, y) in seen)"], ["Line 32: (minHeap)", "Line 34: (dx, dy in dirs)", "Line 37: (x < 0 or x == m or y < 0 or y == n)", "Line 34: (dx, dy in dirs)", "Line 39: ((x, y) in seen)"]]}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "difficulty": 2, "func_name": "pacificAtlantic", "description": "There is an `m x n` rectangular island that borders both the Pacific Ocean and\nAtlantic Ocean. The Pacific Ocean touches the island's left and top edges, and\nthe Atlantic Ocean touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x\nn` integer matrix `heights` where `heights[r][c]` represents the height above\nsea level of the cell at coordinate `(r, c)`.\n\nThe island receives a lot of rain, and the rain water can flow to neighboring\ncells directly north, south, east, and west if the neighboring cell's height\nis less than or equal to the current cell's height. Water can flow from any\ncell adjacent to an ocean into the ocean.\n\nReturn a 2D list of grid coordinates `result` where `result[i] = [ri, ci]`\ndenotes that rain water can flow from cell `(ri, ci)` to both the Pacific and\nAtlantic oceans.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "blocks": [{"type": "if", "start": 53, "end": 54, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 40, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [41, 43, 54], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 21-26\\n')\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      log_function('LOOP #2: Entered for loop at line 27-32\\n')\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        log_function('LOOP #3: Entered while loop at line 34-46\\n')\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          log_function('LOOP #4: Entered for loop at line 37-46\\n')\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            log_function('BRANCH #1: Covered if branch at line 40-41\\n')\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            log_function('BRANCH #2: Covered if branch at line 42-43\\n')\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      log_function('LOOP #5: Entered for loop at line 51-54\\n')\n      for j in range(n):\n        log_function('LOOP #6: Entered for loop at line 52-54\\n')\n        if seenP[i][j] and seenA[i][j]:\n          log_function('BRANCH #3: Covered if branch at line 53-54\\n')\n          res.append([i, j])\n    return res\n\ndef log_function(info_str):\n    with open(\"test_logs/Pacific Atlantic Water Flow.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 40-41\n", "LOOP #4: Entered for loop at line 37-46\n", "BRANCH #1: Covered if branch at line 40-41\n", "LOOP #5: Entered for loop at line 51-54\n", "LOOP #6: Entered for loop at line 52-54\n"], ["LOOP #4: Entered for loop at line 37-46\n", "BRANCH #1: Covered if branch at line 40-41\n", "LOOP #3: Entered while loop at line 34-46\n", "LOOP #4: Entered for loop at line 37-46\n", "BRANCH #1: Covered if branch at line 40-41\n"], ["BRANCH #2: Covered if branch at line 42-43\n", "LOOP #4: Entered for loop at line 37-46\n", "BRANCH #2: Covered if branch at line 42-43\n", "LOOP #3: Entered while loop at line 34-46\n", "LOOP #4: Entered for loop at line 37-46\n"], ["LOOP #4: Entered for loop at line 37-46\n", "BRANCH #1: Covered if branch at line 40-41\n", "LOOP #4: Entered for loop at line 37-46\n", "BRANCH #1: Covered if branch at line 40-41\n", "LOOP #3: Entered while loop at line 34-46\n"]], "sampled_condition_paths": [["Line 40: (x < 0 or x == m or y < 0 or y == n)", "Line 37: (dx, dy in dirs)", "Line 40: (x < 0 or x == m or y < 0 or y == n)", "Line 51: (i in range(m))", "Line 52: (j in range(n))"], ["Line 37: (dx, dy in dirs)", "Line 40: (x < 0 or x == m or y < 0 or y == n)", "Line 34: (q)", "Line 37: (dx, dy in dirs)", "Line 40: (x < 0 or x == m or y < 0 or y == n)"], ["Line 42: (seen[x][y] or heights[x][y] < h)", "Line 37: (dx, dy in dirs)", "Line 42: (seen[x][y] or heights[x][y] < h)", "Line 34: (q)", "Line 37: (dx, dy in dirs)"], ["Line 37: (dx, dy in dirs)", "Line 40: (x < 0 or x == m or y < 0 or y == n)", "Line 37: (dx, dy in dirs)", "Line 40: (x < 0 or x == m or y < 0 or y == n)", "Line 34: (q)"]]}
{"task_num": 420, "task_title": "Strong Password Checker", "difficulty": 3, "func_name": "strongPasswordChecker", "description": "A password is considered strong if the below conditions are all met:\n\n* It has at least `6` characters and at most `20` characters.\n* It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\n* It does not contain three repeating characters in a row (i.e., `\"Baaabb0\"` is weak, but `\"Baaba0\"` is strong).\n\nGiven a string `password`, return the minimum number of steps required to make\n`password` strong. if `password` is already strong, return `0`.\n\nIn one step, you can:\n\n* Insert one character to `password`,\n* Delete one character from `password`, or\n* Replace one character of `password` with another character.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "blocks": [{"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.09}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.25}, {"type": "if", "start": 21, "end": 30, "difficulty": 2, "eg_cov_prob": 0.01}, {"type": "else", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.01}, {"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      log_function('LOOP #1: Entered while loop at line 20-33\\n')\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        log_function('BRANCH #1: Covered if branch at line 21-30\\n')\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          log_function('LOOP #2: Entered while loop at line 23-25\\n')\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          log_function('BRANCH #2: Covered if branch at line 27-28\\n')\n          oneSeq += 1\n        if length % 3 == 1:\n          log_function('BRANCH #3: Covered if branch at line 29-30\\n')\n          twoSeq += 1\n      else:\n        log_function('BRANCH #4: Covered else branch at line 31-32\\n')\n        i += 1\n\n    if n < 6:\n      log_function('BRANCH #5: Covered if branch at line 34-35\\n')\n      return max(6 - n, missing)\n    if n <= 20:\n      log_function('BRANCH #6: Covered if branch at line 36-37\\n')\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n\ndef log_function(info_str):\n    with open(\"test_logs/Strong Password Checker.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #5: Covered if branch at line 34-35\n"], ["BRANCH #4: Covered else branch at line 31-32\n", "LOOP #1: Entered while loop at line 20-33\n", "BRANCH #4: Covered else branch at line 31-32\n", "LOOP #1: Entered while loop at line 20-33\n", "BRANCH #4: Covered else branch at line 31-32\n"], ["LOOP #1: Entered while loop at line 20-33\n", "BRANCH #4: Covered else branch at line 31-32\n", "BRANCH #5: Covered if branch at line 34-35\n"]], "sampled_condition_paths": [["Line 34: (n < 6)"], ["Line 21: NOT (password[i] == password[i - 1] and password[i - 1] == password[i - 2])", "Line 31: ", "Line 20: (i < n)", "Line 21: NOT (password[i] == password[i - 1] and password[i - 1] == password[i - 2])", "Line 31: ", "Line 20: (i < n)", "Line 21: NOT (password[i] == password[i - 1] and password[i - 1] == password[i - 2])", "Line 31: "], ["Line 20: (i < n)", "Line 21: NOT (password[i] == password[i - 1] and password[i - 1] == password[i - 2])", "Line 31: ", "Line 34: (n < 6)"]]}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "difficulty": 2, "func_name": "originalDigits", "description": "Given a string `s` containing an out-of-order English representation of digits\n`0-9`, return the digits in ascending order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 19, 21, 23, 25, 27, 29, 31, 33, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      log_function('LOOP #1: Entered for loop at line 15-36\\n')\n      if c == 'z':\n        log_function('BRANCH #1: Covered if branch at line 16-17\\n')\n        count[0] += 1\n      if c == 'o':\n        log_function('BRANCH #2: Covered if branch at line 18-19\\n')\n        count[1] += 1\n      if c == 'w':\n        log_function('BRANCH #3: Covered if branch at line 20-21\\n')\n        count[2] += 1\n      if c == 'h':\n        log_function('BRANCH #4: Covered if branch at line 22-23\\n')\n        count[3] += 1\n      if c == 'u':\n        log_function('BRANCH #5: Covered if branch at line 24-25\\n')\n        count[4] += 1\n      if c == 'f':\n        log_function('BRANCH #6: Covered if branch at line 26-27\\n')\n        count[5] += 1\n      if c == 'x':\n        log_function('BRANCH #7: Covered if branch at line 28-29\\n')\n        count[6] += 1\n      if c == 's':\n        log_function('BRANCH #8: Covered if branch at line 30-31\\n')\n        count[7] += 1\n      if c == 'g':\n        log_function('BRANCH #9: Covered if branch at line 32-33\\n')\n        count[8] += 1\n      if c == 'i':\n        log_function('BRANCH #10: Covered if branch at line 34-35\\n')\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n\ndef log_function(info_str):\n    with open(\"test_logs/Reconstruct Original Digits from English.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 15-36\n", "BRANCH #6: Covered if branch at line 26-27\n", "LOOP #1: Entered for loop at line 15-36\n", "BRANCH #5: Covered if branch at line 24-25\n", "LOOP #1: Entered for loop at line 15-36\n"], ["LOOP #1: Entered for loop at line 15-36\n", "BRANCH #2: Covered if branch at line 18-19\n", "LOOP #1: Entered for loop at line 15-36\n", "BRANCH #1: Covered if branch at line 16-17\n", "LOOP #1: Entered for loop at line 15-36\n"], ["BRANCH #10: Covered if branch at line 34-35\n", "LOOP #1: Entered for loop at line 15-36\n", "LOOP #1: Entered for loop at line 15-36\n", "BRANCH #6: Covered if branch at line 26-27\n", "LOOP #1: Entered for loop at line 15-36\n"], ["BRANCH #2: Covered if branch at line 18-19\n", "LOOP #1: Entered for loop at line 15-36\n", "BRANCH #3: Covered if branch at line 20-21\n", "LOOP #1: Entered for loop at line 15-36\n", "BRANCH #2: Covered if branch at line 18-19\n"]], "sampled_condition_paths": [["Line 15: (c in s)", "Line 26: (c == 'f')", "Line 15: (c in s)", "Line 24: (c == 'u')", "Line 15: (c in s)"], ["Line 15: (c in s)", "Line 18: (c == 'o')", "Line 15: (c in s)", "Line 16: (c == 'z')", "Line 15: (c in s)"], ["Line 34: (c == 'i')", "Line 15: (c in s)", "Line 15: (c in s)", "Line 26: (c == 'f')", "Line 15: (c in s)"], ["Line 18: (c == 'o')", "Line 15: (c in s)", "Line 20: (c == 'w')", "Line 15: (c in s)", "Line 18: (c == 'o')"]]}
{"task_num": 457, "task_title": "Circular Array Loop", "difficulty": 2, "func_name": "circularArrayLoop", "description": "You are playing a game involving a circular array of non-zero integers `nums`.\nEach `nums[i]` denotes the number of indices forward/backward you must move if\nyou are located at index `i`:\n\n* If `nums[i]` is positive, move `nums[i]` steps forward, and\n* If `nums[i]` is negative, move `nums[i]` steps backward.\n\nSince the array is circular, you may assume that moving forward from the last\nelement puts you on the first element, and moving backwards from the first\nelement puts you on the last element.\n\nA cycle in the array consists of a sequence of indices `seq` of length `k`\nwhere:\n\n* Following the movement rules above results in the repeating index sequence `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`\n* Every `nums[seq[j]]` is either all positive or all negative.\n* `k > 1`\n\nReturn `true` if there is a cycle in `nums`, or `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 20, "end": 21, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "if", "start": 26, "end": 29, "difficulty": 2, "eg_cov_prob": 0.2}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.09}], "target_lines": [17, 21, 27, 28, 29], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      log_function('BRANCH #1: Covered if branch at line 16-17\\n')\n      return False\n\n    for i, num in enumerate(nums):\n      log_function('LOOP #1: Entered for loop at line 19-39\\n')\n      if num == 0:\n        log_function('BRANCH #2: Covered if branch at line 20-21\\n')\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        log_function('LOOP #2: Entered while loop at line 25-32\\n')\n        if slow == fast:\n          log_function('BRANCH #3: Covered if branch at line 26-29\\n')\n          if slow == advance(slow):\n            log_function('BRANCH #4: Covered if branch at line 27-28\\n')\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        log_function('LOOP #3: Entered while loop at line 35-39\\n')\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n\ndef log_function(info_str):\n    with open(\"test_logs/Circular Array Loop.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 26-29\n", "BRANCH #4: Covered if branch at line 27-28\n", "LOOP #3: Entered while loop at line 35-39\n", "LOOP #1: Entered for loop at line 19-39\n", "LOOP #2: Entered while loop at line 25-32\n"], ["LOOP #3: Entered while loop at line 35-39\n", "LOOP #1: Entered for loop at line 19-39\n", "LOOP #3: Entered while loop at line 35-39\n", "LOOP #1: Entered for loop at line 19-39\n", "LOOP #2: Entered while loop at line 25-32\n"], ["LOOP #1: Entered for loop at line 19-39\n", "LOOP #2: Entered while loop at line 25-32\n", "LOOP #2: Entered while loop at line 25-32\n", "LOOP #2: Entered while loop at line 25-32\n", "BRANCH #3: Covered if branch at line 26-29\n"], ["LOOP #3: Entered while loop at line 35-39\n", "LOOP #1: Entered for loop at line 19-39\n", "LOOP #3: Entered while loop at line 35-39\n", "LOOP #1: Entered for loop at line 19-39\n", "LOOP #3: Entered while loop at line 35-39\n"]], "sampled_condition_paths": [["Line 26: (slow == fast)", "Line 27: (slow == advance(slow))", "Line 35: (sign * nums[slow] > 0)", "Line 19: (i, num in enumerate(nums))", "Line 25: (num * nums[fast] > 0 and num * nums[advance(fast)] > 0)"], ["Line 35: (sign * nums[slow] > 0)", "Line 19: (i, num in enumerate(nums))", "Line 35: (sign * nums[slow] > 0)", "Line 19: (i, num in enumerate(nums))", "Line 25: (num * nums[fast] > 0 and num * nums[advance(fast)] > 0)"], ["Line 19: (i, num in enumerate(nums))", "Line 25: (num * nums[fast] > 0 and num * nums[advance(fast)] > 0)", "Line 25: (num * nums[fast] > 0 and num * nums[advance(fast)] > 0)", "Line 25: (num * nums[fast] > 0 and num * nums[advance(fast)] > 0)", "Line 26: (slow == fast)"], ["Line 35: (sign * nums[slow] > 0)", "Line 19: (i, num in enumerate(nums))", "Line 35: (sign * nums[slow] > 0)", "Line 19: (i, num in enumerate(nums))", "Line 35: (sign * nums[slow] > 0)"]]}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "difficulty": 2, "func_name": "findLongestWord", "description": "Given a string `s` and a string array `dictionary`, return the longest string\nin the dictionary that can be formed by deleting some of the given string\ncharacters. If there is more than one possible result, return the longest word\nwith the smallest lexicographical order. If there is no possible result,\nreturn the empty string.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "blocks": [{"type": "if", "start": 20, "end": 22, "difficulty": 1, "eg_cov_prob": 0.89}, {"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.89}], "target_lines": [19, 21, 22], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      log_function('LOOP #1: Entered for loop at line 15-23\\n')\n      i = 0\n      for c in s:\n        log_function('LOOP #2: Entered for loop at line 17-19\\n')\n        if i < len(word) and c == word[i]:\n          log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n          i += 1\n      if i == len(word):\n        log_function('BRANCH #2: Covered if branch at line 20-22\\n')\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          log_function('BRANCH #3: Covered if branch at line 21-22\\n')\n          ans = word\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Longest Word in Dictionary through Deleting.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 17-19\n"], ["LOOP #2: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 17-19\n", "LOOP #1: Entered for loop at line 15-23\n", "LOOP #2: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 17-19\n"], ["LOOP #2: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 17-19\n", "BRANCH #2: Covered if branch at line 20-22\n", "BRANCH #3: Covered if branch at line 21-22\n"], ["LOOP #2: Entered for loop at line 17-19\n", "BRANCH #1: Covered if branch at line 18-19\n", "LOOP #2: Entered for loop at line 17-19\n", "BRANCH #1: Covered if branch at line 18-19\n", "LOOP #2: Entered for loop at line 17-19\n"]], "sampled_condition_paths": [["Line 17: (c in s)", "Line 17: (c in s)", "Line 17: (c in s)", "Line 17: (c in s)", "Line 17: (c in s)"], ["Line 17: (c in s)", "Line 17: (c in s)", "Line 15: (word in d)", "Line 17: (c in s)", "Line 17: (c in s)"], ["Line 17: (c in s)", "Line 17: (c in s)", "Line 17: (c in s)", "Line 20: (i == len(word))", "Line 21: (len(word) > len(ans) or len(word) == len(ans) and word < ans)"], ["Line 17: (c in s)", "Line 18: (i < len(word) and c == word[i])", "Line 17: (c in s)", "Line 18: (i < len(word) and c == word[i])", "Line 17: (c in s)"]]}
{"task_num": 542, "task_title": "01 Matrix", "difficulty": 2, "func_name": "updateMatrix", "description": "Given an `m x n` binary matrix `mat`, return the distance of the nearest `0`\nfor each cell.\n\nThe distance between two adjacent cells is `1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "blocks": [{"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 31, 33], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 19-24\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-24\\n')\n        if mat[i][j] == 0:\n          log_function('BRANCH #1: Covered if branch at line 21-23\\n')\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      log_function('LOOP #3: Entered while loop at line 25-37\\n')\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        log_function('LOOP #4: Entered for loop at line 27-37\\n')\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n          continue\n        if seen[x][y]:\n          log_function('BRANCH #3: Covered if branch at line 32-33\\n')\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n\ndef log_function(info_str):\n    with open(\"test_logs/01 Matrix.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 32-33\n", "LOOP #3: Entered while loop at line 25-37\n", "LOOP #4: Entered for loop at line 27-37\n", "BRANCH #3: Covered if branch at line 32-33\n", "LOOP #4: Entered for loop at line 27-37\n"], ["BRANCH #2: Covered if branch at line 30-31\n", "LOOP #3: Entered while loop at line 25-37\n", "LOOP #4: Entered for loop at line 27-37\n", "BRANCH #3: Covered if branch at line 32-33\n", "LOOP #4: Entered for loop at line 27-37\n"], ["BRANCH #3: Covered if branch at line 32-33\n", "LOOP #4: Entered for loop at line 27-37\n", "BRANCH #3: Covered if branch at line 32-33\n", "LOOP #4: Entered for loop at line 27-37\n", "BRANCH #2: Covered if branch at line 30-31\n"], ["BRANCH #3: Covered if branch at line 32-33\n", "LOOP #4: Entered for loop at line 27-37\n", "BRANCH #3: Covered if branch at line 32-33\n", "LOOP #3: Entered while loop at line 25-37\n", "LOOP #4: Entered for loop at line 27-37\n"]], "sampled_condition_paths": [["Line 32: (seen[x][y])", "Line 25: (q)", "Line 27: (dx, dy in dirs)", "Line 32: (seen[x][y])", "Line 27: (dx, dy in dirs)"], ["Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 25: (q)", "Line 27: (dx, dy in dirs)", "Line 32: (seen[x][y])", "Line 27: (dx, dy in dirs)"], ["Line 32: (seen[x][y])", "Line 27: (dx, dy in dirs)", "Line 32: (seen[x][y])", "Line 27: (dx, dy in dirs)", "Line 30: (x < 0 or x == m or y < 0 or y == n)"], ["Line 32: (seen[x][y])", "Line 27: (dx, dy in dirs)", "Line 32: (seen[x][y])", "Line 25: (q)", "Line 27: (dx, dy in dirs)"]]}
{"task_num": 547, "task_title": "Number of Provinces", "difficulty": 2, "func_name": "findCircleNum", "description": "There are `n` cities. Some of them are connected, while some are not. If city\n`a` is connected directly with city `b`, and city `b` is connected directly\nwith city `c`, then city `a` is connected indirectly with city `c`.\n\nA province is a group of directly or indirectly connected cities and no other\ncities outside of the group.\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if\nthe `ith` city and the `jth` city are directly connected, and\n`isConnected[i][j] = 0` otherwise.\n\nReturn the total number of provinces.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 1, "eg_cov_prob": 0.53}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 26, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 23, 25, 27, 28, 33, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 22-23\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 24-25\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 26-28\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 32-33\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      log_function('LOOP #1: Entered for loop at line 42-46\\n')\n      for j in range(i, n):\n        log_function('LOOP #2: Entered for loop at line 43-46\\n')\n        if isConnected[i][j] == 1:\n          log_function('BRANCH #6: Covered if branch at line 44-45\\n')\n          uf.unionByRank(i, j)\n\n    return uf.count\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Provinces.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 43-46\n", "LOOP #1: Entered for loop at line 42-46\n", "LOOP #2: Entered for loop at line 43-46\n", "BRANCH #6: Covered if branch at line 44-45\n", "BRANCH #1: Covered if branch at line 20-21\n"], ["BRANCH #1: Covered if branch at line 20-21\n", "LOOP #2: Entered for loop at line 43-46\n", "LOOP #1: Entered for loop at line 42-46\n", "LOOP #2: Entered for loop at line 43-46\n", "BRANCH #6: Covered if branch at line 44-45\n"], ["BRANCH #1: Covered if branch at line 20-21\n", "LOOP #2: Entered for loop at line 43-46\n", "LOOP #2: Entered for loop at line 43-46\n", "LOOP #1: Entered for loop at line 42-46\n", "LOOP #2: Entered for loop at line 43-46\n"], ["BRANCH #6: Covered if branch at line 44-45\n", "BRANCH #1: Covered if branch at line 20-21\n", "LOOP #2: Entered for loop at line 43-46\n", "LOOP #1: Entered for loop at line 42-46\n", "LOOP #2: Entered for loop at line 43-46\n"]], "sampled_condition_paths": [["Line 43: (j in range(i, n))", "Line 42: (i in range(n))", "Line 43: (j in range(i, n))", "Line 44: (isConnected[i][j] == 1)", "Line 20: (i == j)"], ["Line 20: (i == j)", "Line 43: (j in range(i, n))", "Line 42: (i in range(n))", "Line 43: (j in range(i, n))", "Line 44: (isConnected[i][j] == 1)"], ["Line 20: (i == j)", "Line 43: (j in range(i, n))", "Line 43: (j in range(i, n))", "Line 42: (i in range(n))", "Line 43: (j in range(i, n))"], ["Line 44: (isConnected[i][j] == 1)", "Line 20: (i == j)", "Line 43: (j in range(i, n))", "Line 42: (i in range(n))", "Line 43: (j in range(i, n))"]]}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "difficulty": 2, "func_name": "findUnsortedSubarray", "description": "Given an integer array `nums`, you need to find one continuous subarray such\nthat if you only sort this subarray in non-decreasing order, then the whole\narray will be sorted in non-decreasing order.\n\nReturn the shortest such subarray and output its length.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 21, 27, 29, 33, 37], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      log_function('LOOP #1: Entered for loop at line 17-22\\n')\n      if nums[i] < nums[i - 1]:\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        flag = True\n      if flag:\n        log_function('BRANCH #2: Covered if branch at line 20-21\\n')\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      log_function('LOOP #2: Entered for loop at line 25-30\\n')\n      if nums[i] > nums[i + 1]:\n        log_function('BRANCH #3: Covered if branch at line 26-27\\n')\n        flag = True\n      if flag:\n        log_function('BRANCH #4: Covered if branch at line 28-29\\n')\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      log_function('LOOP #3: Entered for loop at line 31-34\\n')\n      if nums[l] > mini:\n        log_function('BRANCH #5: Covered if branch at line 32-33\\n')\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      log_function('LOOP #4: Entered for loop at line 35-38\\n')\n      if num < maxi:\n        log_function('BRANCH #6: Covered if branch at line 36-37\\n')\n        break\n\n    return 0 if l >= r else r - l + 1\n\ndef log_function(info_str):\n    with open(\"test_logs/Shortest Unsorted Continuous Subarray.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 20-21\n", "LOOP #1: Entered for loop at line 17-22\n", "BRANCH #2: Covered if branch at line 20-21\n", "LOOP #1: Entered for loop at line 17-22\n", "BRANCH #1: Covered if branch at line 18-19\n"], ["LOOP #3: Entered for loop at line 31-34\n", "LOOP #4: Entered for loop at line 35-38\n"], ["LOOP #2: Entered for loop at line 25-30\n", "LOOP #2: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 31-34\n", "LOOP #3: Entered for loop at line 31-34\n", "LOOP #3: Entered for loop at line 31-34\n"], ["LOOP #3: Entered for loop at line 31-34\n", "LOOP #4: Entered for loop at line 35-38\n", "LOOP #4: Entered for loop at line 35-38\n", "LOOP #4: Entered for loop at line 35-38\n", "LOOP #4: Entered for loop at line 35-38\n"], ["BRANCH #1: Covered if branch at line 18-19\n", "BRANCH #2: Covered if branch at line 20-21\n", "LOOP #1: Entered for loop at line 17-22\n", "BRANCH #2: Covered if branch at line 20-21\n", "LOOP #2: Entered for loop at line 25-30\n"]], "sampled_condition_paths": [["Line 20: (flag)", "Line 17: (i in range(1, len(nums)))", "Line 20: (flag)", "Line 17: (i in range(1, len(nums)))", "Line 18: (nums[i] < nums[i - 1])"], ["Line 31: (l in range(len(nums)))", "Line 35: (r, num in reversed(list(enumerate(nums))))"], ["Line 25: (i in reversed(range(len(nums) - 1)))", "Line 25: (i in reversed(range(len(nums) - 1)))", "Line 31: (l in range(len(nums)))", "Line 31: (l in range(len(nums)))", "Line 31: (l in range(len(nums)))"], ["Line 31: (l in range(len(nums)))", "Line 35: (r, num in reversed(list(enumerate(nums))))", "Line 35: (r, num in reversed(list(enumerate(nums))))", "Line 35: (r, num in reversed(list(enumerate(nums))))", "Line 35: (r, num in reversed(list(enumerate(nums))))"], ["Line 18: (nums[i] < nums[i - 1])", "Line 20: (flag)", "Line 17: (i in range(1, len(nums)))", "Line 20: (flag)", "Line 25: (i in reversed(range(len(nums) - 1)))"]]}
{"task_num": 591, "task_title": "Tag Validator", "difficulty": 3, "func_name": "isValid", "description": "Given a string representing a code snippet, implement a tag validator to parse\nthe code and return whether it is valid.\n\nA code snippet is valid if all the following rules hold:\n\n1. The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\n2. A closed tag (not necessarily valid) has exactly the following format : `<TAG_NAME>TAG_CONTENT</TAG_NAME>`. Among them, `<TAG_NAME>` is the start tag, and `</TAG_NAME>` is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\n3. A valid `TAG_NAME` only contain upper-case letters, and has length in range [1,9]. Otherwise, the `TAG_NAME` is invalid.\n4. A valid `TAG_CONTENT` may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the `TAG_CONTENT` is invalid.\n5. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n6. A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or `</`, all the subsequent characters until the next `>` should be parsed as TAG_NAME (not necessarily valid).\n7. The cdata has the following format : `<![CDATA[CDATA_CONTENT]]>`. The range of `CDATA_CONTENT` is defined as the characters between `<![CDATA[` and the first subsequent `]]>`.\n8. `CDATA_CONTENT` may contain any characters. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 40, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 44, "difficulty": 2, "eg_cov_prob": 0.34}, {"type": "if", "start": 43, "end": 44, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 49, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 2, "eg_cov_prob": 0.18}, {"type": "if", "start": 51, "end": 52, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 25, 27, 30, 39, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        log_function('BRANCH #2: Covered if branch at line 24-25\\n')\n        return False\n      if any(not c.isupper() for c in tagName):\n        log_function('BRANCH #3: Covered if branch at line 26-27\\n')\n        return False\n\n      if isEndTag:\n        log_function('BRANCH #4: Covered if branch at line 29-30\\n')\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      log_function('LOOP #1: Entered while loop at line 37-55\\n')\n      if not stack and containsTag:\n        log_function('BRANCH #5: Covered if branch at line 38-39\\n')\n        return False\n      if code[i] == '<':\n        log_function('BRANCH #6: Covered if branch at line 40-53\\n')\n        if stack and code[i + 1] == '!':\n          log_function('BRANCH #7: Covered if branch at line 41-44\\n')\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            log_function('BRANCH #8: Covered if branch at line 43-44\\n')\n            return False\n        elif code[i + 1] == '/':\n          log_function('BRANCH #9: Covered elif branch at line 45-48\\n')\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            log_function('BRANCH #10: Covered if branch at line 47-48\\n')\n            return False\n        else:\n          log_function('BRANCH #11: Covered else branch at line 49-52\\n')\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            log_function('BRANCH #12: Covered if branch at line 51-52\\n')\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n\ndef log_function(info_str):\n    with open(\"test_logs/Tag Validator.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered while loop at line 37-55\n", "LOOP #1: Entered while loop at line 37-55\n", "LOOP #1: Entered while loop at line 37-55\n", "LOOP #1: Entered while loop at line 37-55\n", "LOOP #1: Entered while loop at line 37-55\n"], ["BRANCH #11: Covered else branch at line 49-52\n", "LOOP #1: Entered while loop at line 37-55\n", "LOOP #1: Entered while loop at line 37-55\n", "BRANCH #6: Covered if branch at line 40-53\n", "BRANCH #9: Covered elif branch at line 45-48\n"], ["LOOP #1: Entered while loop at line 37-55\n", "BRANCH #6: Covered if branch at line 40-53\n", "BRANCH #7: Covered if branch at line 41-44\n", "LOOP #1: Entered while loop at line 37-55\n", "LOOP #1: Entered while loop at line 37-55\n"]], "sampled_condition_paths": [["Line 37: (i < len(code))", "Line 37: (i < len(code))", "Line 37: (i < len(code))", "Line 37: (i < len(code))", "Line 37: (i < len(code))"], ["Line 41: NOT (stack and code[i + 1] == '!')", "Line 45: NOT (code[i + 1] == '/')", "Line 49: ", "Line 37: (i < len(code))", "Line 37: (i < len(code))", "Line 40: (code[i] == '<')", "Line 41: NOT (stack and code[i + 1] == '!')", "Line 45: (code[i + 1] == '/')"], ["Line 37: (i < len(code))", "Line 40: (code[i] == '<')", "Line 41: (stack and code[i + 1] == '!')", "Line 37: (i < len(code))", "Line 37: (i < len(code))"]]}
{"task_num": 648, "task_title": "Replace Words", "difficulty": 2, "func_name": "replaceWords", "description": "In English, we have a concept called root, which can be followed by some other\nword to form another longer word - let's call this word successor. For\nexample, when the root `\"help\"` is followed by the successor word `\"ful\"`, we\ncan form a new word `\"helpful\"`.\n\nGiven a `dictionary` consisting of many roots and a `sentence` consisting of\nwords separated by spaces, replace all the successors in the sentence with the\nroot forming it. If a successor can be replaced by more than one root, replace\nit with the root that has the shortest length.\n\nReturn the `sentence` after the replacement.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.92}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 27, 29], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      log_function('LOOP #1: Entered for loop at line 17-20\\n')\n      if c not in node:\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      log_function('LOOP #2: Entered for loop at line 25-30\\n')\n      if 'word' in node:\n        log_function('BRANCH #2: Covered if branch at line 26-27\\n')\n        return node['word']\n      if c not in node:\n        log_function('BRANCH #3: Covered if branch at line 28-29\\n')\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      log_function('LOOP #3: Entered for loop at line 34-36\\n')\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n\ndef log_function(info_str):\n    with open(\"test_logs/Replace Words.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 25-30\n", "BRANCH #2: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 25-30\n", "LOOP #2: Entered for loop at line 25-30\n", "BRANCH #3: Covered if branch at line 28-29\n"], ["BRANCH #1: Covered if branch at line 18-19\n", "LOOP #1: Entered for loop at line 17-20\n", "BRANCH #1: Covered if branch at line 18-19\n", "LOOP #1: Entered for loop at line 17-20\n", "BRANCH #1: Covered if branch at line 18-19\n"], ["LOOP #3: Entered for loop at line 34-36\n", "LOOP #1: Entered for loop at line 17-20\n", "BRANCH #1: Covered if branch at line 18-19\n", "LOOP #3: Entered for loop at line 34-36\n", "LOOP #1: Entered for loop at line 17-20\n"], ["LOOP #2: Entered for loop at line 25-30\n", "BRANCH #2: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 25-30\n", "LOOP #2: Entered for loop at line 25-30\n", "BRANCH #2: Covered if branch at line 26-27\n"]], "sampled_condition_paths": [["Line 25: (c in word)", "Line 26: ('word' in node)", "Line 25: (c in word)", "Line 25: (c in word)", "Line 28: (c not in node)"], ["Line 18: (c not in node)", "Line 17: (c in word)", "Line 18: (c not in node)", "Line 17: (c in word)", "Line 18: (c not in node)"], ["Line 34: (word in dictionary)", "Line 17: (c in word)", "Line 18: (c not in node)", "Line 34: (word in dictionary)", "Line 17: (c in word)"], ["Line 25: (c in word)", "Line 26: ('word' in node)", "Line 25: (c in word)", "Line 25: (c in word)", "Line 26: ('word' in node)"]]}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "difficulty": 2, "func_name": "findNumberOfLIS", "description": "Given an integer array `nums`, return the number of longest increasing\nsubsequences.\n\nNotice that the sequence has to be strictly increasing.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "blocks": [{"type": "if", "start": 28, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 22, 23, 24, 25, 29, 30, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      log_function('LOOP #1: Entered for loop at line 18-26\\n')\n      for j in range(i):\n        log_function('LOOP #2: Entered for loop at line 19-26\\n')\n        if nums[j] < num:\n          log_function('BRANCH #1: Covered if branch at line 20-25\\n')\n          if length[i] < length[j] + 1:\n            log_function('BRANCH #2: Covered if branch at line 21-23\\n')\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            log_function('BRANCH #3: Covered elif branch at line 24-25\\n')\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      log_function('LOOP #3: Entered for loop at line 27-33\\n')\n      if l > maxLength:\n        log_function('BRANCH #4: Covered if branch at line 28-30\\n')\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        log_function('BRANCH #5: Covered elif branch at line 31-32\\n')\n        ans += count[i]\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Longest Increasing Subsequence.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 21-23\n", "LOOP #2: Entered for loop at line 19-26\n", "BRANCH #1: Covered if branch at line 20-25\n", "BRANCH #2: Covered if branch at line 21-23\n", "LOOP #1: Entered for loop at line 18-26\n"], ["LOOP #2: Entered for loop at line 19-26\n", "LOOP #1: Entered for loop at line 18-26\n", "LOOP #2: Entered for loop at line 19-26\n", "LOOP #2: Entered for loop at line 19-26\n", "LOOP #2: Entered for loop at line 19-26\n"], ["LOOP #1: Entered for loop at line 18-26\n", "LOOP #2: Entered for loop at line 19-26\n", "LOOP #2: Entered for loop at line 19-26\n", "LOOP #2: Entered for loop at line 19-26\n", "LOOP #1: Entered for loop at line 18-26\n"], ["BRANCH #2: Covered if branch at line 21-23\n", "LOOP #1: Entered for loop at line 18-26\n", "LOOP #2: Entered for loop at line 19-26\n", "BRANCH #1: Covered if branch at line 20-25\n", "BRANCH #2: Covered if branch at line 21-23\n"]], "sampled_condition_paths": [["Line 21: (length[i] < length[j] + 1)", "Line 19: (j in range(i))", "Line 20: (nums[j] < num)", "Line 21: (length[i] < length[j] + 1)", "Line 18: (i, num in enumerate(nums))"], ["Line 19: (j in range(i))", "Line 18: (i, num in enumerate(nums))", "Line 19: (j in range(i))", "Line 19: (j in range(i))", "Line 19: (j in range(i))"], ["Line 18: (i, num in enumerate(nums))", "Line 19: (j in range(i))", "Line 19: (j in range(i))", "Line 19: (j in range(i))", "Line 18: (i, num in enumerate(nums))"], ["Line 21: (length[i] < length[j] + 1)", "Line 18: (i, num in enumerate(nums))", "Line 19: (j in range(i))", "Line 20: (nums[j] < num)", "Line 21: (length[i] < length[j] + 1)"]]}
{"task_num": 684, "task_title": "Redundant Connection", "difficulty": 2, "func_name": "findRedundantConnection", "description": "In this problem, a tree is an undirected graph that is connected and has no\ncycles.\n\nYou are given a graph that started as a tree with `n` nodes labeled from `1`\nto `n`, with one additional edge added. The added edge has two different\nvertices chosen from `1` to `n`, and was not an edge that already existed. The\ngraph is represented as an array `edges` of length `n` where `edges[i] = [ai,\nbi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.\n\nReturn an edge that can be removed so that the resulting graph is a tree of\n`n` nodes. If there are multiple answers, return the answer that occurs last\nin the input.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 32, 43], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return False\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 31-32\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      log_function('LOOP #1: Entered for loop at line 40-44\\n')\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        log_function('BRANCH #6: Covered if branch at line 42-43\\n')\n        return edge\n\ndef log_function(info_str):\n    with open(\"test_logs/Redundant Connection.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #4: Covered else branch at line 25-27\n", "LOOP #1: Entered for loop at line 40-44\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #1: Entered for loop at line 40-44\n"], ["BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #1: Entered for loop at line 40-44\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #1: Covered if branch at line 19-20\n", "BRANCH #6: Covered if branch at line 42-43\n"], ["LOOP #1: Entered for loop at line 40-44\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #1: Entered for loop at line 40-44\n", "BRANCH #5: Covered if branch at line 31-32\n"]], "sampled_condition_paths": [["Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 40: (edge in edges)", "Line 31: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 40: (edge in edges)"], ["Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 40: (edge in edges)", "Line 31: (self.id[u] != u)", "Line 19: (i == j)", "Line 42: (not uf.unionByRank(u, v))"], ["Line 40: (edge in edges)", "Line 31: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 40: (edge in edges)", "Line 31: (self.id[u] != u)"]]}
{"task_num": 685, "task_title": "Redundant Connection II", "difficulty": 3, "func_name": "findRedundantDirectedConnection", "description": "In this problem, a rooted tree is a directed graph such that, there is exactly\none node (the root) for which all other nodes are descendants of this node,\nplus every node has exactly one parent, except for the root node which has no\nparents.\n\nThe given input is a directed graph that started as a rooted tree with `n`\nnodes (with distinct values from `1` to `n`), with one additional directed\nedge added. The added edge has two different vertices chosen from `1` to `n`,\nand was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of `edges`. Each element of `edges`\nis a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and\n`vi`, where `ui` is a parent of child `vi`.\n\nReturn an edge that can be removed so that the resulting graph is a rooted\ntree of `n` nodes. If there are multiple answers, return the answer that\noccurs last in the given 2D-array.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.25}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 57, "end": 58, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 64, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 2, "eg_cov_prob": 0.25}, {"type": "if", "start": 63, "end": 64, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 32, 44, 51, 53, 58, 63, 64], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return False\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 31-32\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      log_function('LOOP #1: Entered for loop at line 41-45\\n')\n      ids[v] += 1\n      if ids[v] == 2:\n        log_function('BRANCH #6: Covered if branch at line 43-44\\n')\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        log_function('LOOP #2: Entered for loop at line 49-54\\n')\n        if i == skippedEdgeIndex:\n          log_function('BRANCH #7: Covered if branch at line 50-51\\n')\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          log_function('BRANCH #8: Covered if branch at line 52-53\\n')\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      log_function('BRANCH #9: Covered if branch at line 57-58\\n')\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      log_function('LOOP #3: Entered for loop at line 60-65\\n')\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        log_function('BRANCH #10: Covered if branch at line 62-64\\n')\n        if not findRedundantDirectedConnection(i):\n          log_function('BRANCH #11: Covered if branch at line 63-64\\n')\n          return edges[i]\n\ndef log_function(info_str):\n    with open(\"test_logs/Redundant Connection II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #9: Covered if branch at line 57-58\n", "LOOP #2: Entered for loop at line 49-54\n", "BRANCH #4: Covered else branch at line 25-27\n", "LOOP #2: Entered for loop at line 49-54\n", "BRANCH #3: Covered elif branch at line 23-24\n"], ["BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #2: Entered for loop at line 49-54\n", "BRANCH #7: Covered if branch at line 50-51\n", "BRANCH #11: Covered if branch at line 63-64\n"], ["BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #2: Entered for loop at line 49-54\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #2: Entered for loop at line 49-54\n"], ["LOOP #2: Entered for loop at line 49-54\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #2: Entered for loop at line 49-54\n", "BRANCH #7: Covered if branch at line 50-51\n"]], "sampled_condition_paths": [["Line 57: (nodeWithTwoParents == 0)", "Line 49: (i, edge in enumerate(edges))", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 49: (i, edge in enumerate(edges))", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])"], ["Line 31: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 49: (i, edge in enumerate(edges))", "Line 50: (i == skippedEdgeIndex)", "Line 63: (not findRedundantDirectedConnection(i))"], ["Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 49: (i, edge in enumerate(edges))", "Line 31: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 49: (i, edge in enumerate(edges))"], ["Line 49: (i, edge in enumerate(edges))", "Line 31: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 49: (i, edge in enumerate(edges))", "Line 50: (i == skippedEdgeIndex)"]]}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "difficulty": 2, "func_name": "knightProbability", "description": "On an `n x n` chessboard, a knight starts at the cell `(row, column)` and\nattempts to make exactly `k` moves. The rows and columns are 0-indexed, so the\ntop-left cell is `(0, 0)`, and the bottom-right cell is `(n - 1, n - 1)`.\n\nA chess knight has eight possible moves it can make, as illustrated below.\nEach move is two cells in a cardinal direction, then one cell in an orthogonal\ndirection.\n\nEach time the knight is to move, it chooses one of eight possible moves\nuniformly at random (even if the piece would go off the chessboard) and moves\nthere.\n\nThe knight continues moving until it has made exactly `k` moves or has moved\noff the chessboard.\n\nReturn the probability that the knight remains on the board after it has\nstopped moving.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.9}], "target_lines": [25], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      log_function('LOOP #1: Entered for loop at line 17-27\\n')\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        log_function('LOOP #2: Entered for loop at line 19-25\\n')\n        for j in range(n):\n          log_function('LOOP #3: Entered for loop at line 20-25\\n')\n          for dx, dy in dirs:\n            log_function('LOOP #4: Entered for loop at line 21-25\\n')\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              log_function('BRANCH #1: Covered if branch at line 24-25\\n')\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n\ndef log_function(info_str):\n    with open(\"test_logs/Knight Probability in Chessboard.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 21-25\n", "BRANCH #1: Covered if branch at line 24-25\n", "LOOP #4: Entered for loop at line 21-25\n", "BRANCH #1: Covered if branch at line 24-25\n", "LOOP #4: Entered for loop at line 21-25\n"], [], ["LOOP #4: Entered for loop at line 21-25\n", "LOOP #4: Entered for loop at line 21-25\n", "BRANCH #1: Covered if branch at line 24-25\n", "LOOP #4: Entered for loop at line 21-25\n", "BRANCH #1: Covered if branch at line 24-25\n"]], "sampled_condition_paths": [["Line 21: (dx, dy in dirs)", "Line 24: (0 <= x < n and 0 <= y < n)", "Line 21: (dx, dy in dirs)", "Line 24: (0 <= x < n and 0 <= y < n)", "Line 21: (dx, dy in dirs)"], [], ["Line 21: (dx, dy in dirs)", "Line 21: (dx, dy in dirs)", "Line 24: (0 <= x < n and 0 <= y < n)", "Line 21: (dx, dy in dirs)", "Line 24: (0 <= x < n and 0 <= y < n)"]]}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "difficulty": 3, "func_name": "maxSumOfThreeSubarrays", "description": "Given an integer array `nums` and an integer `k`, find three non-overlapping\nsubarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of\neach interval (0-indexed). If there are multiple answers, return the\nlexicographically smallest one.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 24, 29, 35, 42, 43, 44], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      log_function('LOOP #1: Entered for loop at line 19-25\\n')\n      summ += num\n      if i >= k:\n        log_function('BRANCH #1: Covered if branch at line 21-22\\n')\n        summ -= nums[i - k]\n      if i >= k - 1:\n        log_function('BRANCH #2: Covered if branch at line 23-24\\n')\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      log_function('LOOP #2: Entered for loop at line 27-31\\n')\n      if sums[i] > sums[maxIndex]:\n        log_function('BRANCH #3: Covered if branch at line 28-29\\n')\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      log_function('LOOP #3: Entered for loop at line 33-37\\n')\n      if sums[i] >= sums[maxIndex]:\n        log_function('BRANCH #4: Covered if branch at line 34-35\\n')\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      log_function('LOOP #4: Entered for loop at line 40-45\\n')\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        log_function('BRANCH #5: Covered if branch at line 41-44\\n')\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Sum of 3 Non-Overlapping Subarrays.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #4: Covered if branch at line 34-35\n", "LOOP #3: Entered for loop at line 33-37\n", "LOOP #3: Entered for loop at line 33-37\n", "LOOP #3: Entered for loop at line 33-37\n", "LOOP #3: Entered for loop at line 33-37\n"], ["BRANCH #4: Covered if branch at line 34-35\n", "LOOP #4: Entered for loop at line 40-45\n", "BRANCH #5: Covered if branch at line 41-44\n", "LOOP #4: Entered for loop at line 40-45\n", "LOOP #4: Entered for loop at line 40-45\n"], ["LOOP #1: Entered for loop at line 19-25\n", "BRANCH #1: Covered if branch at line 21-22\n", "BRANCH #2: Covered if branch at line 23-24\n", "LOOP #2: Entered for loop at line 27-31\n", "LOOP #2: Entered for loop at line 27-31\n"], ["BRANCH #2: Covered if branch at line 23-24\n", "LOOP #1: Entered for loop at line 19-25\n", "BRANCH #1: Covered if branch at line 21-22\n", "BRANCH #2: Covered if branch at line 23-24\n", "LOOP #1: Entered for loop at line 19-25\n"]], "sampled_condition_paths": [["Line 34: (sums[i] >= sums[maxIndex])", "Line 33: (i in range(n - 1, -1, -1))", "Line 33: (i in range(n - 1, -1, -1))", "Line 33: (i in range(n - 1, -1, -1))", "Line 33: (i in range(n - 1, -1, -1))"], ["Line 34: (sums[i] >= sums[maxIndex])", "Line 40: (i in range(k, n - k))", "Line 41: (ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]])", "Line 40: (i in range(k, n - k))", "Line 40: (i in range(k, n - k))"], ["Line 19: (i, num in enumerate(nums))", "Line 21: (i >= k)", "Line 23: (i >= k - 1)", "Line 27: (i in range(n))", "Line 27: (i in range(n))"], ["Line 23: (i >= k - 1)", "Line 19: (i, num in enumerate(nums))", "Line 21: (i >= k)", "Line 23: (i >= k - 1)", "Line 19: (i, num in enumerate(nums))"]]}
{"task_num": 691, "task_title": "Stickers to Spell Word", "difficulty": 3, "func_name": "minStickers", "description": "We are given `n` different types of `stickers`. Each sticker has a lowercase\nEnglish word on it.\n\nYou would like to spell out the given string `target` by cutting individual\nletters from your collection of stickers and rearranging them. You can use\neach sticker more than once if you want, and you have infinite quantities of\neach sticker.\n\nReturn the minimum number of stickers that you need to spell out `target`. If\nthe task is impossible, return `-1`.\n\nNote: In all test cases, all words were chosen randomly from the `1000` most\ncommon US English words, and `target` was chosen as a concatenation of two\nrandom words.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 1, "eg_cov_prob": 0.76}, {"type": "if", "start": 24, "end": 26, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [19, 25, 26], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      log_function('LOOP #1: Entered for loop at line 17-28\\n')\n      if dp[mask] == math.inf:\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        continue\n      for sticker in stickers:\n        log_function('LOOP #2: Entered for loop at line 20-28\\n')\n        superMask = mask\n        for c in sticker:\n          log_function('LOOP #3: Entered for loop at line 22-26\\n')\n          for i, t in enumerate(target):\n            log_function('LOOP #4: Entered for loop at line 23-26\\n')\n            if c == t and not (superMask >> i & 1):\n              log_function('BRANCH #2: Covered if branch at line 24-26\\n')\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n\ndef log_function(info_str):\n    with open(\"test_logs/Stickers to Spell Word.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 20-28\n", "LOOP #3: Entered for loop at line 22-26\n", "LOOP #4: Entered for loop at line 23-26\n", "LOOP #4: Entered for loop at line 23-26\n", "LOOP #4: Entered for loop at line 23-26\n"], ["LOOP #4: Entered for loop at line 23-26\n", "LOOP #4: Entered for loop at line 23-26\n", "LOOP #4: Entered for loop at line 23-26\n", "LOOP #4: Entered for loop at line 23-26\n", "LOOP #4: Entered for loop at line 23-26\n"], ["BRANCH #1: Covered if branch at line 18-19\n", "LOOP #1: Entered for loop at line 17-28\n", "BRANCH #1: Covered if branch at line 18-19\n", "LOOP #1: Entered for loop at line 17-28\n", "BRANCH #1: Covered if branch at line 18-19\n"]], "sampled_condition_paths": [["Line 20: (sticker in stickers)", "Line 22: (c in sticker)", "Line 23: (i, t in enumerate(target))", "Line 23: (i, t in enumerate(target))", "Line 23: (i, t in enumerate(target))"], ["Line 23: (i, t in enumerate(target))", "Line 23: (i, t in enumerate(target))", "Line 23: (i, t in enumerate(target))", "Line 23: (i, t in enumerate(target))", "Line 23: (i, t in enumerate(target))"], ["Line 18: (dp[mask] == math.inf)", "Line 17: (mask in range(maxMask))", "Line 18: (dp[mask] == math.inf)", "Line 17: (mask in range(maxMask))", "Line 18: (dp[mask] == math.inf)"]]}
{"task_num": 722, "task_title": "Remove Comments", "difficulty": 2, "func_name": "removeComments", "description": "Given a C++ program, remove comments from it. The program source is an array\nof strings `source` where `source[i]` is the `ith` line of the source code.\nThis represents the result of splitting the original source code string by the\nnewline character `'\\n'`.\n\nIn C++, there are two types of comments, line comments, and block comments.\n\n* The string `\"//\"` denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.\n* The string `\"/*\"` denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of `\"*/\"` should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string `\"/*/\"` does not yet end the block comment, as the ending would be overlapping the beginning.\n\nThe first effective comment takes precedence over others.\n\n* For example, if the string `\"//\"` occurs in a block comment, it is ignored.\n* Similarly, if the string `\"/*\"` occurs in a line or block comment, it is also ignored.\n\nIf a certain line of code is empty after removing comments, you must not\noutput that line: each string in the answer list will be non-empty.\n\nThere will be no control characters, single quote, or double quote characters.\n\n* For example, `source = \"string s = \"/* Not a comment. */\";\"` will not be a test case.\n\nAlso, nothing else such as defines or macros will interfere with the comments.\n\nIt is guaranteed that every open block comment will eventually be closed, so\n`\"/*\"` outside of a line or block comment always starts a new comment.\n\nFinally, implicit newline characters can be deleted by block comments. Please\nsee the examples below for details.\n\nAfter removing the comments from the source code, return the source code in\nthe same format.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "blocks": [{"type": "if", "start": 41, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 28, "difficulty": 1, "eg_cov_prob": 0.87}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 31, "difficulty": 1, "eg_cov_prob": 0.87}, {"type": "if", "start": 32, "end": 36, "difficulty": 1, "eg_cov_prob": 0.89}, {"type": "else", "start": 37, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.89}, {"type": "else", "start": 35, "end": 36, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 22, 23, 24, 27, 28, 30, 31, 33, 34, 36, 38, 39, 40, 42, 43], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      log_function('LOOP #1: Entered for loop at line 17-44\\n')\n      i = 0\n      while i < len(line):\n        log_function('LOOP #2: Entered while loop at line 19-40\\n')\n        if i + 1 == len(line):\n          log_function('BRANCH #1: Covered if branch at line 20-24\\n')\n          if not commenting:\n            log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          log_function('BRANCH #3: Covered if branch at line 26-28\\n')\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          log_function('BRANCH #4: Covered elif branch at line 29-31\\n')\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          log_function('BRANCH #5: Covered elif branch at line 32-36\\n')\n          if not commenting:\n            log_function('BRANCH #6: Covered if branch at line 33-34\\n')\n            break\n          else:\n            log_function('BRANCH #7: Covered else branch at line 35-36\\n')\n            i += 2\n        else:\n          log_function('BRANCH #8: Covered else branch at line 37-40\\n')\n          if not commenting:\n            log_function('BRANCH #9: Covered if branch at line 38-39\\n')\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        log_function('BRANCH #10: Covered if branch at line 41-43\\n')\n        ans.append(modified)\n        modified = ''\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Remove Comments.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #8: Covered else branch at line 37-40\n", "LOOP #2: Entered while loop at line 19-40\n", "BRANCH #8: Covered else branch at line 37-40\n", "LOOP #2: Entered while loop at line 19-40\n", "BRANCH #4: Covered elif branch at line 29-31\n"], ["BRANCH #10: Covered if branch at line 41-43\n", "LOOP #1: Entered for loop at line 17-44\n", "LOOP #2: Entered while loop at line 19-40\n", "BRANCH #8: Covered else branch at line 37-40\n", "BRANCH #9: Covered if branch at line 38-39\n"], ["BRANCH #1: Covered if branch at line 20-24\n", "LOOP #1: Entered for loop at line 17-44\n", "LOOP #2: Entered while loop at line 19-40\n", "BRANCH #8: Covered else branch at line 37-40\n", "LOOP #2: Entered while loop at line 19-40\n"]], "sampled_condition_paths": [["Line 26: NOT (twoChars == '/*' and not commenting)", "Line 29: NOT (twoChars == '*/' and commenting)", "Line 32: NOT (twoChars == '//')", "Line 37: ", "Line 19: (i < len(line))", "Line 26: NOT (twoChars == '/*' and not commenting)", "Line 29: NOT (twoChars == '*/' and commenting)", "Line 32: NOT (twoChars == '//')", "Line 37: ", "Line 19: (i < len(line))", "Line 26: NOT (twoChars == '/*' and not commenting)", "Line 29: (twoChars == '*/' and commenting)"], ["Line 41: (modified and not commenting)", "Line 17: (line in source)", "Line 19: (i < len(line))", "Line 26: NOT (twoChars == '/*' and not commenting)", "Line 29: NOT (twoChars == '*/' and commenting)", "Line 32: NOT (twoChars == '//')", "Line 37: ", "Line 38: (not commenting)"], ["Line 20: (i + 1 == len(line))", "Line 17: (line in source)", "Line 19: (i < len(line))", "Line 26: NOT (twoChars == '/*' and not commenting)", "Line 29: NOT (twoChars == '*/' and commenting)", "Line 32: NOT (twoChars == '//')", "Line 37: ", "Line 19: (i < len(line))"]]}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "difficulty": 3, "func_name": "countPalindromicSubsequences", "description": "Given a string s, return the number of different non-empty palindromic\nsubsequences in `s`. Since the answer may be very large, return it modulo `109\n+ 7`.\n\nA subsequence of a string is obtained by deleting zero or more characters from\nthe string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences `a1, a2, ...` and `b1, b2, ...` are different if there is some\n`i` for which `ai != bi`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "blocks": [{"type": "if", "start": 23, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      log_function('LOOP #1: Entered for loop at line 17-19\\n')\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      log_function('LOOP #2: Entered for loop at line 20-39\\n')\n      for i in range(n - d):\n        log_function('LOOP #3: Entered for loop at line 21-39\\n')\n        j = i + d\n        if s[i] == s[j]:\n          log_function('BRANCH #1: Covered if branch at line 23-35\\n')\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            log_function('LOOP #4: Entered while loop at line 26-27\\n')\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            log_function('LOOP #5: Entered while loop at line 28-29\\n')\n            hi -= 1\n          if lo > hi:\n            log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            log_function('BRANCH #3: Covered elif branch at line 32-33\\n')\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            log_function('BRANCH #4: Covered else branch at line 34-35\\n')\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          log_function('BRANCH #5: Covered else branch at line 36-37\\n')\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Different Palindromic Subsequences.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 17-19\n", "LOOP #1: Entered for loop at line 17-19\n", "LOOP #1: Entered for loop at line 17-19\n", "LOOP #2: Entered for loop at line 20-39\n", "LOOP #3: Entered for loop at line 21-39\n"], ["BRANCH #2: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 21-39\n", "BRANCH #5: Covered else branch at line 36-37\n", "LOOP #2: Entered for loop at line 20-39\n", "LOOP #3: Entered for loop at line 21-39\n"], ["LOOP #3: Entered for loop at line 21-39\n", "BRANCH #5: Covered else branch at line 36-37\n", "LOOP #3: Entered for loop at line 21-39\n", "BRANCH #5: Covered else branch at line 36-37\n", "LOOP #3: Entered for loop at line 21-39\n"], ["LOOP #4: Entered while loop at line 26-27\n", "LOOP #4: Entered while loop at line 26-27\n", "LOOP #5: Entered while loop at line 28-29\n", "LOOP #5: Entered while loop at line 28-29\n", "LOOP #5: Entered while loop at line 28-29\n"]], "sampled_condition_paths": [["Line 17: (i in range(n))", "Line 17: (i in range(n))", "Line 17: (i in range(n))", "Line 20: (d in range(1, n))", "Line 21: (i in range(n - d))"], ["Line 30: (lo > hi)", "Line 21: (i in range(n - d))", "Line 23: NOT (s[i] == s[j])", "Line 36: ", "Line 20: (d in range(1, n))", "Line 21: (i in range(n - d))"], ["Line 21: (i in range(n - d))", "Line 23: NOT (s[i] == s[j])", "Line 36: ", "Line 21: (i in range(n - d))", "Line 23: NOT (s[i] == s[j])", "Line 36: ", "Line 21: (i in range(n - d))"], ["Line 26: (lo <= hi and s[lo] != s[i])", "Line 26: (lo <= hi and s[lo] != s[i])", "Line 28: (lo <= hi and s[hi] != s[i])", "Line 28: (lo <= hi and s[hi] != s[i])", "Line 28: (lo <= hi and s[hi] != s[i])"]]}
{"task_num": 735, "task_title": "Asteroid Collision", "difficulty": 2, "func_name": "asteroidCollision", "description": "We are given an array `asteroids` of integers representing asteroids in a row.\n\nFor each asteroid, the absolute value represents its size, and the sign\nrepresents its direction (positive meaning right, negative meaning left). Each\nasteroid moves at the same speed.\n\nFind out the state of the asteroids after all collisions. If two asteroids\nmeet, the smaller one will explode. If both are the same size, both will\nexplode. Two asteroids moving in the same direction will never meet.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 18, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.89}, {"type": "else", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 19, 20, 21, 22, 23, 24, 26], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      log_function('LOOP #1: Entered for loop at line 15-27\\n')\n      if a > 0:\n        log_function('BRANCH #1: Covered if branch at line 16-17\\n')\n        stack.append(a)\n      else:\n        log_function('BRANCH #2: Covered else branch at line 18-26\\n')\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          log_function('LOOP #2: Entered while loop at line 19-20\\n')\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          log_function('BRANCH #3: Covered if branch at line 21-22\\n')\n          stack.append(a)\n        elif stack[-1] == -a:\n          log_function('BRANCH #4: Covered elif branch at line 23-24\\n')\n          stack.pop()\n        else:\n          log_function('BRANCH #5: Covered else branch at line 25-26\\n')\n          pass\n\n    return stack\n\ndef log_function(info_str):\n    with open(\"test_logs/Asteroid Collision.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 16-17\n", "LOOP #1: Entered for loop at line 15-27\n", "BRANCH #2: Covered else branch at line 18-26\n", "LOOP #2: Entered while loop at line 19-20\n", "BRANCH #5: Covered else branch at line 25-26\n"], ["LOOP #1: Entered for loop at line 15-27\n", "BRANCH #1: Covered if branch at line 16-17\n", "LOOP #1: Entered for loop at line 15-27\n", "BRANCH #2: Covered else branch at line 18-26\n", "BRANCH #4: Covered elif branch at line 23-24\n"], ["BRANCH #1: Covered if branch at line 16-17\n", "LOOP #1: Entered for loop at line 15-27\n", "BRANCH #1: Covered if branch at line 16-17\n", "LOOP #1: Entered for loop at line 15-27\n", "BRANCH #2: Covered else branch at line 18-26\n"], ["LOOP #1: Entered for loop at line 15-27\n", "BRANCH #1: Covered if branch at line 16-17\n", "LOOP #1: Entered for loop at line 15-27\n", "BRANCH #2: Covered else branch at line 18-26\n", "LOOP #2: Entered while loop at line 19-20\n"]], "sampled_condition_paths": [["Line 16: (a > 0)", "Line 15: (a in asteroids)", "Line 16: NOT (a > 0)", "Line 18: ", "Line 19: (stack and stack[-1] > 0 and stack[-1] < -a)", "Line 21: NOT (not stack or stack[-1] < 0)", "Line 23: NOT (stack[-1] == -a)", "Line 25: "], ["Line 15: (a in asteroids)", "Line 16: (a > 0)", "Line 15: (a in asteroids)", "Line 16: NOT (a > 0)", "Line 18: ", "Line 21: NOT (not stack or stack[-1] < 0)", "Line 23: (stack[-1] == -a)"], ["Line 16: (a > 0)", "Line 15: (a in asteroids)", "Line 16: (a > 0)", "Line 15: (a in asteroids)", "Line 16: NOT (a > 0)", "Line 18: "], ["Line 15: (a in asteroids)", "Line 16: (a > 0)", "Line 15: (a in asteroids)", "Line 16: NOT (a > 0)", "Line 18: ", "Line 19: (stack and stack[-1] > 0 and stack[-1] < -a)"]]}
{"task_num": 743, "task_title": "Network Delay Time", "difficulty": 2, "func_name": "networkDelayTime", "description": "You are given a network of `n` nodes, labeled from `1` to `n`. You are also\ngiven `times`, a list of travel times as directed edges `times[i] = (ui, vi,\nwi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the\ntime it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return the minimum time it takes\nfor all the `n` nodes to receive the signal. If it is impossible for all the\n`n` nodes to receive the signal, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "blocks": [{"type": "if", "start": 28, "end": 29, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 31, "end": 33, "difficulty": 1, "eg_cov_prob": 0.97}], "target_lines": [29, 32, 33], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      log_function('LOOP #1: Entered for loop at line 15-17\\n')\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      log_function('LOOP #2: Entered while loop at line 26-34\\n')\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        log_function('BRANCH #1: Covered if branch at line 28-29\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #3: Entered for loop at line 30-34\\n')\n        if d + w < dist[v]:\n          log_function('BRANCH #2: Covered if branch at line 31-33\\n')\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Network Delay Time.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 26-34\n", "LOOP #3: Entered for loop at line 30-34\n", "BRANCH #2: Covered if branch at line 31-33\n", "LOOP #3: Entered for loop at line 30-34\n", "BRANCH #2: Covered if branch at line 31-33\n"], ["LOOP #3: Entered for loop at line 30-34\n", "BRANCH #2: Covered if branch at line 31-33\n", "LOOP #3: Entered for loop at line 30-34\n", "BRANCH #2: Covered if branch at line 31-33\n", "LOOP #2: Entered while loop at line 26-34\n"], ["LOOP #1: Entered for loop at line 15-17\n", "LOOP #2: Entered while loop at line 26-34\n", "LOOP #3: Entered for loop at line 30-34\n", "BRANCH #2: Covered if branch at line 31-33\n", "LOOP #2: Entered while loop at line 26-34\n"], ["LOOP #1: Entered for loop at line 15-17\n", "LOOP #2: Entered while loop at line 26-34\n"]], "sampled_condition_paths": [["Line 26: (minHeap)", "Line 30: (v, w in graph[u])", "Line 31: (d + w < dist[v])", "Line 30: (v, w in graph[u])", "Line 31: (d + w < dist[v])"], ["Line 30: (v, w in graph[u])", "Line 31: (d + w < dist[v])", "Line 30: (v, w in graph[u])", "Line 31: (d + w < dist[v])", "Line 26: (minHeap)"], ["Line 15: (u, v, w in times)", "Line 26: (minHeap)", "Line 30: (v, w in graph[u])", "Line 31: (d + w < dist[v])", "Line 26: (minHeap)"], ["Line 15: (u, v, w in times)", "Line 26: (minHeap)"]]}
{"task_num": 770, "task_title": "Basic Calculator IV", "difficulty": 3, "func_name": "basicCalculatorIV", "description": "Given an expression such as `expression = \"e + 8 - a + 5\"` and an evaluation\nmap such as `{\"e\": 1}` (given in terms of `evalvars = [\"e\"]` and `evalints =\n[1]`), return a list of tokens representing the simplified expression, such as\n`[\"-1*a\",\"14\"]`\n\n* An expression alternates chunks and symbols, with a space separating each chunk and symbol.\n* A chunk is either an expression in parentheses, a variable, or a non-negative integer.\n* A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like `\"2x\"` or `\"-x\"`.\n\nExpressions are evaluated in the usual order: brackets first, then\nmultiplication, then addition and subtraction.\n\n* For example, `expression = \"1 + 2 * 3\"` has an answer of `[\"7\"]`.\n\nThe format of the output is as follows:\n\n* For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically. \n* For example, we would never write a term like `\"b*a*c\"`, only `\"a*b*c\"`.\n* Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. \n* For example, `\"a*a*b*c\"` has degree `4`.\n* The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\n* An example of a well-formatted answer is `[\"-2*a*a*a\", \"3*a*a*b\", \"3*b*b\", \"4*a\", \"5*c\", \"-6\"]`.\n* Terms (including constant terms) with coefficient `0` are not included. \n* For example, an expression of `\"0\"` has an output of `[]`.\n\nNote: You may assume that the given expression is always valid. All\nintermediate results will be in the range of `[-231, 231 - 1]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "if", "start": 56, "end": 57, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 58, "end": 59, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 99, "end": 100, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 41, "end": 42, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 47, "end": 48, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 66, "end": 68, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 69, "end": 71, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 81, "end": 82, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 90, "end": 93, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 107, "end": 108, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 112, "end": 113, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 129, "end": 137, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 91, "end": 92, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 94, "end": 98, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 114, "end": 117, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 132, "end": 133, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 138, "end": 139, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 140, "end": 141, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 95, "end": 96, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 118, "end": 121, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "else", "start": 122, "end": 123, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 134, "end": 135, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "else", "start": 136, "end": 137, "difficulty": 1, "eg_cov_prob": 0.96}], "target_lines": [14, 16, 38, 42, 48, 57, 59, 67, 68, 70, 71, 82, 91, 92, 93, 95, 96, 97, 98, 100, 108, 113, 115, 116, 117, 119, 120, 121, 123, 130, 131, 132, 133, 134, 135, 137, 139, 141], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      self.terms = collections.Counter({term: coef})\n    else:\n      log_function('BRANCH #2: Covered else branch at line 15-16\\n')\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      log_function('LOOP #1: Entered for loop at line 19-20\\n')\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      log_function('LOOP #2: Entered for loop at line 24-25\\n')\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      log_function('LOOP #3: Entered for loop at line 30-32\\n')\n      for b, bCoef in other.terms.items():\n        log_function('LOOP #4: Entered for loop at line 31-32\\n')\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      log_function('LOOP #5: Entered for loop at line 36-39\\n')\n      if not self.terms[term]:\n        log_function('BRANCH #3: Covered if branch at line 37-38\\n')\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        log_function('BRANCH #4: Covered if branch at line 41-42\\n')\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        log_function('BRANCH #5: Covered if branch at line 47-48\\n')\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      log_function('BRANCH #6: Covered if branch at line 56-57\\n')\n      return b\n    if b == '1':\n      log_function('BRANCH #7: Covered if branch at line 58-59\\n')\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      log_function('LOOP #6: Entered while loop at line 65-71\\n')\n      if A[i] < B[j]:\n        log_function('BRANCH #8: Covered if branch at line 66-68\\n')\n        res.append(A[i])\n        i += 1\n      else:\n        log_function('BRANCH #9: Covered else branch at line 69-71\\n')\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      log_function('LOOP #7: Entered for loop at line 80-83\\n')\n      if token in evalMap:\n        log_function('BRANCH #10: Covered if branch at line 81-82\\n')\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      log_function('LOOP #8: Entered for loop at line 89-98\\n')\n      if c == ' ':\n        log_function('BRANCH #11: Covered if branch at line 90-93\\n')\n        if i < j:\n          log_function('BRANCH #12: Covered if branch at line 91-92\\n')\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        log_function('BRANCH #13: Covered elif branch at line 94-98\\n')\n        if i < j:\n          log_function('BRANCH #14: Covered if branch at line 95-96\\n')\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      log_function('BRANCH #15: Covered if branch at line 99-100\\n')\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        log_function('BRANCH #16: Covered if branch at line 107-108\\n')\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      log_function('LOOP #9: Entered for loop at line 111-123\\n')\n      if token == '(':\n        log_function('BRANCH #17: Covered if branch at line 112-113\\n')\n        ops.append(token)\n      elif token == ')':\n        log_function('BRANCH #18: Covered elif branch at line 114-117\\n')\n        while ops[-1] != '(':\n          log_function('LOOP #10: Entered while loop at line 115-116\\n')\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        log_function('BRANCH #19: Covered elif branch at line 118-121\\n')\n        while ops and precedes(ops[-1], token):\n          log_function('LOOP #11: Entered while loop at line 119-120\\n')\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        log_function('BRANCH #20: Covered else branch at line 122-123\\n')\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      log_function('LOOP #12: Entered for loop at line 128-141\\n')\n      if token in '+-*':\n        log_function('BRANCH #21: Covered if branch at line 129-137\\n')\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          log_function('BRANCH #22: Covered if branch at line 132-133\\n')\n          polys.append(a + b)\n        elif token == '-':\n          log_function('BRANCH #23: Covered elif branch at line 134-135\\n')\n          polys.append(a - b)\n        else:\n          log_function('BRANCH #24: Covered else branch at line 136-137\\n')\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        log_function('BRANCH #25: Covered elif branch at line 138-139\\n')\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        log_function('BRANCH #26: Covered else branch at line 140-141\\n')\n        polys.append(Poly(token, 1))\n    return polys[0]\n\ndef log_function(info_str):\n    with open(\"test_logs/Basic Calculator IV.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 13-14\n", "LOOP #12: Entered for loop at line 128-141\n", "BRANCH #25: Covered elif branch at line 138-139\n", "BRANCH #1: Covered if branch at line 13-14\n", "LOOP #12: Entered for loop at line 128-141\n"], ["LOOP #12: Entered for loop at line 128-141\n", "BRANCH #25: Covered elif branch at line 138-139\n", "BRANCH #1: Covered if branch at line 13-14\n", "LOOP #12: Entered for loop at line 128-141\n", "BRANCH #25: Covered elif branch at line 138-139\n"], ["BRANCH #13: Covered elif branch at line 94-98\n", "LOOP #8: Entered for loop at line 89-98\n", "LOOP #8: Entered for loop at line 89-98\n", "BRANCH #11: Covered if branch at line 90-93\n", "BRANCH #12: Covered if branch at line 91-92\n"], ["LOOP #9: Entered for loop at line 111-123\n", "BRANCH #20: Covered else branch at line 122-123\n", "LOOP #12: Entered for loop at line 128-141\n", "BRANCH #25: Covered elif branch at line 138-139\n", "BRANCH #1: Covered if branch at line 13-14\n"], ["BRANCH #13: Covered elif branch at line 94-98\n", "LOOP #8: Entered for loop at line 89-98\n", "BRANCH #11: Covered if branch at line 90-93\n", "LOOP #8: Entered for loop at line 89-98\n", "BRANCH #15: Covered if branch at line 99-100\n"], ["LOOP #12: Entered for loop at line 128-141\n", "BRANCH #21: Covered if branch at line 129-137\n", "BRANCH #22: Covered if branch at line 132-133\n", "LOOP #1: Entered for loop at line 19-20\n", "LOOP #12: Entered for loop at line 128-141\n"]], "sampled_condition_paths": [["Line 13: (term and coef)", "Line 128: (token in postfix)", "Line 129: NOT (token in '+-*')", "Line 138: (token.lstrip('-').isnumeric())", "Line 13: (term and coef)", "Line 128: (token in postfix)"], ["Line 128: (token in postfix)", "Line 129: NOT (token in '+-*')", "Line 138: (token.lstrip('-').isnumeric())", "Line 13: (term and coef)", "Line 128: (token in postfix)", "Line 129: NOT (token in '+-*')", "Line 138: (token.lstrip('-').isnumeric())"], ["Line 90: NOT (c == ' ')", "Line 94: (c in '()+-*')", "Line 89: (j, c in enumerate(s))", "Line 89: (j, c in enumerate(s))", "Line 90: (c == ' ')", "Line 91: (i < j)"], ["Line 111: (token in tokens)", "Line 112: NOT (token == '(')", "Line 114: NOT (token == ')')", "Line 118: NOT (token in '+-*')", "Line 122: ", "Line 128: (token in postfix)", "Line 129: NOT (token in '+-*')", "Line 138: (token.lstrip('-').isnumeric())", "Line 13: (term and coef)"], ["Line 90: NOT (c == ' ')", "Line 94: (c in '()+-*')", "Line 89: (j, c in enumerate(s))", "Line 90: (c == ' ')", "Line 89: (j, c in enumerate(s))", "Line 99: (i < len(s))"], ["Line 128: (token in postfix)", "Line 129: (token in '+-*')", "Line 132: (token == '+')", "Line 19: (term, coef in other.terms.items())", "Line 128: (token in postfix)"]]}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "difficulty": 2, "func_name": "canTransform", "description": "In a string composed of `'L'`, `'R'`, and `'X'` characters, like\n`\"RXXLRXRXL\"`, a move consists of either replacing one occurrence of `\"XL\"`\nwith `\"LX\"`, or replacing one occurrence of `\"RX\"` with `\"XR\"`. Given the\nstarting string `start` and the ending string `end`, return `True` if and only\nif there exists a sequence of moves to transform one string to the other.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 25, 27, 29, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      log_function('LOOP #1: Entered while loop at line 19-34\\n')\n      while i < len(start) and start[i] == 'X':\n        log_function('LOOP #2: Entered while loop at line 20-21\\n')\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        log_function('LOOP #3: Entered while loop at line 22-23\\n')\n        j += 1\n      if i == len(start) and j == len(end):\n        log_function('BRANCH #2: Covered if branch at line 24-25\\n')\n        return True\n      if i == len(start) or j == len(end):\n        log_function('BRANCH #3: Covered if branch at line 26-27\\n')\n        return False\n      if start[i] == 'L' and i < j:\n        log_function('BRANCH #4: Covered if branch at line 28-29\\n')\n        return False\n      if start[i] == 'R' and i > j:\n        log_function('BRANCH #5: Covered if branch at line 30-31\\n')\n        return False\n      i += 1\n      j += 1\n\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Swap Adjacent in LR String.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 20-21\n", "LOOP #2: Entered while loop at line 20-21\n", "LOOP #1: Entered while loop at line 19-34\n", "LOOP #3: Entered while loop at line 22-23\n", "LOOP #3: Entered while loop at line 22-23\n"], ["LOOP #2: Entered while loop at line 20-21\n", "LOOP #1: Entered while loop at line 19-34\n", "LOOP #3: Entered while loop at line 22-23\n", "LOOP #3: Entered while loop at line 22-23\n", "LOOP #1: Entered while loop at line 19-34\n"], ["BRANCH #1: Covered if branch at line 13-14\n"]], "sampled_condition_paths": [["Line 20: (i < len(start) and start[i] == 'X')", "Line 20: (i < len(start) and start[i] == 'X')", "Line 19: (i < len(start) and j < len(end))", "Line 22: (j < len(end) and end[j] == 'X')", "Line 22: (j < len(end) and end[j] == 'X')"], ["Line 20: (i < len(start) and start[i] == 'X')", "Line 19: (i < len(start) and j < len(end))", "Line 22: (j < len(end) and end[j] == 'X')", "Line 22: (j < len(end) and end[j] == 'X')", "Line 19: (i < len(start) and j < len(end))"], ["Line 13: (start.replace('X', '') != end.replace('X', ''))"]]}
{"task_num": 782, "task_title": "Transform to Chessboard", "difficulty": 3, "func_name": "movesToChessboard", "description": "You are given an `n x n` binary grid `board`. In each move, you can swap any\ntwo rows with each other, or any two columns with each other.\n\nReturn the minimum number of moves to transform the board into a chessboard\nboard. If the task is impossible, return `-1`.\n\nA chessboard board is a board where no `0`'s and no `1`'s are 4-directionally\nadjacent.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 2, "eg_cov_prob": 0.01}, {"type": "if", "start": 25, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 31, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 36, "end": 38, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [18, 24, 26, 32, 33, 34, 35, 37, 38], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      log_function('LOOP #1: Entered for loop at line 15-19\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 16-19\\n')\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          log_function('BRANCH #1: Covered if branch at line 17-18\\n')\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      log_function('BRANCH #2: Covered if branch at line 23-24\\n')\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      log_function('BRANCH #3: Covered if branch at line 25-26\\n')\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      log_function('BRANCH #4: Covered if branch at line 31-35\\n')\n      if rowSwaps & 1:\n        log_function('BRANCH #5: Covered if branch at line 32-33\\n')\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        log_function('BRANCH #6: Covered if branch at line 34-35\\n')\n        colSwaps = n - colSwaps\n    else:\n      log_function('BRANCH #7: Covered else branch at line 36-38\\n')\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n\ndef log_function(info_str):\n    with open(\"test_logs/Transform to Chessboard.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 16-19\n", "LOOP #2: Entered for loop at line 16-19\n", "LOOP #2: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 15-19\n", "LOOP #2: Entered for loop at line 16-19\n"], ["LOOP #2: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 15-19\n", "LOOP #2: Entered for loop at line 16-19\n", "LOOP #2: Entered for loop at line 16-19\n", "BRANCH #3: Covered if branch at line 25-26\n"], ["LOOP #2: Entered for loop at line 16-19\n", "LOOP #2: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 15-19\n", "LOOP #2: Entered for loop at line 16-19\n", "LOOP #2: Entered for loop at line 16-19\n"]], "sampled_condition_paths": [["Line 16: (j in range(n))", "Line 16: (j in range(n))", "Line 16: (j in range(n))", "Line 15: (i in range(n))", "Line 16: (j in range(n))"], ["Line 16: (j in range(n))", "Line 15: (i in range(n))", "Line 16: (j in range(n))", "Line 16: (j in range(n))", "Line 25: (colSum != n // 2 and colSum != (n + 1) // 2)"], ["Line 16: (j in range(n))", "Line 16: (j in range(n))", "Line 15: (i in range(n))", "Line 16: (j in range(n))", "Line 16: (j in range(n))"]]}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "difficulty": 2, "func_name": "kthSmallestPrimeFraction", "description": "You are given a sorted integer array `arr` containing `1` and prime numbers,\nwhere all the integers of `arr` are unique. You are also given an integer `k`.\n\nFor every `i` and `j` where `0 <= i < j < arr.length`, we consider the\nfraction `arr[i] / arr[j]`.\n\nReturn the `kth` smallest fraction considered. Return your answer as an array\nof integers of size `2`, where `answer[0] == arr[i]` and `answer[1] ==\narr[j]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "blocks": [{"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "else", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [29, 31, 32, 35, 37, 39], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      log_function('LOOP #1: Entered while loop at line 18-40\\n')\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        log_function('LOOP #2: Entered for loop at line 24-33\\n')\n        while j < n and arr[i] > m * arr[j]:\n          log_function('LOOP #3: Entered while loop at line 25-26\\n')\n          j += 1\n        count += n - j\n        if j == n:\n          log_function('BRANCH #1: Covered if branch at line 28-29\\n')\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          log_function('BRANCH #2: Covered if branch at line 30-32\\n')\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        log_function('BRANCH #3: Covered if branch at line 34-35\\n')\n        l = m\n      elif count > k:\n        log_function('BRANCH #4: Covered elif branch at line 36-37\\n')\n        r = m\n      else:\n        log_function('BRANCH #5: Covered else branch at line 38-39\\n')\n        return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/K-th Smallest Prime Fraction.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered while loop at line 25-26\n", "BRANCH #1: Covered if branch at line 28-29\n", "BRANCH #3: Covered if branch at line 34-35\n", "LOOP #1: Entered while loop at line 18-40\n", "LOOP #2: Entered for loop at line 24-33\n"], ["BRANCH #2: Covered if branch at line 30-32\n", "LOOP #2: Entered for loop at line 24-33\n", "LOOP #3: Entered while loop at line 25-26\n", "BRANCH #1: Covered if branch at line 28-29\n", "BRANCH #5: Covered else branch at line 38-39\n"], ["LOOP #2: Entered for loop at line 24-33\n", "BRANCH #2: Covered if branch at line 30-32\n", "LOOP #2: Entered for loop at line 24-33\n", "LOOP #3: Entered while loop at line 25-26\n", "BRANCH #1: Covered if branch at line 28-29\n"], ["LOOP #2: Entered for loop at line 24-33\n", "LOOP #3: Entered while loop at line 25-26\n", "BRANCH #1: Covered if branch at line 28-29\n", "BRANCH #4: Covered elif branch at line 36-37\n", "LOOP #1: Entered while loop at line 18-40\n"]], "sampled_condition_paths": [["Line 25: (j < n and arr[i] > m * arr[j])", "Line 28: (j == n)", "Line 34: (count < k)", "Line 18: (True)", "Line 24: (i in range(n))"], ["Line 30: (ans[0] * arr[j] < ans[1] * arr[i])", "Line 24: (i in range(n))", "Line 25: (j < n and arr[i] > m * arr[j])", "Line 28: (j == n)", "Line 34: NOT (count < k)", "Line 36: NOT (count > k)", "Line 38: "], ["Line 24: (i in range(n))", "Line 30: (ans[0] * arr[j] < ans[1] * arr[i])", "Line 24: (i in range(n))", "Line 25: (j < n and arr[i] > m * arr[j])", "Line 28: (j == n)"], ["Line 24: (i in range(n))", "Line 25: (j < n and arr[i] > m * arr[j])", "Line 28: (j == n)", "Line 34: NOT (count < k)", "Line 36: (count > k)", "Line 18: (True)"]]}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "difficulty": 2, "func_name": "findCheapestPrice", "description": "There are `n` cities connected by some number of flights. You are given an\narray `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there\nis a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return the cheapest\nprice from `src` to `dst` with at most `k` stops. If there is no such route,\nreturn `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "blocks": [{"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.93}, {"type": "if", "start": 32, "end": 33, "difficulty": 1, "eg_cov_prob": 0.61}, {"type": "if", "start": 35, "end": 37, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [31, 33, 36, 37], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      log_function('LOOP #1: Entered for loop at line 15-17\\n')\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      log_function('LOOP #2: Entered for loop at line 22-24\\n')\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      log_function('LOOP #3: Entered while loop at line 28-38\\n')\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        log_function('BRANCH #1: Covered if branch at line 30-31\\n')\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        log_function('BRANCH #2: Covered if branch at line 32-33\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #4: Entered for loop at line 34-38\\n')\n        if d + w < dist[v][stops - 1]:\n          log_function('BRANCH #3: Covered if branch at line 35-37\\n')\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Cheapest Flights Within K Stops.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 34-38\n", "BRANCH #3: Covered if branch at line 35-37\n", "LOOP #3: Entered while loop at line 28-38\n", "LOOP #4: Entered for loop at line 34-38\n", "BRANCH #3: Covered if branch at line 35-37\n"], ["LOOP #1: Entered for loop at line 15-17\n", "LOOP #2: Entered for loop at line 22-24\n", "LOOP #2: Entered for loop at line 22-24\n", "LOOP #2: Entered for loop at line 22-24\n", "LOOP #3: Entered while loop at line 28-38\n"], ["BRANCH #3: Covered if branch at line 35-37\n", "LOOP #4: Entered for loop at line 34-38\n", "BRANCH #3: Covered if branch at line 35-37\n", "LOOP #3: Entered while loop at line 28-38\n", "BRANCH #2: Covered if branch at line 32-33\n"], ["LOOP #2: Entered for loop at line 22-24\n", "LOOP #2: Entered for loop at line 22-24\n", "LOOP #2: Entered for loop at line 22-24\n", "LOOP #2: Entered for loop at line 22-24\n", "LOOP #3: Entered while loop at line 28-38\n"], ["LOOP #4: Entered for loop at line 34-38\n", "BRANCH #3: Covered if branch at line 35-37\n", "LOOP #3: Entered while loop at line 28-38\n", "BRANCH #2: Covered if branch at line 32-33\n", "LOOP #3: Entered while loop at line 28-38\n"]], "sampled_condition_paths": [["Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v][stops - 1])", "Line 28: (minHeap)", "Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v][stops - 1])"], ["Line 15: (u, v, w in flights)", "Line 22: (i in range(len(graph)))", "Line 22: (i in range(len(graph)))", "Line 22: (i in range(len(graph)))", "Line 28: (minHeap)"], ["Line 35: (d + w < dist[v][stops - 1])", "Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v][stops - 1])", "Line 28: (minHeap)", "Line 32: (stops == 0 or d > dist[u][stops])"], ["Line 22: (i in range(len(graph)))", "Line 22: (i in range(len(graph)))", "Line 22: (i in range(len(graph)))", "Line 22: (i in range(len(graph)))", "Line 28: (minHeap)"], ["Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v][stops - 1])", "Line 28: (minHeap)", "Line 32: (stops == 0 or d > dist[u][stops])", "Line 28: (minHeap)"]]}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "difficulty": 2, "func_name": "validTicTacToe", "description": "Given a Tic-Tac-Toe board as a string array `board`, return `true` if and only\nif it is possible to reach this board position during the course of a valid\ntic-tac-toe game.\n\nThe board is a `3 x 3` array that consists of characters `' '`, `'X'`, and\n`'O'`. The `' '` character represents an empty square.\n\nHere are the rules of Tic-Tac-Toe:\n\n* Players take turns placing characters into empty squares `' '`.\n* The first player always places `'X'` characters, while the second player always places `'O'` characters.\n* `'X'` and `'O'` characters are always placed into empty squares, never filled ones.\n* The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n* The game also ends if all squares are non-empty.\n* No more moves can be played if the game is over.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [20, 22], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      return False\n\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Valid Tic-Tac-Toe State.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 19-20\n"], []], "sampled_condition_paths": [["Line 19: (countX < countO or countX - countO > 1)"], []]}
{"task_num": 805, "task_title": "Split Array With Same Average", "difficulty": 3, "func_name": "splitArraySameAverage", "description": "You are given an integer array `nums`.\n\nYou should move each element of `nums` into one of the two arrays `A` and `B`\nsuch that `A` and `B` are non-empty, and `average(A) == average(B)`.\n\nReturn `true` if it is possible to achieve that and `false` otherwise.\n\nNote that for an array `arr`, `average(arr)` is the sum of all the elements of\n`arr` over the length of `arr`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.54}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.21}], "target_lines": [16, 28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      log_function('BRANCH #1: Covered if branch at line 15-16\\n')\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      log_function('LOOP #1: Entered for loop at line 21-25\\n')\n      for i in range(n // 2, 0, -1):\n        log_function('LOOP #2: Entered for loop at line 22-25\\n')\n        for val in sums[i - 1]:\n          log_function('LOOP #3: Entered for loop at line 23-25\\n')\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      log_function('LOOP #4: Entered for loop at line 26-29\\n')\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        log_function('BRANCH #2: Covered if branch at line 27-28\\n')\n        return True\n\n    return False\n\ndef log_function(info_str):\n    with open(\"test_logs/Split Array With Same Average.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 23-25\n", "LOOP #1: Entered for loop at line 21-25\n", "LOOP #2: Entered for loop at line 22-25\n", "LOOP #3: Entered for loop at line 23-25\n", "LOOP #3: Entered for loop at line 23-25\n"], ["LOOP #2: Entered for loop at line 22-25\n", "LOOP #3: Entered for loop at line 23-25\n", "LOOP #1: Entered for loop at line 21-25\n", "LOOP #2: Entered for loop at line 22-25\n", "LOOP #3: Entered for loop at line 23-25\n"], ["LOOP #3: Entered for loop at line 23-25\n", "LOOP #1: Entered for loop at line 21-25\n", "LOOP #2: Entered for loop at line 22-25\n", "LOOP #3: Entered for loop at line 23-25\n", "LOOP #4: Entered for loop at line 26-29\n"], ["LOOP #3: Entered for loop at line 23-25\n", "LOOP #2: Entered for loop at line 22-25\n", "LOOP #3: Entered for loop at line 23-25\n", "LOOP #3: Entered for loop at line 23-25\n", "LOOP #3: Entered for loop at line 23-25\n"]], "sampled_condition_paths": [["Line 23: (val in sums[i - 1])", "Line 21: (num in nums)", "Line 22: (i in range(n // 2, 0, -1))", "Line 23: (val in sums[i - 1])", "Line 23: (val in sums[i - 1])"], ["Line 22: (i in range(n // 2, 0, -1))", "Line 23: (val in sums[i - 1])", "Line 21: (num in nums)", "Line 22: (i in range(n // 2, 0, -1))", "Line 23: (val in sums[i - 1])"], ["Line 23: (val in sums[i - 1])", "Line 21: (num in nums)", "Line 22: (i in range(n // 2, 0, -1))", "Line 23: (val in sums[i - 1])", "Line 26: (i in range(1, n // 2 + 1))"], ["Line 23: (val in sums[i - 1])", "Line 22: (i in range(n // 2, 0, -1))", "Line 23: (val in sums[i - 1])", "Line 23: (val in sums[i - 1])", "Line 23: (val in sums[i - 1])"]]}
{"task_num": 815, "task_title": "Bus Routes", "difficulty": 3, "func_name": "numBusesToDestination", "description": "You are given an array `routes` representing bus routes where `routes[i]` is a\nbus route that the `ith` bus repeats forever.\n\n* For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.\n\nYou will start at the bus stop `source` (You are not on any bus initially),\nand you want to go to the bus stop `target`. You can travel between bus stops\nby buses only.\n\nReturn the least number of buses you must take to travel from `source` to\n`target`. Return `-1` if it is not possible.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 31, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      log_function('LOOP #1: Entered for loop at line 19-22\\n')\n      for route in routes[i]:\n        log_function('LOOP #2: Entered for loop at line 20-22\\n')\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      log_function('LOOP #3: Entered while loop at line 26-37\\n')\n      ans += 1\n      for _ in range(len(q)):\n        log_function('LOOP #4: Entered for loop at line 28-37\\n')\n        for bus in graph[q.popleft()]:\n          log_function('LOOP #5: Entered for loop at line 29-37\\n')\n          if bus in usedBuses:\n            log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            log_function('LOOP #6: Entered for loop at line 33-37\\n')\n            if nextRoute == target:\n              log_function('BRANCH #3: Covered if branch at line 34-35\\n')\n              return ans\n            q.append(nextRoute)\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Bus Routes.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 20-22\n", "LOOP #2: Entered for loop at line 20-22\n", "LOOP #3: Entered while loop at line 26-37\n", "LOOP #4: Entered for loop at line 28-37\n", "LOOP #5: Entered for loop at line 29-37\n"], ["LOOP #5: Entered for loop at line 29-37\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 28-37\n", "LOOP #5: Entered for loop at line 29-37\n", "BRANCH #2: Covered if branch at line 30-31\n"], ["LOOP #2: Entered for loop at line 20-22\n", "LOOP #3: Entered while loop at line 26-37\n", "LOOP #4: Entered for loop at line 28-37\n", "LOOP #5: Entered for loop at line 29-37\n", "LOOP #6: Entered for loop at line 33-37\n"], ["BRANCH #2: Covered if branch at line 30-31\n", "LOOP #5: Entered for loop at line 29-37\n", "LOOP #6: Entered for loop at line 33-37\n", "LOOP #6: Entered for loop at line 33-37\n", "BRANCH #3: Covered if branch at line 34-35\n"]], "sampled_condition_paths": [["Line 20: (route in routes[i])", "Line 20: (route in routes[i])", "Line 26: (q)", "Line 28: (_ in range(len(q)))", "Line 29: (bus in graph[q.popleft()])"], ["Line 29: (bus in graph[q.popleft()])", "Line 30: (bus in usedBuses)", "Line 28: (_ in range(len(q)))", "Line 29: (bus in graph[q.popleft()])", "Line 30: (bus in usedBuses)"], ["Line 20: (route in routes[i])", "Line 26: (q)", "Line 28: (_ in range(len(q)))", "Line 29: (bus in graph[q.popleft()])", "Line 33: (nextRoute in routes[bus])"], ["Line 30: (bus in usedBuses)", "Line 29: (bus in graph[q.popleft()])", "Line 33: (nextRoute in routes[bus])", "Line 33: (nextRoute in routes[bus])", "Line 34: (nextRoute == target)"]]}
{"task_num": 838, "task_title": "Push Dominoes", "difficulty": 2, "func_name": "pushDominoes", "description": "There are `n` dominoes in a line, and we place each domino vertically upright.\nIn the beginning, we simultaneously push some of the dominoes either to the\nleft or to the right.\n\nAfter each second, each domino that is falling to the left pushes the adjacent\ndomino on the left. Similarly, the dominoes falling to the right push their\nadjacent dominoes standing on the right.\n\nWhen a vertical domino has dominoes falling on it from both sides, it stays\nstill due to the balance of the forces.\n\nFor the purposes of this question, we will consider that a falling domino\nexpends no additional force to a falling or already fallen domino.\n\nYou are given a string `dominoes` representing the initial state where:\n\n* `dominoes[i] = 'L'`, if the `ith` domino has been pushed to the left,\n* `dominoes[i] = 'R'`, if the `ith` domino has been pushed to the right, and\n* `dominoes[i] = '.'`, if the `ith` domino has not been pushed.\n\nReturn a string representing the final state.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "blocks": [{"type": "if", "start": 18, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 31, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.44}], "target_lines": [19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      log_function('LOOP #1: Entered for loop at line 17-40\\n')\n      if i == len(dominoes) or dominoes[i] == 'R':\n        log_function('BRANCH #1: Covered if branch at line 18-23\\n')\n        if L < R:\n          log_function('BRANCH #2: Covered if branch at line 19-22\\n')\n          while R < i:\n            log_function('LOOP #2: Entered while loop at line 20-22\\n')\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        log_function('BRANCH #3: Covered elif branch at line 24-39\\n')\n        if R < L or (L, R) == (-1, -1):\n          log_function('BRANCH #4: Covered if branch at line 25-30\\n')\n          if (L, R) == (-1, -1):\n            log_function('BRANCH #5: Covered if branch at line 26-27\\n')\n            L += 1\n          while L < i:\n            log_function('LOOP #3: Entered while loop at line 28-30\\n')\n            ans[L] = 'L'\n            L += 1\n        else:\n          log_function('BRANCH #6: Covered else branch at line 31-38\\n')\n          l = R + 1\n          r = i - 1\n          while l < r:\n            log_function('LOOP #4: Entered while loop at line 34-38\\n')\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n\ndef log_function(info_str):\n    with open(\"test_logs/Push Dominoes.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 17-40\n", "LOOP #1: Entered for loop at line 17-40\n", "LOOP #1: Entered for loop at line 17-40\n", "BRANCH #3: Covered elif branch at line 24-39\n", "BRANCH #6: Covered else branch at line 31-38\n"], ["LOOP #4: Entered while loop at line 34-38\n", "LOOP #1: Entered for loop at line 17-40\n", "LOOP #1: Entered for loop at line 17-40\n", "LOOP #1: Entered for loop at line 17-40\n", "BRANCH #1: Covered if branch at line 18-23\n"], ["LOOP #1: Entered for loop at line 17-40\n", "LOOP #1: Entered for loop at line 17-40\n", "BRANCH #3: Covered elif branch at line 24-39\n", "BRANCH #6: Covered else branch at line 31-38\n", "LOOP #1: Entered for loop at line 17-40\n"], ["BRANCH #2: Covered if branch at line 19-22\n", "LOOP #2: Entered while loop at line 20-22\n", "LOOP #1: Entered for loop at line 17-40\n", "LOOP #1: Entered for loop at line 17-40\n", "BRANCH #3: Covered elif branch at line 24-39\n"]], "sampled_condition_paths": [["Line 17: (i in range(len(dominoes) + 1))", "Line 17: (i in range(len(dominoes) + 1))", "Line 17: (i in range(len(dominoes) + 1))", "Line 18: NOT (i == len(dominoes) or dominoes[i] == 'R')", "Line 24: (dominoes[i] == 'L')", "Line 25: NOT (R < L or (L, R) == (-1, -1))", "Line 31: "], ["Line 34: (l < r)", "Line 17: (i in range(len(dominoes) + 1))", "Line 17: (i in range(len(dominoes) + 1))", "Line 17: (i in range(len(dominoes) + 1))", "Line 18: (i == len(dominoes) or dominoes[i] == 'R')"], ["Line 17: (i in range(len(dominoes) + 1))", "Line 17: (i in range(len(dominoes) + 1))", "Line 18: NOT (i == len(dominoes) or dominoes[i] == 'R')", "Line 24: (dominoes[i] == 'L')", "Line 25: NOT (R < L or (L, R) == (-1, -1))", "Line 31: ", "Line 17: (i in range(len(dominoes) + 1))"], ["Line 19: (L < R)", "Line 20: (R < i)", "Line 17: (i in range(len(dominoes) + 1))", "Line 17: (i in range(len(dominoes) + 1))", "Line 18: NOT (i == len(dominoes) or dominoes[i] == 'R')", "Line 24: (dominoes[i] == 'L')"]]}
{"task_num": 845, "task_title": "Longest Mountain in Array", "difficulty": 2, "func_name": "longestMountain", "description": "You may recall that an array `arr` is a mountain array if and only if:\n\n* `arr.length >= 3`\n* There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that: \n* `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n* `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return the length of the longest subarray, which\nis a mountain. Return `0` if there is no mountain subarray.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      log_function('LOOP #1: Entered while loop at line 16-33\\n')\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        log_function('LOOP #2: Entered while loop at line 17-19\\n')\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        log_function('LOOP #3: Entered while loop at line 23-26\\n')\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        log_function('LOOP #4: Entered while loop at line 27-30\\n')\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        log_function('BRANCH #1: Covered if branch at line 31-32\\n')\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Longest Mountain in Array.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered while loop at line 23-26\n", "LOOP #3: Entered while loop at line 23-26\n", "LOOP #4: Entered while loop at line 27-30\n", "LOOP #4: Entered while loop at line 27-30\n", "BRANCH #1: Covered if branch at line 31-32\n"], ["LOOP #1: Entered while loop at line 16-33\n", "LOOP #2: Entered while loop at line 17-19\n", "LOOP #2: Entered while loop at line 17-19\n"], ["LOOP #3: Entered while loop at line 23-26\n", "LOOP #4: Entered while loop at line 27-30\n", "LOOP #4: Entered while loop at line 27-30\n", "BRANCH #1: Covered if branch at line 31-32\n", "LOOP #1: Entered while loop at line 16-33\n"]], "sampled_condition_paths": [["Line 23: (i + 1 < len(arr) and arr[i] < arr[i + 1])", "Line 23: (i + 1 < len(arr) and arr[i] < arr[i + 1])", "Line 27: (i + 1 < len(arr) and arr[i] > arr[i + 1])", "Line 27: (i + 1 < len(arr) and arr[i] > arr[i + 1])", "Line 31: (increasing > 0 and decreasing > 0)"], ["Line 16: (i + 1 < len(arr))", "Line 17: (i + 1 < len(arr) and arr[i] == arr[i + 1])", "Line 17: (i + 1 < len(arr) and arr[i] == arr[i + 1])"], ["Line 23: (i + 1 < len(arr) and arr[i] < arr[i + 1])", "Line 27: (i + 1 < len(arr) and arr[i] > arr[i + 1])", "Line 27: (i + 1 < len(arr) and arr[i] > arr[i + 1])", "Line 31: (increasing > 0 and decreasing > 0)", "Line 16: (i + 1 < len(arr))"]]}
{"task_num": 854, "task_title": "K-Similar Strings", "difficulty": 3, "func_name": "kSimilarity", "description": "Strings `s1` and `s2` are `k`-similar (for some non-negative integer `k`) if\nwe can swap the positions of two letters in `s1` exactly `k` times so that the\nresulting string equals `s2`.\n\nGiven two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and\n`s2` are `k`-similar.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "blocks": [{"type": "if", "start": 39, "end": 42, "difficulty": 1, "eg_cov_prob": 0.9}, {"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.73}], "target_lines": [21, 24, 40, 41, 42], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      log_function('LOOP #1: Entered while loop at line 17-28\\n')\n      for _ in range(len(q)):\n        log_function('LOOP #2: Entered for loop at line 18-26\\n')\n        curr = q.popleft()\n        if curr == s2:\n          log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n          return ans\n        for child in self._getChildren(curr, s2):\n          log_function('LOOP #3: Entered for loop at line 22-26\\n')\n          if child in seen:\n            log_function('BRANCH #2: Covered if branch at line 23-24\\n')\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      log_function('LOOP #4: Entered while loop at line 35-37\\n')\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      log_function('LOOP #5: Entered for loop at line 38-43\\n')\n      if s[j] == target[i]:\n        log_function('BRANCH #3: Covered if branch at line 39-42\\n')\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n\ndef log_function(info_str):\n    with open(\"test_logs/K-Similar Strings.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #5: Entered for loop at line 38-43\n", "BRANCH #3: Covered if branch at line 39-42\n", "LOOP #3: Entered for loop at line 22-26\n", "LOOP #1: Entered while loop at line 17-28\n", "LOOP #2: Entered for loop at line 18-26\n"], ["LOOP #4: Entered while loop at line 35-37\n", "LOOP #5: Entered for loop at line 38-43\n", "BRANCH #3: Covered if branch at line 39-42\n", "LOOP #3: Entered for loop at line 22-26\n", "LOOP #1: Entered while loop at line 17-28\n"], ["LOOP #2: Entered for loop at line 18-26\n", "LOOP #5: Entered for loop at line 38-43\n", "BRANCH #3: Covered if branch at line 39-42\n", "LOOP #3: Entered for loop at line 22-26\n", "LOOP #1: Entered while loop at line 17-28\n"]], "sampled_condition_paths": [["Line 38: (j in range(i + 1, len(s)))", "Line 39: (s[j] == target[i])", "Line 22: (child in self._getChildren(curr, s2))", "Line 17: (q)", "Line 18: (_ in range(len(q)))"], ["Line 35: (curr[i] == target[i])", "Line 38: (j in range(i + 1, len(s)))", "Line 39: (s[j] == target[i])", "Line 22: (child in self._getChildren(curr, s2))", "Line 17: (q)"], ["Line 18: (_ in range(len(q)))", "Line 38: (j in range(i + 1, len(s)))", "Line 39: (s[j] == target[i])", "Line 22: (child in self._getChildren(curr, s2))", "Line 17: (q)"]]}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "difficulty": 2, "func_name": "matrixScore", "description": "You are given an `m x n` binary matrix `grid`.\n\nA move consists of choosing any row or column and toggling each value in that\nrow or column (i.e., changing all `0`'s to `1`'s, and all `1`'s to `0`'s).\n\nEvery row of the matrix is interpreted as a binary number, and the score of\nthe matrix is the sum of these numbers.\n\nReturn the highest possible score after making any number of moves (including\nzero moves).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "if", "start": 18, "end": 19, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [15, 19], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      log_function('LOOP #1: Entered for loop at line 13-16\\n')\n      if row[0] == 0:\n        log_function('BRANCH #1: Covered if branch at line 14-15\\n')\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      log_function('LOOP #2: Entered for loop at line 17-20\\n')\n      if sum(col) * 2 < len(grid):\n        log_function('BRANCH #2: Covered if branch at line 18-19\\n')\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      log_function('LOOP #3: Entered for loop at line 24-26\\n')\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      log_function('LOOP #4: Entered for loop at line 28-30\\n')\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      log_function('LOOP #5: Entered for loop at line 33-34\\n')\n      res = res * 2 + row[j]\n    return res\n\ndef log_function(info_str):\n    with open(\"test_logs/Score After Flipping Matrix.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 24-26\n", "LOOP #3: Entered for loop at line 24-26\n", "LOOP #3: Entered for loop at line 24-26\n", "LOOP #1: Entered for loop at line 13-16\n", "LOOP #1: Entered for loop at line 13-16\n"], ["LOOP #1: Entered for loop at line 13-16\n", "BRANCH #1: Covered if branch at line 14-15\n", "LOOP #3: Entered for loop at line 24-26\n", "LOOP #2: Entered for loop at line 17-20\n"], ["LOOP #2: Entered for loop at line 17-20\n", "LOOP #2: Entered for loop at line 17-20\n", "LOOP #2: Entered for loop at line 17-20\n", "BRANCH #2: Covered if branch at line 18-19\n", "LOOP #4: Entered for loop at line 28-30\n"]], "sampled_condition_paths": [["Line 24: (i in range(len(row)))", "Line 24: (i in range(len(row)))", "Line 24: (i in range(len(row)))", "Line 13: (row in grid)", "Line 13: (row in grid)"], ["Line 13: (row in grid)", "Line 14: (row[0] == 0)", "Line 24: (i in range(len(row)))", "Line 17: (j, col in enumerate(list(zip(*grid))))"], ["Line 17: (j, col in enumerate(list(zip(*grid))))", "Line 17: (j, col in enumerate(list(zip(*grid))))", "Line 17: (j, col in enumerate(list(zip(*grid))))", "Line 18: (sum(col) * 2 < len(grid))", "Line 28: (i in range(len(grid)))"]]}
{"task_num": 866, "task_title": "Prime Palindrome", "difficulty": 2, "func_name": "primePalindrome", "description": "Given an integer n, return the smallest prime palindrome greater than or equal\nto `n`.\n\nAn integer is prime if it has exactly two divisors: `1` and itself. Note that\n`1` is not a prime number.\n\n* For example, `2`, `3`, `5`, `7`, `11`, and `13` are all primes.\n\nAn integer is a palindrome if it reads the same from left to right as it does\nfrom right to left.\n\n* For example, `101` and `12321` are palindromes.\n\nThe test cases are generated so that the answer always exists and is in the\nrange `[2, 2 * 108]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 41, "end": 42, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 27, 29, 31, 33, 35, 42], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        log_function('LOOP #1: Entered for loop at line 15-19\\n')\n        s = str(i)\n        for j in range(10):\n          log_function('LOOP #2: Entered for loop at line 17-19\\n')\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        log_function('LOOP #3: Entered for loop at line 21-23\\n')\n        if num % i == 0:\n          log_function('BRANCH #1: Covered if branch at line 22-23\\n')\n          return False\n      return True\n\n    if n <= 2:\n      log_function('BRANCH #2: Covered if branch at line 26-27\\n')\n      return 2\n    if n == 3:\n      log_function('BRANCH #3: Covered if branch at line 28-29\\n')\n      return 3\n    if n <= 5:\n      log_function('BRANCH #4: Covered if branch at line 30-31\\n')\n      return 5\n    if n <= 7:\n      log_function('BRANCH #5: Covered if branch at line 32-33\\n')\n      return 7\n    if n <= 11:\n      log_function('BRANCH #6: Covered if branch at line 34-35\\n')\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      log_function('LOOP #4: Entered while loop at line 39-44\\n')\n      for num in getPalindromes(nLength):\n        log_function('LOOP #5: Entered for loop at line 40-42\\n')\n        if num >= n and isPrime(num):\n          log_function('BRANCH #7: Covered if branch at line 41-42\\n')\n          return num\n      nLength += 1\n\ndef log_function(info_str):\n    with open(\"test_logs/Prime Palindrome.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #5: Covered if branch at line 32-33\n"], ["LOOP #3: Entered for loop at line 21-23\n", "LOOP #3: Entered for loop at line 21-23\n", "LOOP #3: Entered for loop at line 21-23\n", "LOOP #3: Entered for loop at line 21-23\n", "LOOP #3: Entered for loop at line 21-23\n"], ["BRANCH #6: Covered if branch at line 34-35\n"], ["LOOP #1: Entered for loop at line 15-19\n", "LOOP #2: Entered for loop at line 17-19\n", "LOOP #5: Entered for loop at line 40-42\n", "LOOP #3: Entered for loop at line 21-23\n", "LOOP #3: Entered for loop at line 21-23\n"]], "sampled_condition_paths": [["Line 32: (n <= 7)"], ["Line 21: (i in range(2, int(num**0.5 + 1)))", "Line 21: (i in range(2, int(num**0.5 + 1)))", "Line 21: (i in range(2, int(num**0.5 + 1)))", "Line 21: (i in range(2, int(num**0.5 + 1)))", "Line 21: (i in range(2, int(num**0.5 + 1)))"], ["Line 34: (n <= 11)"], ["Line 15: (i in range(10**(length - 1), 10**length))", "Line 17: (j in range(10))", "Line 40: (num in getPalindromes(nLength))", "Line 21: (i in range(2, int(num**0.5 + 1)))", "Line 21: (i in range(2, int(num**0.5 + 1)))"]]}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "difficulty": 3, "func_name": "reachableNodes", "description": "You are given an undirected graph (the \"original graph\") with `n` nodes\nlabeled from `0` to `n - 1`. You decide to subdivide each edge in the graph\ninto a chain of nodes, with the number of new nodes varying between each edge.\n\nThe graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]`\nindicates that there is an edge between nodes `ui` and `vi` in the original\ngraph, and `cnti` is the total number of new nodes that you will subdivide the\nedge into. Note that `cnti == 0` means you will not subdivide the edge.\n\nTo subdivide the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and\n`cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new\nedges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti-1, xcnti]`,\n`[xcnti, vi]`.\n\nIn this new graph, you want to know how many nodes are reachable from the node\n`0`, where a node is reachable if the distance is `maxMoves` or less.\n\nGiven the original graph and `maxMoves`, return the number of nodes that are\nreachable from node `0` in the new graph.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "blocks": [{"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.87}, {"type": "if", "start": 42, "end": 44, "difficulty": 1, "eg_cov_prob": 0.92}], "target_lines": [37, 39, 43, 44], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      log_function('LOOP #1: Entered for loop at line 16-19\\n')\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      log_function('LOOP #2: Entered for loop at line 23-27\\n')\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      log_function('LOOP #3: Entered while loop at line 34-45\\n')\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        log_function('BRANCH #1: Covered if branch at line 36-37\\n')\n        break\n      if d > dist[u]:\n        log_function('BRANCH #2: Covered if branch at line 38-39\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #4: Entered for loop at line 40-45\\n')\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          log_function('BRANCH #3: Covered if branch at line 42-44\\n')\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n\ndef log_function(info_str):\n    with open(\"test_logs/Reachable Nodes In Subdivided Graph.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 42-44\n", "LOOP #3: Entered while loop at line 34-45\n", "LOOP #4: Entered for loop at line 40-45\n", "LOOP #4: Entered for loop at line 40-45\n", "LOOP #2: Entered for loop at line 23-27\n"], ["BRANCH #3: Covered if branch at line 42-44\n", "LOOP #3: Entered while loop at line 34-45\n", "LOOP #4: Entered for loop at line 40-45\n", "LOOP #4: Entered for loop at line 40-45\n", "LOOP #4: Entered for loop at line 40-45\n"], ["LOOP #1: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 16-19\n", "LOOP #3: Entered while loop at line 34-45\n", "LOOP #4: Entered for loop at line 40-45\n"], ["LOOP #3: Entered while loop at line 34-45\n", "LOOP #2: Entered for loop at line 23-27\n", "LOOP #2: Entered for loop at line 23-27\n", "LOOP #2: Entered for loop at line 23-27\n", "LOOP #2: Entered for loop at line 23-27\n"], ["LOOP #4: Entered for loop at line 40-45\n", "LOOP #4: Entered for loop at line 40-45\n", "BRANCH #3: Covered if branch at line 42-44\n", "LOOP #3: Entered while loop at line 34-45\n", "LOOP #4: Entered for loop at line 40-45\n"]], "sampled_condition_paths": [["Line 42: (newDist < dist[v])", "Line 34: (minHeap)", "Line 40: (v, w in graph[u])", "Line 40: (v, w in graph[u])", "Line 23: (u, v, cnt in edges)"], ["Line 42: (newDist < dist[v])", "Line 34: (minHeap)", "Line 40: (v, w in graph[u])", "Line 40: (v, w in graph[u])", "Line 40: (v, w in graph[u])"], ["Line 16: (u, v, cnt in edges)", "Line 16: (u, v, cnt in edges)", "Line 16: (u, v, cnt in edges)", "Line 34: (minHeap)", "Line 40: (v, w in graph[u])"], ["Line 34: (minHeap)", "Line 23: (u, v, cnt in edges)", "Line 23: (u, v, cnt in edges)", "Line 23: (u, v, cnt in edges)", "Line 23: (u, v, cnt in edges)"], ["Line 40: (v, w in graph[u])", "Line 40: (v, w in graph[u])", "Line 42: (newDist < dist[v])", "Line 34: (minHeap)", "Line 40: (v, w in graph[u])"]]}
{"task_num": 909, "task_title": "Snakes and Ladders", "difficulty": 2, "func_name": "snakesAndLadders", "description": "You are given an `n x n` integer matrix `board` where the cells are labeled\nfrom `1` to `n2` in a Boustrophedon style starting from the bottom left of the\nboard (i.e. `board[n - 1][0]`) and alternating direction each row.\n\nYou start on square `1` of the board. In each move, starting from square\n`curr`, do the following:\n\n* Choose a destination square `next` with a label in the range `[curr + 1, min(curr + 6, n2)]`. \n* This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.\n* If `next` has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to `next`.\n* The game ends when you reach the square `n2`.\n\nA board square on row `r` and column `c` has a snake or ladder if `board[r][c]\n!= -1`. The destination of that snake or ladder is `board[r][c]`. Squares `1`\nand `n2` do not have a snake or ladder.\n\nNote that you only take a snake or ladder at most once per move. If the\ndestination to a snake or ladder is the start of another snake or ladder, you\ndo not follow the subsequent snake or ladder.\n\n* For example, suppose the board is `[[-1,4],[-1,3]]`, and on the first move, your destination square is `2`. You follow the ladder to square `3`, but do not follow the subsequent ladder to `4`.\n\nReturn the least number of moves required to reach the square `n2`. If it is\nnot possible to reach the square, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 1, "eg_cov_prob": 0.86}, {"type": "if", "start": 34, "end": 35, "difficulty": 1, "eg_cov_prob": 0.92}], "target_lines": [22, 24, 33, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      log_function('LOOP #1: Entered for loop at line 19-25\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-25\\n')\n        if n - i & 1 :\n          log_function('BRANCH #1: Covered if branch at line 21-22\\n')\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          log_function('BRANCH #2: Covered else branch at line 23-24\\n')\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      log_function('LOOP #3: Entered while loop at line 26-38\\n')\n      ans += 1\n      for _ in range(len(q)):\n        log_function('LOOP #4: Entered for loop at line 28-38\\n')\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          log_function('LOOP #5: Entered for loop at line 30-38\\n')\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            log_function('BRANCH #3: Covered if branch at line 32-33\\n')\n            return ans\n          if dest in seen:\n            log_function('BRANCH #4: Covered if branch at line 34-35\\n')\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Snakes and Ladders.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 20-25\n", "BRANCH #2: Covered else branch at line 23-24\n", "LOOP #1: Entered for loop at line 19-25\n", "LOOP #2: Entered for loop at line 20-25\n", "BRANCH #1: Covered if branch at line 21-22\n"], ["BRANCH #2: Covered else branch at line 23-24\n", "LOOP #2: Entered for loop at line 20-25\n", "BRANCH #2: Covered else branch at line 23-24\n", "LOOP #1: Entered for loop at line 19-25\n", "LOOP #2: Entered for loop at line 20-25\n"], ["LOOP #2: Entered for loop at line 20-25\n", "BRANCH #2: Covered else branch at line 23-24\n", "LOOP #2: Entered for loop at line 20-25\n", "BRANCH #2: Covered else branch at line 23-24\n", "LOOP #2: Entered for loop at line 20-25\n"], ["BRANCH #2: Covered else branch at line 23-24\n", "LOOP #1: Entered for loop at line 19-25\n", "LOOP #2: Entered for loop at line 20-25\n", "BRANCH #1: Covered if branch at line 21-22\n", "LOOP #2: Entered for loop at line 20-25\n"]], "sampled_condition_paths": [["Line 20: (j in range(n))", "Line 21: NOT (n - i & 1 )", "Line 23: ", "Line 19: (i in range(n))", "Line 20: (j in range(n))", "Line 21: (n - i & 1 )"], ["Line 21: NOT (n - i & 1 )", "Line 23: ", "Line 20: (j in range(n))", "Line 21: NOT (n - i & 1 )", "Line 23: ", "Line 19: (i in range(n))", "Line 20: (j in range(n))"], ["Line 20: (j in range(n))", "Line 21: NOT (n - i & 1 )", "Line 23: ", "Line 20: (j in range(n))", "Line 21: NOT (n - i & 1 )", "Line 23: ", "Line 20: (j in range(n))"], ["Line 21: NOT (n - i & 1 )", "Line 23: ", "Line 19: (i in range(n))", "Line 20: (j in range(n))", "Line 21: (n - i & 1 )", "Line 20: (j in range(n))"]]}
{"task_num": 913, "task_title": "Cat and Mouse", "difficulty": 3, "func_name": "catMouseGame", "description": "A game on an undirected graph is played by two players, Mouse and Cat, who\nalternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that\n`ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first, the cat starts at node `2` and\ngoes second, and there is a hole at node `0`.\n\nDuring each player's turn, they must travel along one edge of the graph that\nmeets where they are. For example, if the Mouse is at node 1, it must travel\nto any node in `graph[1]`.\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node `0`).\n\nThen, the game can end in three ways:\n\n* If ever the Cat occupies the same node as the Mouse, the Cat wins.\n* If ever the Mouse reaches the Hole, the Mouse wins.\n* If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a `graph`, and assuming both players play optimally, return\n\n* `1` if the mouse wins the game,\n* `2` if the cat wins the game, or\n* `0` if the game is a draw.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "blocks": [{"type": "if", "start": 41, "end": 42, "difficulty": 1, "eg_cov_prob": 0.77}, {"type": "if", "start": 46, "end": 47, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 51, "end": 54, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 55, "end": 59, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 57, "end": 59, "difficulty": 1, "eg_cov_prob": 0.81}], "target_lines": [42, 47, 50, 52, 53, 54, 56, 57, 58, 59], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      log_function('LOOP #1: Entered for loop at line 27-31\\n')\n      for mouse in range(n):\n        log_function('LOOP #2: Entered for loop at line 28-31\\n')\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      log_function('LOOP #3: Entered for loop at line 32-38\\n')\n      for move in range(2):\n        log_function('LOOP #4: Entered for loop at line 33-38\\n')\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      log_function('LOOP #5: Entered while loop at line 39-60\\n')\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        log_function('BRANCH #1: Covered if branch at line 41-42\\n')\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        log_function('LOOP #6: Entered for loop at line 44-60\\n')\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          log_function('BRANCH #2: Covered if branch at line 46-47\\n')\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          log_function('BRANCH #3: Covered if branch at line 49-50\\n')\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          log_function('BRANCH #4: Covered if branch at line 51-54\\n')\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          log_function('BRANCH #5: Covered else branch at line 55-59\\n')\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            log_function('BRANCH #6: Covered if branch at line 57-59\\n')\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n\ndef log_function(info_str):\n    with open(\"test_logs/Cat and Mouse.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #1: Entered for loop at line 27-31\n"], ["BRANCH #4: Covered if branch at line 51-54\n", "LOOP #5: Entered while loop at line 39-60\n", "LOOP #6: Entered for loop at line 44-60\n", "BRANCH #4: Covered if branch at line 51-54\n", "LOOP #6: Entered for loop at line 44-60\n"], ["LOOP #5: Entered while loop at line 39-60\n", "LOOP #6: Entered for loop at line 44-60\n", "BRANCH #3: Covered if branch at line 49-50\n", "LOOP #5: Entered while loop at line 39-60\n", "LOOP #6: Entered for loop at line 44-60\n"], ["LOOP #1: Entered for loop at line 27-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n"]], "sampled_condition_paths": [["Line 28: (mouse in range(n))", "Line 28: (mouse in range(n))", "Line 28: (mouse in range(n))", "Line 28: (mouse in range(n))", "Line 27: (cat in range(n))"], ["Line 51: (prevMove == 0 and state == int(State.kMouseWin) or prevMove == 1 and state == int(State.kCatWin))", "Line 39: (q)", "Line 44: (prev in graph[cat if prevMove else mouse])", "Line 51: (prevMove == 0 and state == int(State.kMouseWin) or prevMove == 1 and state == int(State.kCatWin))", "Line 44: (prev in graph[cat if prevMove else mouse])"], ["Line 39: (q)", "Line 44: (prev in graph[cat if prevMove else mouse])", "Line 49: (states[prevCat][prevMouse][prevMove])", "Line 39: (q)", "Line 44: (prev in graph[cat if prevMove else mouse])"], ["Line 27: (cat in range(n))", "Line 28: (mouse in range(n))", "Line 28: (mouse in range(n))", "Line 28: (mouse in range(n))", "Line 28: (mouse in range(n))"]]}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "difficulty": 2, "func_name": "threeSumMulti", "description": "Given an integer array `arr`, and an integer `target`, return the number of\ntuples `i, j, k` such that `i < j < k` and `arr[i] + arr[j] + arr[k] ==\ntarget`.\n\nAs the answer can be very large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.34}, {"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.97}], "target_lines": [21, 23, 25, 27], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      log_function('LOOP #1: Entered for loop at line 17-28\\n')\n      for j, y in count.items():\n        log_function('LOOP #2: Entered for loop at line 18-28\\n')\n        k = target - i - j\n        if k not in count:\n          log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n          continue\n        if i == j and j == k:\n          log_function('BRANCH #2: Covered if branch at line 22-23\\n')\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          log_function('BRANCH #3: Covered elif branch at line 24-25\\n')\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          log_function('BRANCH #4: Covered elif branch at line 26-27\\n')\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n\ndef log_function(info_str):\n    with open(\"test_logs/3Sum With Multiplicity.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 18-28\n", "BRANCH #1: Covered if branch at line 20-21\n", "LOOP #2: Entered for loop at line 18-28\n", "LOOP #1: Entered for loop at line 17-28\n", "LOOP #2: Entered for loop at line 18-28\n"], ["LOOP #2: Entered for loop at line 18-28\n", "LOOP #1: Entered for loop at line 17-28\n", "LOOP #2: Entered for loop at line 18-28\n", "LOOP #2: Entered for loop at line 18-28\n", "BRANCH #3: Covered elif branch at line 24-25\n"], ["LOOP #1: Entered for loop at line 17-28\n", "LOOP #2: Entered for loop at line 18-28\n", "LOOP #2: Entered for loop at line 18-28\n", "LOOP #2: Entered for loop at line 18-28\n", "BRANCH #1: Covered if branch at line 20-21\n"], ["LOOP #1: Entered for loop at line 17-28\n", "LOOP #2: Entered for loop at line 18-28\n", "LOOP #2: Entered for loop at line 18-28\n", "LOOP #2: Entered for loop at line 18-28\n", "BRANCH #3: Covered elif branch at line 24-25\n"], ["LOOP #2: Entered for loop at line 18-28\n", "LOOP #2: Entered for loop at line 18-28\n", "BRANCH #3: Covered elif branch at line 24-25\n", "LOOP #2: Entered for loop at line 18-28\n", "LOOP #2: Entered for loop at line 18-28\n"]], "sampled_condition_paths": [["Line 18: (j, y in count.items())", "Line 20: (k not in count)", "Line 18: (j, y in count.items())", "Line 17: (i, x in count.items())", "Line 18: (j, y in count.items())"], ["Line 18: (j, y in count.items())", "Line 17: (i, x in count.items())", "Line 18: (j, y in count.items())", "Line 18: (j, y in count.items())", "Line 22: NOT (i == j and j == k)", "Line 24: (i == j and j != k)"], ["Line 17: (i, x in count.items())", "Line 18: (j, y in count.items())", "Line 18: (j, y in count.items())", "Line 18: (j, y in count.items())", "Line 20: (k not in count)"], ["Line 17: (i, x in count.items())", "Line 18: (j, y in count.items())", "Line 18: (j, y in count.items())", "Line 18: (j, y in count.items())", "Line 22: NOT (i == j and j == k)", "Line 24: (i == j and j != k)"], ["Line 18: (j, y in count.items())", "Line 18: (j, y in count.items())", "Line 22: NOT (i == j and j == k)", "Line 24: (i == j and j != k)", "Line 18: (j, y in count.items())", "Line 18: (j, y in count.items())"]]}
{"task_num": 927, "task_title": "Three Equal Parts", "difficulty": 3, "func_name": "threeEqualParts", "description": "You are given an array `arr` which consists of only zeros and ones, divide the\narray into three non-empty parts such that all of these parts represent the\nsame binary value.\n\nIf it is possible, return any `[i, j]` with `i + 1 < j`, such that:\n\n* `arr[0], arr[1], ..., arr[i]` is the first part,\n* `arr[i + 1], arr[i + 2], ..., arr[j - 1]` is the second part, and\n* `arr[j], arr[j + 1], ..., arr[arr.length - 1]` is the third part.\n* All three parts have equal binary values.\n\nIf it is not possible, return `[-1, -1]`.\n\nNote that the entire part is used when considering what binary value it\nrepresents. For example, `[1,1,0]` represents `6` in decimal, not `3`. Also,\nleading zeros are allowed, so `[0,1,1]` and `[1,1]` represent the same value.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 1, "eg_cov_prob": 0.61}, {"type": "if", "start": 51, "end": 52, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 26, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 31, "end": 35, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 40, "end": 44, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 33, "end": 35, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 42, "end": 44, "difficulty": 2, "eg_cov_prob": 0.39}], "target_lines": [16, 18, 25, 26, 32, 33, 34, 35, 41, 42, 43, 44, 52], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      log_function('BRANCH #1: Covered if branch at line 15-16\\n')\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      log_function('BRANCH #2: Covered if branch at line 17-18\\n')\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      log_function('LOOP #1: Entered for loop at line 23-27\\n')\n      if arr[i] == 1:\n        log_function('BRANCH #3: Covered if branch at line 24-26\\n')\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      log_function('LOOP #2: Entered for loop at line 30-36\\n')\n      if arr[j] == 1:\n        log_function('BRANCH #4: Covered if branch at line 31-35\\n')\n        gapOnes -= 1\n        if gapOnes == 0:\n          log_function('BRANCH #5: Covered if branch at line 33-35\\n')\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      log_function('LOOP #3: Entered for loop at line 39-45\\n')\n      if arr[i] == 1:\n        log_function('BRANCH #6: Covered if branch at line 40-44\\n')\n        gapOnes -= 1\n        if gapOnes == 0:\n          log_function('BRANCH #7: Covered if branch at line 42-44\\n')\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      log_function('LOOP #4: Entered while loop at line 46-50\\n')\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      log_function('BRANCH #8: Covered if branch at line 51-52\\n')\n      return [first - 1, second]\n    return [-1, -1]\n\ndef log_function(info_str):\n    with open(\"test_logs/Three Equal Parts.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 17-18\n"], ["LOOP #2: Entered for loop at line 30-36\n", "LOOP #2: Entered for loop at line 30-36\n", "BRANCH #4: Covered if branch at line 31-35\n", "BRANCH #5: Covered if branch at line 33-35\n", "LOOP #3: Entered for loop at line 39-45\n"], ["LOOP #3: Entered for loop at line 39-45\n", "LOOP #3: Entered for loop at line 39-45\n", "LOOP #3: Entered for loop at line 39-45\n", "BRANCH #6: Covered if branch at line 40-44\n", "BRANCH #7: Covered if branch at line 42-44\n"], ["LOOP #3: Entered for loop at line 39-45\n", "LOOP #3: Entered for loop at line 39-45\n", "BRANCH #6: Covered if branch at line 40-44\n", "BRANCH #7: Covered if branch at line 42-44\n", "LOOP #4: Entered while loop at line 46-50\n"]], "sampled_condition_paths": [["Line 17: (ones % 3 != 0)"], ["Line 30: (j in range(i + 1, len(arr)))", "Line 30: (j in range(i + 1, len(arr)))", "Line 31: (arr[j] == 1)", "Line 33: (gapOnes == 0)", "Line 39: (i in range(j + 1, len(arr)))"], ["Line 39: (i in range(j + 1, len(arr)))", "Line 39: (i in range(j + 1, len(arr)))", "Line 39: (i in range(j + 1, len(arr)))", "Line 40: (arr[i] == 1)", "Line 42: (gapOnes == 0)"], ["Line 39: (i in range(j + 1, len(arr)))", "Line 39: (i in range(j + 1, len(arr)))", "Line 40: (arr[i] == 1)", "Line 42: (gapOnes == 0)", "Line 46: (third < len(arr) and arr[first] == arr[second] == arr[third])"]]}
{"task_num": 935, "task_title": "Knight Dialer", "difficulty": 2, "func_name": "knightDialer", "description": "The chess knight has a unique movement, it may move two squares vertically and\none square horizontally, or two squares horizontally and one square vertically\n(with both forming the shape of an L). The possible movements of chess knight\nare shown in this diagram:\n\nA chess knight can move as indicated in the chess diagram below:\n\nWe have a chess knight and a phone pad as shown below, the knight can only\nstand on a numeric cell (i.e. blue cell).\n\nGiven an integer `n`, return how many distinct phone numbers of length `n` we\ncan dial.\n\nYou are allowed to place the knight on any numeric cell initially and then you\nshould perform `n - 1` jumps to dial a number of length `n`. All jumps should\nbe valid knight jumps.\n\nAs the answer may be very large, return the answer modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 29, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      log_function('LOOP #1: Entered for loop at line 19-34\\n')\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        log_function('LOOP #2: Entered for loop at line 21-32\\n')\n        for j in range(3):\n          log_function('LOOP #3: Entered for loop at line 22-32\\n')\n          if (i, j) in ((3, 0), (3, 2)):\n            log_function('BRANCH #1: Covered if branch at line 23-24\\n')\n            continue\n          for dx, dy in dirs:\n            log_function('LOOP #4: Entered for loop at line 25-32\\n')\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              log_function('BRANCH #2: Covered if branch at line 28-29\\n')\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              log_function('BRANCH #3: Covered if branch at line 30-31\\n')\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n\ndef log_function(info_str):\n    with open(\"test_logs/Knight Dialer.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 22-32\n", "LOOP #4: Entered for loop at line 25-32\n", "BRANCH #3: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 25-32\n", "BRANCH #2: Covered if branch at line 28-29\n"], ["LOOP #4: Entered for loop at line 25-32\n", "BRANCH #2: Covered if branch at line 28-29\n", "LOOP #4: Entered for loop at line 25-32\n", "BRANCH #2: Covered if branch at line 28-29\n", "LOOP #4: Entered for loop at line 25-32\n"], ["LOOP #4: Entered for loop at line 25-32\n", "BRANCH #2: Covered if branch at line 28-29\n", "LOOP #3: Entered for loop at line 22-32\n", "LOOP #4: Entered for loop at line 25-32\n", "BRANCH #2: Covered if branch at line 28-29\n"], ["LOOP #4: Entered for loop at line 25-32\n", "BRANCH #2: Covered if branch at line 28-29\n", "LOOP #4: Entered for loop at line 25-32\n", "BRANCH #3: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 25-32\n"], []], "sampled_condition_paths": [["Line 22: (j in range(3))", "Line 25: (dx, dy in dirs)", "Line 30: ((x, y) in ((3, 0), (3, 2)))", "Line 25: (dx, dy in dirs)", "Line 28: (x < 0 or x >= 4 or y < 0 or y >= 3)"], ["Line 25: (dx, dy in dirs)", "Line 28: (x < 0 or x >= 4 or y < 0 or y >= 3)", "Line 25: (dx, dy in dirs)", "Line 28: (x < 0 or x >= 4 or y < 0 or y >= 3)", "Line 25: (dx, dy in dirs)"], ["Line 25: (dx, dy in dirs)", "Line 28: (x < 0 or x >= 4 or y < 0 or y >= 3)", "Line 22: (j in range(3))", "Line 25: (dx, dy in dirs)", "Line 28: (x < 0 or x >= 4 or y < 0 or y >= 3)"], ["Line 25: (dx, dy in dirs)", "Line 28: (x < 0 or x >= 4 or y < 0 or y >= 3)", "Line 25: (dx, dy in dirs)", "Line 30: ((x, y) in ((3, 0), (3, 2)))", "Line 25: (dx, dy in dirs)"], []]}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "difficulty": 2, "func_name": "minAreaRect", "description": "You are given an array of points in the X-Y plane `points` where `points[i] =\n[xi, yi]`.\n\nReturn the minimum area of a rectangle formed from these points, with sides\nparallel to the X and Y axes. If there is not any such rectangle, return `0`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.63}, {"type": "if", "start": 25, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [24, 26], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      log_function('LOOP #1: Entered for loop at line 16-18\\n')\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      log_function('LOOP #2: Entered for loop at line 19-27\\n')\n      for j in range(i):\n        log_function('LOOP #3: Entered for loop at line 20-27\\n')\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          log_function('BRANCH #1: Covered if branch at line 23-24\\n')\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Area Rectangle.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 20-27\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #2: Entered for loop at line 19-27\n", "LOOP #3: Entered for loop at line 20-27\n", "BRANCH #2: Covered if branch at line 25-26\n"], ["LOOP #2: Entered for loop at line 19-27\n", "LOOP #3: Entered for loop at line 20-27\n", "BRANCH #1: Covered if branch at line 23-24\n", "LOOP #2: Entered for loop at line 19-27\n", "LOOP #3: Entered for loop at line 20-27\n"], ["LOOP #1: Entered for loop at line 16-18\n", "LOOP #2: Entered for loop at line 19-27\n", "LOOP #2: Entered for loop at line 19-27\n", "LOOP #3: Entered for loop at line 20-27\n", "BRANCH #1: Covered if branch at line 23-24\n"], ["LOOP #2: Entered for loop at line 19-27\n", "LOOP #3: Entered for loop at line 20-27\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #3: Entered for loop at line 20-27\n", "BRANCH #1: Covered if branch at line 23-24\n"]], "sampled_condition_paths": [["Line 20: (j in range(i))", "Line 25: (y2 in xToYs[x1] and y1 in xToYs[x2])", "Line 19: (i in range(len(points)))", "Line 20: (j in range(i))", "Line 25: (y2 in xToYs[x1] and y1 in xToYs[x2])"], ["Line 19: (i in range(len(points)))", "Line 20: (j in range(i))", "Line 23: (x1 == x2 or y1 == y2)", "Line 19: (i in range(len(points)))", "Line 20: (j in range(i))"], ["Line 16: (x, y in points)", "Line 19: (i in range(len(points)))", "Line 19: (i in range(len(points)))", "Line 20: (j in range(i))", "Line 23: (x1 == x2 or y1 == y2)"], ["Line 19: (i in range(len(points)))", "Line 20: (j in range(i))", "Line 25: (y2 in xToYs[x1] and y1 in xToYs[x2])", "Line 20: (j in range(i))", "Line 23: (x1 == x2 or y1 == y2)"]]}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "difficulty": 3, "func_name": "largestComponentSize", "description": "You are given an integer array of unique positive integers `nums`. Consider\nthe following graph:\n\n* There are `nums.length` nodes, labeled `nums[0]` to `nums[nums.length - 1]`,\n* There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`.\n\nReturn the size of the largest connected component in the graph.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 31, 44, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 30-31\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      log_function('LOOP #1: Entered for loop at line 41-46\\n')\n      for x in range(2, int(math.sqrt(num) + 1)):\n        log_function('LOOP #2: Entered for loop at line 42-46\\n')\n        if num % x == 0:\n          log_function('BRANCH #6: Covered if branch at line 43-45\\n')\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      log_function('LOOP #3: Entered for loop at line 47-51\\n')\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Largest Component Size by Common Factor.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 47-51\n", "BRANCH #5: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 47-51\n", "BRANCH #5: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 47-51\n"], ["BRANCH #2: Covered if branch at line 21-22\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #3: Entered for loop at line 47-51\n", "BRANCH #5: Covered if branch at line 30-31\n"], ["BRANCH #5: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 47-51\n", "BRANCH #5: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 47-51\n", "BRANCH #5: Covered if branch at line 30-31\n"], ["BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #1: Covered if branch at line 19-20\n", "LOOP #1: Entered for loop at line 41-46\n", "LOOP #2: Entered for loop at line 42-46\n"], ["LOOP #2: Entered for loop at line 42-46\n", "BRANCH #6: Covered if branch at line 43-45\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #1: Covered if branch at line 19-20\n"], ["LOOP #2: Entered for loop at line 42-46\n", "LOOP #2: Entered for loop at line 42-46\n", "BRANCH #6: Covered if branch at line 43-45\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #3: Covered elif branch at line 23-24\n"]], "sampled_condition_paths": [["Line 47: (num in nums)", "Line 30: (self.id[u] != u)", "Line 47: (num in nums)", "Line 30: (self.id[u] != u)", "Line 47: (num in nums)"], ["Line 21: (self.rank[i] < self.rank[j])", "Line 30: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 47: (num in nums)", "Line 30: (self.id[u] != u)"], ["Line 30: (self.id[u] != u)", "Line 47: (num in nums)", "Line 30: (self.id[u] != u)", "Line 47: (num in nums)", "Line 30: (self.id[u] != u)"], ["Line 30: (self.id[u] != u)", "Line 30: (self.id[u] != u)", "Line 19: (i == j)", "Line 41: (num in nums)", "Line 42: (x in range(2, int(math.sqrt(num) + 1)))"], ["Line 42: (x in range(2, int(math.sqrt(num) + 1)))", "Line 43: (num % x == 0)", "Line 30: (self.id[u] != u)", "Line 30: (self.id[u] != u)", "Line 19: (i == j)"], ["Line 42: (x in range(2, int(math.sqrt(num) + 1)))", "Line 42: (x in range(2, int(math.sqrt(num) + 1)))", "Line 43: (num % x == 0)", "Line 30: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])"]]}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "difficulty": 2, "func_name": "minAreaFreeRect", "description": "You are given an array of points in the X-Y plane `points` where `points[i] =\n[xi, yi]`.\n\nReturn the minimum area of any rectangle formed from these points, with sides\nnot necessarily parallel to the X and Y axes. If there is not any such\nrectangle, return `0`.\n\nAnswers within `10-5` of the actual answer will be accepted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "blocks": [{"type": "if", "start": 28, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [29, 30, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      log_function('LOOP #1: Entered for loop at line 17-21\\n')\n      for bx, by in points:\n        log_function('LOOP #2: Entered for loop at line 18-21\\n')\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      log_function('LOOP #3: Entered for loop at line 25-32\\n')\n      for ax, ay, _, _ in points:\n        log_function('LOOP #4: Entered for loop at line 26-32\\n')\n        for cx, cy, dx, dy in points:\n          log_function('LOOP #5: Entered for loop at line 27-32\\n')\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            log_function('BRANCH #1: Covered if branch at line 28-31\\n')\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Area Rectangle II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #3: Entered for loop at line 25-32\n"], ["LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #1: Entered for loop at line 17-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n"], ["LOOP #5: Entered for loop at line 27-32\n", "BRANCH #1: Covered if branch at line 28-31\n", "LOOP #5: Entered for loop at line 27-32\n", "BRANCH #1: Covered if branch at line 28-31\n", "LOOP #3: Entered for loop at line 25-32\n"], ["LOOP #5: Entered for loop at line 27-32\n", "BRANCH #1: Covered if branch at line 28-31\n", "LOOP #3: Entered for loop at line 25-32\n", "LOOP #4: Entered for loop at line 26-32\n", "LOOP #5: Entered for loop at line 27-32\n"], ["LOOP #4: Entered for loop at line 26-32\n", "LOOP #5: Entered for loop at line 27-32\n", "BRANCH #1: Covered if branch at line 28-31\n", "LOOP #3: Entered for loop at line 25-32\n", "LOOP #4: Entered for loop at line 26-32\n"], ["LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #1: Entered for loop at line 17-21\n", "LOOP #2: Entered for loop at line 18-21\n"]], "sampled_condition_paths": [["Line 18: (bx, by in points)", "Line 18: (bx, by in points)", "Line 18: (bx, by in points)", "Line 18: (bx, by in points)", "Line 25: (points in centerToPoints.values())"], ["Line 18: (bx, by in points)", "Line 18: (bx, by in points)", "Line 17: (ax, ay in points)", "Line 18: (bx, by in points)", "Line 18: (bx, by in points)"], ["Line 27: (cx, cy, dx, dy in points)", "Line 28: ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0)", "Line 27: (cx, cy, dx, dy in points)", "Line 28: ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0)", "Line 25: (points in centerToPoints.values())"], ["Line 27: (cx, cy, dx, dy in points)", "Line 28: ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0)", "Line 25: (points in centerToPoints.values())", "Line 26: (ax, ay, _, _ in points)", "Line 27: (cx, cy, dx, dy in points)"], ["Line 26: (ax, ay, _, _ in points)", "Line 27: (cx, cy, dx, dy in points)", "Line 28: ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0)", "Line 25: (points in centerToPoints.values())", "Line 26: (ax, ay, _, _ in points)"], ["Line 18: (bx, by in points)", "Line 18: (bx, by in points)", "Line 18: (bx, by in points)", "Line 17: (ax, ay in points)", "Line 18: (bx, by in points)"]]}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "difficulty": 2, "func_name": "equationsPossible", "description": "You are given an array of strings `equations` that represent relationships\nbetween variables where each string `equations[i]` is of length `4` and takes\none of two different forms: `\"xi==yi\"` or `\"xi!=yi\"`.Here, `xi` and `yi` are\nlowercase letters (not necessarily different) that represent one-letter\nvariable names.\n\nReturn `true` if it is possible to assign integers to variable names so as to\nsatisfy all the given equations, or `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 1, "eg_cov_prob": 0.96}], "target_lines": [20, 30, 34, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      log_function('LOOP #1: Entered for loop at line 28-31\\n')\n      if op == '=':\n        log_function('BRANCH #2: Covered if branch at line 29-30\\n')\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      log_function('LOOP #2: Entered for loop at line 32-35\\n')\n      if op == '!':\n        log_function('BRANCH #3: Covered if branch at line 33-35\\n')\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          log_function('BRANCH #4: Covered if branch at line 34-35\\n')\n          return False\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Satisfiability of Equality Equations.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 32-35\n", "LOOP #2: Entered for loop at line 32-35\n", "BRANCH #3: Covered if branch at line 33-35\n", "BRANCH #1: Covered if branch at line 19-20\n"], ["BRANCH #2: Covered if branch at line 29-30\n", "LOOP #1: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 32-35\n", "LOOP #2: Entered for loop at line 32-35\n", "BRANCH #3: Covered if branch at line 33-35\n"], ["BRANCH #2: Covered if branch at line 29-30\n", "LOOP #1: Entered for loop at line 28-31\n", "BRANCH #2: Covered if branch at line 29-30\n", "BRANCH #1: Covered if branch at line 19-20\n", "LOOP #2: Entered for loop at line 32-35\n"]], "sampled_condition_paths": [["Line 28: (x, op, _, y in equations)", "Line 32: (x, op, _, y in equations)", "Line 32: (x, op, _, y in equations)", "Line 33: (op == '!')", "Line 19: (self.id[u] != u)"], ["Line 29: (op == '=')", "Line 28: (x, op, _, y in equations)", "Line 32: (x, op, _, y in equations)", "Line 32: (x, op, _, y in equations)", "Line 33: (op == '!')"], ["Line 29: (op == '=')", "Line 28: (x, op, _, y in equations)", "Line 29: (op == '=')", "Line 19: (self.id[u] != u)", "Line 32: (x, op, _, y in equations)"]]}
{"task_num": 999, "task_title": "Available Captures for Rook", "difficulty": 1, "func_name": "numRookCaptures", "description": "On an `8 x 8` chessboard, there is exactly one white rook `'R'` and some\nnumber of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east,\nsouth, or west), then moves in that direction until it chooses to stop,\nreaches the edge of the board, captures a black pawn, or is blocked by a white\nbishop. A rook is considered attacking a pawn if the rook can capture the pawn\non the rook's turn. The number of available captures for the white rook is the\nnumber of pawns that the rook is attacking.\n\nReturn the number of available captures for the white rook.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "blocks": [{"type": "if", "start": 17, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 1, "eg_cov_prob": 0.82}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [18, 19, 26, 28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      log_function('LOOP #1: Entered for loop at line 15-20\\n')\n      for j in range(8):\n        log_function('LOOP #2: Entered for loop at line 16-20\\n')\n        if board[i][j] == 'R':\n          log_function('BRANCH #1: Covered if branch at line 17-19\\n')\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      log_function('LOOP #3: Entered for loop at line 21-31\\n')\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        log_function('LOOP #4: Entered while loop at line 24-31\\n')\n        if board[i][j] == 'p':\n          log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n          ans += 1\n        if board[i][j] != '.':\n          log_function('BRANCH #3: Covered if branch at line 27-28\\n')\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Available Captures for Rook.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 15-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n"], ["LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n"], ["LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #1: Entered for loop at line 15-20\n", "LOOP #2: Entered for loop at line 16-20\n"], ["LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #1: Entered for loop at line 15-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n"], ["LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #2: Entered for loop at line 16-20\n", "LOOP #3: Entered for loop at line 21-31\n"]], "sampled_condition_paths": [["Line 15: (i in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))"], ["Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))"], ["Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 15: (i in range(8))", "Line 16: (j in range(8))"], ["Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 15: (i in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))"], ["Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 16: (j in range(8))", "Line 21: (d in [[1, 0], [0, 1], [-1, 0], [0, -1]])"]]}
{"task_num": 1001, "task_title": "Grid Illumination", "difficulty": 3, "func_name": "gridIllumination", "description": "There is a 2D `grid` of size `n x n` where each cell of this grid has a lamp\nthat is initially turned off.\n\nYou are given a 2D array of lamp positions `lamps`, where `lamps[i] = [rowi,\ncoli]` indicates that the lamp at `grid[rowi][coli]` is turned on. Even if the\nsame lamp is listed more than once, it is turned on.\n\nWhen a lamp is turned on, it illuminates its cell and all other cells in the\nsame row, column, or diagonal.\n\nYou are also given another 2D array `queries`, where `queries[j] = [rowj,\ncolj]`. For the `jth` query, determine whether `grid[rowj][colj]` is\nilluminated or not. After answering the `jth` query, turn off the lamp at\n`grid[rowj][colj]` and its 8 adjacent lamps if they exist. A lamp is adjacent\nif its cell shares either a side or corner with `grid[rowj][colj]`.\n\nReturn an array of integers `ans`, where `ans[j]` should be `1` if the cell in\nthe `jth` query was illuminated, or `0` if the lamp was not.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 24, 25, 26, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      log_function('LOOP #1: Entered for loop at line 20-27\\n')\n      if (i, j) not in lampsSet:\n        log_function('BRANCH #1: Covered if branch at line 21-26\\n')\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      log_function('LOOP #2: Entered for loop at line 28-41\\n')\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        log_function('BRANCH #2: Covered if branch at line 29-38\\n')\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          log_function('LOOP #3: Entered for loop at line 31-38\\n')\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            log_function('LOOP #4: Entered for loop at line 32-38\\n')\n            if (y, x) in lampsSet:\n              log_function('BRANCH #3: Covered if branch at line 33-38\\n')\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        log_function('BRANCH #4: Covered else branch at line 39-40\\n')\n        ans.append(0)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Grid Illumination.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 21-26\n", "LOOP #2: Entered for loop at line 28-41\n", "BRANCH #2: Covered if branch at line 29-38\n", "LOOP #3: Entered for loop at line 31-38\n", "LOOP #4: Entered for loop at line 32-38\n"], ["BRANCH #3: Covered if branch at line 33-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #3: Entered for loop at line 31-38\n", "LOOP #4: Entered for loop at line 32-38\n"], ["LOOP #3: Entered for loop at line 31-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #2: Entered for loop at line 28-41\n"], ["LOOP #4: Entered for loop at line 32-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #3: Entered for loop at line 31-38\n", "LOOP #4: Entered for loop at line 32-38\n"], ["BRANCH #3: Covered if branch at line 33-38\n", "LOOP #3: Entered for loop at line 31-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #2: Entered for loop at line 28-41\n"], ["LOOP #3: Entered for loop at line 31-38\n", "LOOP #4: Entered for loop at line 32-38\n", "BRANCH #3: Covered if branch at line 33-38\n", "LOOP #4: Entered for loop at line 32-38\n", "LOOP #4: Entered for loop at line 32-38\n"]], "sampled_condition_paths": [["Line 21: ((i, j) not in lampsSet)", "Line 28: (i, j in queries)", "Line 29: (rows[i] or cols[j] or diag1[i + j] or diag2[i - j])", "Line 31: (y in range(max(0, i - 1), min(n, i + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))"], ["Line 33: ((y, x) in lampsSet)", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 31: (y in range(max(0, i - 1), min(n, i + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))"], ["Line 31: (y in range(max(0, i - 1), min(n, i + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 28: (i, j in queries)"], ["Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 31: (y in range(max(0, i - 1), min(n, i + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))"], ["Line 33: ((y, x) in lampsSet)", "Line 31: (y in range(max(0, i - 1), min(n, i + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 28: (i, j in queries)"], ["Line 31: (y in range(max(0, i - 1), min(n, i + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 33: ((y, x) in lampsSet)", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))", "Line 32: (x in range(max(0, j - 1), min(n, j + 2)))"]]}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "difficulty": 2, "func_name": "sampleStats", "description": "You are given a large sample of integers in the range `[0, 255]`. Since the\nsample is so large, it is represented by an array `count` where `count[k]` is\nthe number of times that `k` appears in the sample.\n\nCalculate the following statistics:\n\n* `minimum`: The minimum element in the sample.\n* `maximum`: The maximum element in the sample.\n* `mean`: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.\n* `median`: \n* If the sample has an odd number of elements, then the `median` is the middle element once the sample is sorted.\n* If the sample has an even number of elements, then the `median` is the average of the two middle elements once the sample is sorted.\n* `mode`: The number that appears the most in the sample. It is guaranteed to be unique.\n\nReturn the statistics of the sample as an array of floating-point numbers\n`[minimum, maximum, mean, median, mode]`. Answers within `10-5` of the actual\nanswer will be accepted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "blocks": [{"type": "if", "start": 23, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 25, 32, 33], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      log_function('LOOP #1: Entered for loop at line 21-26\\n')\n      numCount += c\n      if numCount >= n / 2:\n        log_function('BRANCH #1: Covered if branch at line 23-25\\n')\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      log_function('LOOP #2: Entered for loop at line 29-34\\n')\n      numCount += c\n      if numCount >= n / 2:\n        log_function('BRANCH #2: Covered if branch at line 31-33\\n')\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n\ndef log_function(info_str):\n    with open(\"test_logs/Statistics from a Large Sample.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 29-34\n", "LOOP #2: Entered for loop at line 29-34\n", "LOOP #2: Entered for loop at line 29-34\n", "LOOP #2: Entered for loop at line 29-34\n", "LOOP #2: Entered for loop at line 29-34\n"]], "sampled_condition_paths": [["Line 29: (i, c in reversed(list(enumerate(count))))", "Line 29: (i, c in reversed(list(enumerate(count))))", "Line 29: (i, c in reversed(list(enumerate(count))))", "Line 29: (i, c in reversed(list(enumerate(count))))", "Line 29: (i, c in reversed(list(enumerate(count))))"]]}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "difficulty": 2, "func_name": "shortestAlternatingPaths", "description": "You are given an integer `n`, the number of nodes in a directed graph where\nthe nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this\ngraph, and there could be self-edges and parallel edges.\n\nYou are given two arrays `redEdges` and `blueEdges` where:\n\n* `redEdges[i] = [ai, bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph, and\n* `blueEdges[j] = [uj, vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.\n\nReturn an array `answer` of length `n`, where each `answer[x]` is the length\nof the shortest path from node `0` to node `x` such that the edge colors\nalternate along the path, or `-1` if such a path does not exist.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.97}], "target_lines": [37, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      log_function('LOOP #1: Entered for loop at line 26-28\\n')\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      log_function('LOOP #2: Entered for loop at line 29-31\\n')\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      log_function('LOOP #3: Entered while loop at line 33-44\\n')\n      for _ in range(len(q)):\n        log_function('LOOP #4: Entered for loop at line 34-42\\n')\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          log_function('BRANCH #1: Covered if branch at line 36-37\\n')\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          log_function('LOOP #5: Entered for loop at line 38-42\\n')\n          if v == -1 or edgeColor == prevColor:\n            log_function('BRANCH #2: Covered if branch at line 39-40\\n')\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Shortest Path with Alternating Colors.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 29-31\n", "LOOP #3: Entered while loop at line 33-44\n", "LOOP #4: Entered for loop at line 34-42\n", "BRANCH #1: Covered if branch at line 36-37\n", "LOOP #5: Entered for loop at line 38-42\n"], ["LOOP #1: Entered for loop at line 26-28\n", "LOOP #3: Entered while loop at line 33-44\n", "LOOP #4: Entered for loop at line 34-42\n", "BRANCH #1: Covered if branch at line 36-37\n", "LOOP #5: Entered for loop at line 38-42\n"], ["LOOP #3: Entered while loop at line 33-44\n", "LOOP #4: Entered for loop at line 34-42\n", "BRANCH #1: Covered if branch at line 36-37\n", "LOOP #5: Entered for loop at line 38-42\n", "LOOP #3: Entered while loop at line 33-44\n"]], "sampled_condition_paths": [["Line 29: (u, v in blueEdges)", "Line 33: (q)", "Line 34: (_ in range(len(q)))", "Line 36: (ans[u] == -1)", "Line 38: (i, (v, edgeColor) in enumerate(graph[u]))"], ["Line 26: (u, v in redEdges)", "Line 33: (q)", "Line 34: (_ in range(len(q)))", "Line 36: (ans[u] == -1)", "Line 38: (i, (v, edgeColor) in enumerate(graph[u]))"], ["Line 33: (q)", "Line 34: (_ in range(len(q)))", "Line 36: (ans[u] == -1)", "Line 38: (i, (v, edgeColor) in enumerate(graph[u]))", "Line 33: (q)"]]}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "difficulty": 2, "func_name": "largest1BorderedSquare", "description": "Given a 2D `grid` of `0`s and `1`s, return the number of elements in the\nlargest square subgrid that has all `1`s on its border, or `0` if such a\nsubgrid doesn't exist in the `grid`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "blocks": [{"type": "if", "start": 21, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "else", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 25, 26, 27, 29, 37], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 19-30\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-30\\n')\n        if grid[i][j] == 1:\n          log_function('BRANCH #1: Covered if branch at line 21-29\\n')\n          if j==0:\n            log_function('BRANCH #2: Covered if branch at line 22-23\\n')\n            leftOnes[i][j]=1\n          else:\n            log_function('BRANCH #3: Covered else branch at line 24-25\\n')\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            log_function('BRANCH #4: Covered if branch at line 26-27\\n')\n            topOnes[i][j]=1\n          else:\n            log_function('BRANCH #5: Covered else branch at line 28-29\\n')\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      log_function('LOOP #3: Entered for loop at line 31-38\\n')\n      for i in range(m - sz + 1):\n        log_function('LOOP #4: Entered for loop at line 32-38\\n')\n        for j in range(n - sz + 1):\n          log_function('LOOP #5: Entered for loop at line 33-38\\n')\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            log_function('BRANCH #6: Covered if branch at line 36-37\\n')\n            return sz * sz\n\n    return 0\n\ndef log_function(info_str):\n    with open(\"test_logs/Largest 1-Bordered Square.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 20-30\n", "BRANCH #1: Covered if branch at line 21-29\n", "BRANCH #3: Covered else branch at line 24-25\n", "BRANCH #5: Covered else branch at line 28-29\n", "LOOP #3: Entered for loop at line 31-38\n"], ["BRANCH #5: Covered else branch at line 28-29\n", "LOOP #2: Entered for loop at line 20-30\n", "BRANCH #1: Covered if branch at line 21-29\n", "BRANCH #3: Covered else branch at line 24-25\n", "BRANCH #5: Covered else branch at line 28-29\n"], ["BRANCH #2: Covered if branch at line 22-23\n", "BRANCH #4: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 20-30\n", "BRANCH #1: Covered if branch at line 21-29\n", "BRANCH #3: Covered else branch at line 24-25\n"], ["BRANCH #3: Covered else branch at line 24-25\n", "BRANCH #4: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 20-30\n", "LOOP #2: Entered for loop at line 20-30\n", "LOOP #3: Entered for loop at line 31-38\n"]], "sampled_condition_paths": [["Line 20: (j in range(n))", "Line 21: (grid[i][j] == 1)", "Line 22: NOT (j==0)", "Line 24: ", "Line 26: NOT (i==0)", "Line 28: ", "Line 31: (sz in range(min(m, n), 0, -1))"], ["Line 26: NOT (i==0)", "Line 28: ", "Line 20: (j in range(n))", "Line 21: (grid[i][j] == 1)", "Line 22: NOT (j==0)", "Line 24: ", "Line 26: NOT (i==0)", "Line 28: "], ["Line 22: (j==0)", "Line 26: (i==0)", "Line 20: (j in range(n))", "Line 21: (grid[i][j] == 1)", "Line 22: NOT (j==0)", "Line 24: "], ["Line 22: NOT (j==0)", "Line 24: ", "Line 26: (i==0)", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 31: (sz in range(min(m, n), 0, -1))"]]}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "difficulty": 2, "func_name": "maxDistance", "description": "Given an `n x n` `grid` containing only values `0` and `1`, where `0`\nrepresents water and `1` represents land, find a water cell such that its\ndistance to the nearest land cell is maximized, and return the distance. If no\nland or water exists in the grid, return `-1`.\n\nThe distance used in this problem is the Manhattan distance: the distance\nbetween two cells `(x0, y0)` and `(x1, y1)` is `|x0 - x1| + |y0 - y1|`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.02}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 41, "end": 42, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [22, 24, 27, 40, 42], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 19-25\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-25\\n')\n        if grid[i][j] == 0:\n          log_function('BRANCH #1: Covered if branch at line 21-22\\n')\n          water += 1\n        else:\n          log_function('BRANCH #2: Covered else branch at line 23-24\\n')\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      log_function('BRANCH #3: Covered if branch at line 26-27\\n')\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      log_function('LOOP #3: Entered while loop at line 32-46\\n')\n      for _ in range(len(q)):\n        log_function('LOOP #4: Entered for loop at line 33-44\\n')\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          log_function('LOOP #5: Entered for loop at line 36-44\\n')\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            log_function('BRANCH #4: Covered if branch at line 39-40\\n')\n            continue\n          if grid[x][y] > 0:\n            log_function('BRANCH #5: Covered if branch at line 41-42\\n')\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/As Far from Land as Possible.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 33-44\n", "LOOP #5: Entered for loop at line 36-44\n", "LOOP #5: Entered for loop at line 36-44\n", "LOOP #5: Entered for loop at line 36-44\n", "BRANCH #4: Covered if branch at line 39-40\n"], ["BRANCH #4: Covered if branch at line 39-40\n", "LOOP #3: Entered while loop at line 32-46\n", "LOOP #4: Entered for loop at line 33-44\n", "LOOP #5: Entered for loop at line 36-44\n", "LOOP #5: Entered for loop at line 36-44\n"], ["LOOP #2: Entered for loop at line 20-25\n", "BRANCH #1: Covered if branch at line 21-22\n", "LOOP #2: Entered for loop at line 20-25\n", "BRANCH #1: Covered if branch at line 21-22\n", "LOOP #2: Entered for loop at line 20-25\n"], ["LOOP #5: Entered for loop at line 36-44\n", "BRANCH #4: Covered if branch at line 39-40\n", "LOOP #4: Entered for loop at line 33-44\n", "LOOP #5: Entered for loop at line 36-44\n", "BRANCH #5: Covered if branch at line 41-42\n"]], "sampled_condition_paths": [["Line 33: (_ in range(len(q)))", "Line 36: (dx, dy in dirs)", "Line 36: (dx, dy in dirs)", "Line 36: (dx, dy in dirs)", "Line 39: (x < 0 or x == m or y < 0 or y == n)"], ["Line 39: (x < 0 or x == m or y < 0 or y == n)", "Line 32: (q)", "Line 33: (_ in range(len(q)))", "Line 36: (dx, dy in dirs)", "Line 36: (dx, dy in dirs)"], ["Line 20: (j in range(n))", "Line 21: (grid[i][j] == 0)", "Line 20: (j in range(n))", "Line 21: (grid[i][j] == 0)", "Line 20: (j in range(n))"], ["Line 36: (dx, dy in dirs)", "Line 39: (x < 0 or x == m or y < 0 or y == n)", "Line 33: (_ in range(len(q)))", "Line 36: (dx, dy in dirs)", "Line 41: (grid[x][y] > 0)"]]}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "difficulty": 2, "func_name": "smallestStringWithSwaps", "description": "You are given a string `s`, and an array of pairs of indices in the string\n`pairs` where `pairs[i] = [a, b]` indicates 2 indices(0-indexed) of the\nstring.\n\nYou can swap the characters at any pair of indices in the given `pairs` any\nnumber of times.\n\nReturn the lexicographically smallest string that `s` can be changed to after\nusing the swaps.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.91}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 30-31\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      log_function('LOOP #1: Entered for loop at line 41-43\\n')\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      log_function('LOOP #2: Entered for loop at line 44-46\\n')\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      log_function('LOOP #3: Entered for loop at line 47-49\\n')\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      log_function('LOOP #4: Entered for loop at line 50-52\\n')\n      ans += map[uf.find(i)].pop()\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Smallest String With Swaps.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #5: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 44-46\n", "BRANCH #5: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 44-46\n", "LOOP #2: Entered for loop at line 44-46\n"], ["BRANCH #5: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 47-49\n", "LOOP #4: Entered for loop at line 50-52\n", "BRANCH #5: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 50-52\n"], ["BRANCH #5: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 44-46\n", "LOOP #2: Entered for loop at line 44-46\n", "LOOP #3: Entered for loop at line 47-49\n", "LOOP #3: Entered for loop at line 47-49\n"], ["BRANCH #5: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 44-46\n", "LOOP #2: Entered for loop at line 44-46\n", "BRANCH #5: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 47-49\n"], ["LOOP #2: Entered for loop at line 44-46\n", "BRANCH #5: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 47-49\n", "LOOP #4: Entered for loop at line 50-52\n", "BRANCH #5: Covered if branch at line 30-31\n"], ["BRANCH #4: Covered else branch at line 25-27\n", "LOOP #1: Entered for loop at line 41-43\n", "BRANCH #4: Covered else branch at line 25-27\n", "LOOP #1: Entered for loop at line 41-43\n", "BRANCH #5: Covered if branch at line 30-31\n"]], "sampled_condition_paths": [["Line 30: (self.id[u] != u)", "Line 44: (i, c in enumerate(s))", "Line 30: (self.id[u] != u)", "Line 44: (i, c in enumerate(s))", "Line 44: (i, c in enumerate(s))"], ["Line 30: (self.id[u] != u)", "Line 47: (key in map.keys())", "Line 50: (i in range(len(s)))", "Line 30: (self.id[u] != u)", "Line 50: (i in range(len(s)))"], ["Line 30: (self.id[u] != u)", "Line 44: (i, c in enumerate(s))", "Line 44: (i, c in enumerate(s))", "Line 47: (key in map.keys())", "Line 47: (key in map.keys())"], ["Line 30: (self.id[u] != u)", "Line 44: (i, c in enumerate(s))", "Line 44: (i, c in enumerate(s))", "Line 30: (self.id[u] != u)", "Line 47: (key in map.keys())"], ["Line 44: (i, c in enumerate(s))", "Line 30: (self.id[u] != u)", "Line 47: (key in map.keys())", "Line 50: (i in range(len(s)))", "Line 30: (self.id[u] != u)"], ["Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 41: (a, b in pairs)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 41: (a, b in pairs)", "Line 30: (self.id[u] != u)"]]}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "difficulty": 3, "func_name": "minimumMoves", "description": "In an `n*n` grid, there is a snake that spans 2 cells and starts moving from\nthe top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells\nrepresented by zeros and blocked cells represented by ones. The snake wants to\nreach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.\n\nIn one move the snake can:\n\n* Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n* Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n* Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.  \n\n* Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.  \n\nReturn the minimum number of moves to reach the target.\n\nIf there is no way to reach the target, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "blocks": [{"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.44}, {"type": "if", "start": 48, "end": 49, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 50, "end": 52, "difficulty": 1, "eg_cov_prob": 0.62}, {"type": "if", "start": 53, "end": 55, "difficulty": 1, "eg_cov_prob": 0.44}, {"type": "if", "start": 57, "end": 59, "difficulty": 1, "eg_cov_prob": 0.44}], "target_lines": [29, 34, 49, 51, 52, 54, 55, 58, 59], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        log_function('BRANCH #1: Covered if branch at line 28-29\\n')\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        log_function('BRANCH #2: Covered if branch at line 33-34\\n')\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      log_function('LOOP #1: Entered while loop at line 45-61\\n')\n      for _ in range(len(q)):\n        log_function('LOOP #2: Entered for loop at line 46-59\\n')\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          log_function('BRANCH #3: Covered if branch at line 48-49\\n')\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          log_function('BRANCH #4: Covered if branch at line 50-52\\n')\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          log_function('BRANCH #5: Covered if branch at line 53-55\\n')\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          log_function('BRANCH #6: Covered if branch at line 57-59\\n')\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Moves to Reach Target with Rotations.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 46-59\n", "BRANCH #4: Covered if branch at line 50-52\n", "BRANCH #2: Covered if branch at line 33-34\n", "BRANCH #6: Covered if branch at line 57-59\n", "LOOP #1: Entered while loop at line 45-61\n"], ["LOOP #2: Entered for loop at line 46-59\n", "BRANCH #2: Covered if branch at line 33-34\n", "LOOP #1: Entered while loop at line 45-61\n", "LOOP #2: Entered for loop at line 46-59\n", "BRANCH #3: Covered if branch at line 48-49\n"], ["BRANCH #1: Covered if branch at line 28-29\n", "BRANCH #5: Covered if branch at line 53-55\n", "BRANCH #6: Covered if branch at line 57-59\n", "LOOP #2: Entered for loop at line 46-59\n", "BRANCH #4: Covered if branch at line 50-52\n"], ["BRANCH #4: Covered if branch at line 50-52\n", "BRANCH #2: Covered if branch at line 33-34\n", "LOOP #2: Entered for loop at line 46-59\n", "BRANCH #2: Covered if branch at line 33-34\n", "LOOP #1: Entered while loop at line 45-61\n"]], "sampled_condition_paths": [["Line 46: (_ in range(len(q)))", "Line 50: (canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen)", "Line 33: (pos == Pos.kVertical)", "Line 57: ((canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen)", "Line 45: (q)"], ["Line 46: (_ in range(len(q)))", "Line 33: (pos == Pos.kVertical)", "Line 45: (q)", "Line 46: (_ in range(len(q)))", "Line 48: (x == n - 1 and y == n - 2 and pos == Pos.kHorizontal)"], ["Line 28: (pos == Pos.kHorizontal)", "Line 53: (canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen)", "Line 57: ((canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen)", "Line 46: (_ in range(len(q)))", "Line 50: (canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen)"], ["Line 50: (canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen)", "Line 33: (pos == Pos.kVertical)", "Line 46: (_ in range(len(q)))", "Line 33: (pos == Pos.kVertical)", "Line 45: (q)"]]}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "difficulty": 2, "func_name": "reconstructMatrix", "description": "Given the following details of a matrix with `n` columns and `2` rows :\n\n* The matrix is a binary matrix, which means each element in the matrix can be `0` or `1`.\n* The sum of elements of the 0-th(upper) row is given as `upper`.\n* The sum of elements of the 1-st(lower) row is given as `lower`.\n* The sum of elements in the i-th column(0-indexed) is `colsum[i]`, where `colsum` is given as an integer array with length `n`.\n\nYour task is to reconstruct the matrix with `upper`, `lower` and `colsum`.\n\nReturn it as a 2-D integer array.\n\nIf there are more than one valid solution, any of them will be accepted.\n\nIf no valid solution exists, return an empty 2-D array.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 15, "end": 16, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 21, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 31, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 16, 22, 23, 24, 25, 29, 30, 31, 33, 34], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return []\n    if min(upper, lower) < colsum.count(2):\n      log_function('BRANCH #2: Covered if branch at line 15-16\\n')\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      log_function('LOOP #1: Entered for loop at line 20-26\\n')\n      if c == 2:\n        log_function('BRANCH #3: Covered if branch at line 21-25\\n')\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      log_function('LOOP #2: Entered for loop at line 27-35\\n')\n      if c == 1 and upper > 0:\n        log_function('BRANCH #4: Covered if branch at line 28-31\\n')\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        log_function('BRANCH #5: Covered if branch at line 32-34\\n')\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Reconstruct a 2-Row Binary Matrix.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 21-25\n", "LOOP #1: Entered for loop at line 20-26\n", "LOOP #1: Entered for loop at line 20-26\n", "LOOP #2: Entered for loop at line 27-35\n", "LOOP #2: Entered for loop at line 27-35\n"], ["BRANCH #4: Covered if branch at line 28-31\n", "LOOP #2: Entered for loop at line 27-35\n", "BRANCH #4: Covered if branch at line 28-31\n", "LOOP #2: Entered for loop at line 27-35\n", "BRANCH #5: Covered if branch at line 32-34\n"], ["LOOP #1: Entered for loop at line 20-26\n", "LOOP #2: Entered for loop at line 27-35\n", "BRANCH #4: Covered if branch at line 28-31\n", "LOOP #2: Entered for loop at line 27-35\n", "BRANCH #4: Covered if branch at line 28-31\n"], ["LOOP #1: Entered for loop at line 20-26\n", "LOOP #1: Entered for loop at line 20-26\n", "LOOP #1: Entered for loop at line 20-26\n", "BRANCH #3: Covered if branch at line 21-25\n", "LOOP #1: Entered for loop at line 20-26\n"], ["BRANCH #1: Covered if branch at line 13-14\n"]], "sampled_condition_paths": [["Line 21: (c == 2)", "Line 20: (j, c in enumerate(colsum))", "Line 20: (j, c in enumerate(colsum))", "Line 27: (j, c in enumerate(colsum))", "Line 27: (j, c in enumerate(colsum))"], ["Line 28: (c == 1 and upper > 0)", "Line 27: (j, c in enumerate(colsum))", "Line 28: (c == 1 and upper > 0)", "Line 27: (j, c in enumerate(colsum))", "Line 32: (c == 1 and lower > 0)"], ["Line 20: (j, c in enumerate(colsum))", "Line 27: (j, c in enumerate(colsum))", "Line 28: (c == 1 and upper > 0)", "Line 27: (j, c in enumerate(colsum))", "Line 28: (c == 1 and upper > 0)"], ["Line 20: (j, c in enumerate(colsum))", "Line 20: (j, c in enumerate(colsum))", "Line 20: (j, c in enumerate(colsum))", "Line 21: (c == 2)", "Line 20: (j, c in enumerate(colsum))"], ["Line 13: (upper + lower != sum(colsum))"]]}
{"task_num": 1254, "task_title": "Number of Closed Islands", "difficulty": 2, "func_name": "closedIsland", "description": "Given a 2D `grid` consists of `0s` (land) and `1s` (water). An island is a\nmaximal 4-directionally connected group of `0s` and a closed island is an\nisland totally (all left, top, right, bottom) surrounded by `1s.`\n\nReturn the number of closed islands.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 17, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 40, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [18, 20, 31, 32, 39, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        log_function('BRANCH #1: Covered if branch at line 17-18\\n')\n        return\n      if grid[i][j] == 1:\n        log_function('BRANCH #2: Covered if branch at line 19-20\\n')\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 28-33\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 29-33\\n')\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          log_function('BRANCH #3: Covered if branch at line 30-32\\n')\n          if grid[i][j] == 0:\n            log_function('BRANCH #4: Covered if branch at line 31-32\\n')\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      log_function('LOOP #3: Entered for loop at line 36-41\\n')\n      for j in range(n):\n        log_function('LOOP #4: Entered for loop at line 37-41\\n')\n        if grid[i][j] == 0:\n          log_function('BRANCH #5: Covered if branch at line 38-40\\n')\n          dfs(i, j)\n          ans += 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Closed Islands.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 30-32\n", "BRANCH #4: Covered if branch at line 31-32\n", "BRANCH #2: Covered if branch at line 19-20\n", "BRANCH #2: Covered if branch at line 19-20\n", "BRANCH #1: Covered if branch at line 17-18\n"], ["LOOP #4: Entered for loop at line 37-41\n", "LOOP #4: Entered for loop at line 37-41\n", "LOOP #4: Entered for loop at line 37-41\n", "LOOP #4: Entered for loop at line 37-41\n", "LOOP #4: Entered for loop at line 37-41\n"], ["BRANCH #1: Covered if branch at line 17-18\n", "BRANCH #2: Covered if branch at line 19-20\n", "BRANCH #2: Covered if branch at line 19-20\n", "BRANCH #1: Covered if branch at line 17-18\n", "BRANCH #2: Covered if branch at line 19-20\n"], ["BRANCH #2: Covered if branch at line 19-20\n", "BRANCH #2: Covered if branch at line 19-20\n", "BRANCH #1: Covered if branch at line 17-18\n", "BRANCH #1: Covered if branch at line 17-18\n", "BRANCH #2: Covered if branch at line 19-20\n"], ["BRANCH #2: Covered if branch at line 19-20\n", "BRANCH #2: Covered if branch at line 19-20\n", "LOOP #4: Entered for loop at line 37-41\n", "LOOP #4: Entered for loop at line 37-41\n", "LOOP #4: Entered for loop at line 37-41\n"], ["BRANCH #1: Covered if branch at line 17-18\n", "BRANCH #2: Covered if branch at line 19-20\n", "LOOP #3: Entered for loop at line 36-41\n", "LOOP #4: Entered for loop at line 37-41\n", "LOOP #4: Entered for loop at line 37-41\n"]], "sampled_condition_paths": [["Line 30: (i * j == 0 or i == m - 1 or j == n - 1)", "Line 31: (grid[i][j] == 0)", "Line 19: (grid[i][j] == 1)", "Line 19: (grid[i][j] == 1)", "Line 17: (i < 0 or i == m or j < 0 or j == n)"], ["Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))"], ["Line 17: (i < 0 or i == m or j < 0 or j == n)", "Line 19: (grid[i][j] == 1)", "Line 19: (grid[i][j] == 1)", "Line 17: (i < 0 or i == m or j < 0 or j == n)", "Line 19: (grid[i][j] == 1)"], ["Line 19: (grid[i][j] == 1)", "Line 19: (grid[i][j] == 1)", "Line 17: (i < 0 or i == m or j < 0 or j == n)", "Line 17: (i < 0 or i == m or j < 0 or j == n)", "Line 19: (grid[i][j] == 1)"], ["Line 19: (grid[i][j] == 1)", "Line 19: (grid[i][j] == 1)", "Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))"], ["Line 17: (i < 0 or i == m or j < 0 or j == n)", "Line 19: (grid[i][j] == 1)", "Line 36: (i in range(m))", "Line 37: (j in range(n))", "Line 37: (j in range(n))"]]}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "difficulty": 3, "func_name": "minPushBox", "description": "A storekeeper is a game in which the player pushes boxes around in a warehouse\ntrying to get them to target locations.\n\nThe game is represented by an `m x n` grid of characters `grid` where each\nelement is a wall, floor, or box.\n\nYour task is to move the box `'B'` to the target position `'T'` under the\nfollowing rules:\n\n* The character `'S'` represents the player. The player can move up, down, left, right in `grid` if it is a floor (empty cell).\n* The character `'.'` represents the floor which means a free cell to walk.\n* The character `'#'` represents the wall which means an obstacle (impossible to walk there).\n* There is only one box `'B'` and one target cell `'T'` in the `grid`.\n* The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.\n* The player cannot walk through the box.\n\nReturn the minimum number of pushes to move the box to the target. If there is\nno way to reach the target, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "blocks": [{"type": "if", "start": 44, "end": 45, "difficulty": 2, "eg_cov_prob": 0.16}, {"type": "if", "start": 16, "end": 17, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.35}, {"type": "if", "start": 51, "end": 54, "difficulty": 1, "eg_cov_prob": 0.82}, {"type": "if", "start": 35, "end": 37, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 52, "end": 54, "difficulty": 2, "eg_cov_prob": 0.35}], "target_lines": [17, 19, 21, 32, 36, 37, 45, 52, 53, 54], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      log_function('LOOP #1: Entered for loop at line 14-22\\n')\n      for j in range(len(grid[0])):\n        log_function('LOOP #2: Entered for loop at line 15-22\\n')\n        if grid[i][j] == \"T\":\n          log_function('BRANCH #1: Covered if branch at line 16-17\\n')\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          log_function('BRANCH #2: Covered if branch at line 18-19\\n')\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          log_function('BRANCH #3: Covered if branch at line 20-21\\n')\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        log_function('LOOP #3: Entered while loop at line 29-37\\n')\n        pos = que.popleft()\n        if pos == dest: \n          log_function('BRANCH #4: Covered if branch at line 31-32\\n')\n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          log_function('LOOP #4: Entered for loop at line 34-37\\n')\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            log_function('BRANCH #5: Covered if branch at line 35-37\\n')\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      log_function('LOOP #5: Entered while loop at line 42-55\\n')\n      dist, box, person = q.popleft()\n      if box == target:\n        log_function('BRANCH #6: Covered if branch at line 44-45\\n')\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        log_function('LOOP #6: Entered for loop at line 50-55\\n')\n        if valid(*new_box) and new_box+box not in vis:\n          log_function('BRANCH #7: Covered if branch at line 51-54\\n')\n          if valid(*new_person) and check(person,new_person,box):\n            log_function('BRANCH #8: Covered if branch at line 52-54\\n')\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Moves to Move a Box to Their Target Location.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 15-22\n", "LOOP #2: Entered for loop at line 15-22\n", "LOOP #1: Entered for loop at line 14-22\n", "LOOP #2: Entered for loop at line 15-22\n", "LOOP #2: Entered for loop at line 15-22\n"], ["LOOP #1: Entered for loop at line 14-22\n", "LOOP #2: Entered for loop at line 15-22\n", "LOOP #2: Entered for loop at line 15-22\n", "LOOP #2: Entered for loop at line 15-22\n", "LOOP #2: Entered for loop at line 15-22\n"]], "sampled_condition_paths": [["Line 15: (j in range(len(grid[0])))", "Line 15: (j in range(len(grid[0])))", "Line 14: (i in range(len(grid)))", "Line 15: (j in range(len(grid[0])))", "Line 15: (j in range(len(grid[0])))"], ["Line 14: (i in range(len(grid)))", "Line 15: (j in range(len(grid[0])))", "Line 15: (j in range(len(grid[0])))", "Line 15: (j in range(len(grid[0])))", "Line 15: (j in range(len(grid[0])))"]]}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "difficulty": 2, "func_name": "countServers", "description": "You are given a map of a server center, represented as a `m * n` integer\nmatrix `grid`, where 1 means that on that cell there is a server and 0 means\nthat it is no server. Two servers are said to communicate if they are on the\nsame row or on the same column.  \n\nReturn the number of servers that communicate with any other server.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 19-24\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-24\\n')\n        if grid[i][j] == 1:\n          log_function('BRANCH #1: Covered if branch at line 21-23\\n')\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      log_function('LOOP #3: Entered for loop at line 25-29\\n')\n      for j in range(n):\n        log_function('LOOP #4: Entered for loop at line 26-29\\n')\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          log_function('BRANCH #2: Covered if branch at line 27-28\\n')\n          ans += 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Servers that Communicate.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 21-23\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #1: Entered for loop at line 19-24\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #2: Entered for loop at line 20-24\n"], ["BRANCH #1: Covered if branch at line 21-23\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #1: Entered for loop at line 19-24\n", "LOOP #2: Entered for loop at line 20-24\n"], ["LOOP #4: Entered for loop at line 26-29\n", "LOOP #4: Entered for loop at line 26-29\n", "LOOP #3: Entered for loop at line 25-29\n", "LOOP #4: Entered for loop at line 26-29\n", "LOOP #4: Entered for loop at line 26-29\n"], ["LOOP #4: Entered for loop at line 26-29\n", "BRANCH #2: Covered if branch at line 27-28\n", "LOOP #4: Entered for loop at line 26-29\n", "LOOP #3: Entered for loop at line 25-29\n", "LOOP #4: Entered for loop at line 26-29\n"], ["BRANCH #1: Covered if branch at line 21-23\n", "LOOP #3: Entered for loop at line 25-29\n", "LOOP #4: Entered for loop at line 26-29\n", "BRANCH #2: Covered if branch at line 27-28\n", "LOOP #4: Entered for loop at line 26-29\n"]], "sampled_condition_paths": [["Line 21: (grid[i][j] == 1)", "Line 20: (j in range(n))", "Line 19: (i in range(m))", "Line 20: (j in range(n))", "Line 20: (j in range(n))"], ["Line 21: (grid[i][j] == 1)", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 19: (i in range(m))", "Line 20: (j in range(n))"], ["Line 26: (j in range(n))", "Line 26: (j in range(n))", "Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 26: (j in range(n))"], ["Line 26: (j in range(n))", "Line 27: (grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1))", "Line 26: (j in range(n))", "Line 25: (i in range(m))", "Line 26: (j in range(n))"], ["Line 21: (grid[i][j] == 1)", "Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 27: (grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1))", "Line 26: (j in range(n))"]]}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "difficulty": 3, "func_name": "minFlips", "description": "Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and\nflip it and all the four neighbors of it if they exist (Flip is changing `1`\nto `0` and `0` to `1`). A pair of cells are called neighbors if they share one\nedge.\n\nReturn the minimum number of steps required to convert `mat` to a zero matrix\nor `-1` if you cannot.\n\nA binary matrix is a matrix with all cells equal to `0` or `1` only.\n\nA zero matrix is a matrix with all cells equal to `0`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.09}, {"type": "if", "start": 50, "end": 51, "difficulty": 1, "eg_cov_prob": 0.91}, {"type": "if", "start": 37, "end": 38, "difficulty": 1, "eg_cov_prob": 0.64}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.61}, {"type": "if", "start": 34, "end": 35, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [17, 35, 38, 40, 51], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      log_function('BRANCH #1: Covered if branch at line 16-17\\n')\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      log_function('LOOP #1: Entered while loop at line 24-43\\n')\n      step += 1\n      for _ in range(len(q)):\n        log_function('LOOP #2: Entered for loop at line 26-43\\n')\n        curr = q.popleft()\n        for i in range(m):\n          log_function('LOOP #3: Entered for loop at line 28-43\\n')\n          for j in range(n):\n            log_function('LOOP #4: Entered for loop at line 29-43\\n')\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              log_function('LOOP #5: Entered for loop at line 31-36\\n')\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                log_function('BRANCH #2: Covered if branch at line 34-35\\n')\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              log_function('BRANCH #3: Covered if branch at line 37-38\\n')\n              return step\n            if next in seen:\n              log_function('BRANCH #4: Covered if branch at line 39-40\\n')\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      log_function('LOOP #6: Entered for loop at line 48-51\\n')\n      for j in range(n):\n        log_function('LOOP #7: Entered for loop at line 49-51\\n')\n        if mat[i][j]:\n          log_function('BRANCH #5: Covered if branch at line 50-51\\n')\n          hash |= 1 << (i * n + j)\n    return hash\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Number of Flips to Convert Binary Matrix to Zero Matrix.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 34-35\n", "LOOP #5: Entered for loop at line 31-36\n", "LOOP #4: Entered for loop at line 29-43\n", "LOOP #5: Entered for loop at line 31-36\n", "BRANCH #2: Covered if branch at line 34-35\n"], ["BRANCH #2: Covered if branch at line 34-35\n", "LOOP #5: Entered for loop at line 31-36\n", "LOOP #5: Entered for loop at line 31-36\n", "LOOP #1: Entered while loop at line 24-43\n", "LOOP #2: Entered for loop at line 26-43\n"], ["LOOP #5: Entered for loop at line 31-36\n", "BRANCH #2: Covered if branch at line 34-35\n", "LOOP #5: Entered for loop at line 31-36\n", "LOOP #4: Entered for loop at line 29-43\n", "LOOP #5: Entered for loop at line 31-36\n"], ["LOOP #6: Entered for loop at line 48-51\n", "LOOP #7: Entered for loop at line 49-51\n", "BRANCH #1: Covered if branch at line 16-17\n"], ["BRANCH #4: Covered if branch at line 39-40\n", "LOOP #4: Entered for loop at line 29-43\n", "LOOP #5: Entered for loop at line 31-36\n", "LOOP #5: Entered for loop at line 31-36\n", "BRANCH #2: Covered if branch at line 34-35\n"]], "sampled_condition_paths": [["Line 34: (x < 0 or x == m or y < 0 or y == n)", "Line 31: (dx, dy in dirs)", "Line 29: (j in range(n))", "Line 31: (dx, dy in dirs)", "Line 34: (x < 0 or x == m or y < 0 or y == n)"], ["Line 34: (x < 0 or x == m or y < 0 or y == n)", "Line 31: (dx, dy in dirs)", "Line 31: (dx, dy in dirs)", "Line 24: (q)", "Line 26: (_ in range(len(q)))"], ["Line 31: (dx, dy in dirs)", "Line 34: (x < 0 or x == m or y < 0 or y == n)", "Line 31: (dx, dy in dirs)", "Line 29: (j in range(n))", "Line 31: (dx, dy in dirs)"], ["Line 48: (i in range(m))", "Line 49: (j in range(n))", "Line 16: (hash == 0)"], ["Line 39: (next in seen)", "Line 29: (j in range(n))", "Line 31: (dx, dy in dirs)", "Line 31: (dx, dy in dirs)", "Line 34: (x < 0 or x == m or y < 0 or y == n)"]]}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "difficulty": 3, "func_name": "shortestPath", "description": "You are given an `m x n` integer matrix `grid` where each cell is either `0`\n(empty) or `1` (obstacle). You can move up, down, left, or right from and to\nan empty cell in one step.\n\nReturn the minimum number of steps to walk from the upper left corner `(0, 0)`\nto the lower right corner `(m - 1, n - 1)` given that you can eliminate at\nmost `k` obstacles. If it is not possible to find such walk return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 2, "eg_cov_prob": 0.01}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 32, "end": 33, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.13}, {"type": "if", "start": 37, "end": 38, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [16, 31, 33, 35, 38], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      log_function('BRANCH #1: Covered if branch at line 15-16\\n')\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      log_function('LOOP #1: Entered while loop at line 23-41\\n')\n      steps += 1\n      for _ in range(len(q)):\n        log_function('LOOP #2: Entered for loop at line 25-41\\n')\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          log_function('LOOP #3: Entered for loop at line 27-41\\n')\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n            continue\n          if x == m - 1 and y == n - 1:\n            log_function('BRANCH #3: Covered if branch at line 32-33\\n')\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            log_function('BRANCH #4: Covered if branch at line 34-35\\n')\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            log_function('BRANCH #5: Covered if branch at line 37-38\\n')\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Shortest Path in a Grid with Obstacles Elimination.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #5: Covered if branch at line 37-38\n", "LOOP #3: Entered for loop at line 27-41\n", "BRANCH #5: Covered if branch at line 37-38\n", "LOOP #2: Entered for loop at line 25-41\n", "LOOP #3: Entered for loop at line 27-41\n"], ["BRANCH #4: Covered if branch at line 34-35\n", "LOOP #3: Entered for loop at line 27-41\n", "LOOP #3: Entered for loop at line 27-41\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 27-41\n"], ["LOOP #3: Entered for loop at line 27-41\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 27-41\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #1: Entered while loop at line 23-41\n"], ["BRANCH #4: Covered if branch at line 34-35\n", "LOOP #3: Entered for loop at line 27-41\n", "LOOP #3: Entered for loop at line 27-41\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 25-41\n"]], "sampled_condition_paths": [["Line 37: ((x, y, newEliminate) in seen)", "Line 27: (l in range(4))", "Line 37: ((x, y, newEliminate) in seen)", "Line 25: (_ in range(len(q)))", "Line 27: (l in range(4))"], ["Line 34: (grid[x][y] == 1 and eliminate == 0)", "Line 27: (l in range(4))", "Line 27: (l in range(4))", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 27: (l in range(4))"], ["Line 27: (l in range(4))", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 27: (l in range(4))", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 23: (q)"], ["Line 34: (grid[x][y] == 1 and eliminate == 0)", "Line 27: (l in range(4))", "Line 27: (l in range(4))", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 25: (_ in range(len(q)))"]]}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "difficulty": 3, "func_name": "pathsWithMaxScore", "description": "You are given a square `board` of characters. You can move on the board\nstarting at the bottom right square marked with the character `'S'`.\n\nYou need to reach the top left square marked with the character `'E'`. The\nrest of the squares are labeled either with a numeric character `1, 2, ..., 9`\nor with an obstacle `'X'`. In one move you can go up, left or up-left\n(diagonally) only if there is no obstacle there.\n\nReturn a list of two integers: the first integer is the maximum sum of numeric\ncharacters you can collect, and the second is the number of such paths that\nyou can take to get that maximum sum, taken modulo `10^9 + 7`.\n\nIn case there is no path, return `[0, 0]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "blocks": [{"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [26, 31, 32, 34, 35, 38, 39], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      log_function('LOOP #1: Entered for loop at line 23-40\\n')\n      for j in reversed(range(n)):\n        log_function('LOOP #2: Entered for loop at line 24-40\\n')\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          log_function('BRANCH #1: Covered if branch at line 25-26\\n')\n          continue\n        for dx, dy in dirs:\n          log_function('LOOP #3: Entered for loop at line 27-36\\n')\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            log_function('BRANCH #2: Covered if branch at line 30-32\\n')\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            log_function('BRANCH #3: Covered elif branch at line 33-35\\n')\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          log_function('BRANCH #4: Covered if branch at line 37-39\\n')\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Paths with Max Score.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 24-40\n", "LOOP #3: Entered for loop at line 27-36\n", "BRANCH #3: Covered elif branch at line 33-35\n", "LOOP #3: Entered for loop at line 27-36\n", "BRANCH #2: Covered if branch at line 30-32\n"], ["BRANCH #2: Covered if branch at line 30-32\n", "LOOP #3: Entered for loop at line 27-36\n", "BRANCH #4: Covered if branch at line 37-39\n", "LOOP #2: Entered for loop at line 24-40\n", "LOOP #3: Entered for loop at line 27-36\n"], ["LOOP #2: Entered for loop at line 24-40\n", "LOOP #3: Entered for loop at line 27-36\n", "BRANCH #2: Covered if branch at line 30-32\n", "LOOP #3: Entered for loop at line 27-36\n", "LOOP #3: Entered for loop at line 27-36\n"], ["BRANCH #3: Covered elif branch at line 33-35\n", "LOOP #3: Entered for loop at line 27-36\n", "BRANCH #2: Covered if branch at line 30-32\n", "LOOP #3: Entered for loop at line 27-36\n", "BRANCH #4: Covered if branch at line 37-39\n"], ["LOOP #3: Entered for loop at line 27-36\n", "LOOP #3: Entered for loop at line 27-36\n", "BRANCH #4: Covered if branch at line 37-39\n", "LOOP #2: Entered for loop at line 24-40\n", "LOOP #3: Entered for loop at line 27-36\n"]], "sampled_condition_paths": [["Line 24: (j in reversed(range(n)))", "Line 27: (dx, dy in dirs)", "Line 30: NOT (dp[i][j] < dp[x][y])", "Line 33: (dp[i][j] == dp[x][y])", "Line 27: (dx, dy in dirs)", "Line 30: (dp[i][j] < dp[x][y])"], ["Line 30: (dp[i][j] < dp[x][y])", "Line 27: (dx, dy in dirs)", "Line 37: (dp[i][j] != -1 and board[i][j] != 'E')", "Line 24: (j in reversed(range(n)))", "Line 27: (dx, dy in dirs)"], ["Line 24: (j in reversed(range(n)))", "Line 27: (dx, dy in dirs)", "Line 30: (dp[i][j] < dp[x][y])", "Line 27: (dx, dy in dirs)", "Line 27: (dx, dy in dirs)"], ["Line 30: NOT (dp[i][j] < dp[x][y])", "Line 33: (dp[i][j] == dp[x][y])", "Line 27: (dx, dy in dirs)", "Line 30: (dp[i][j] < dp[x][y])", "Line 27: (dx, dy in dirs)", "Line 37: (dp[i][j] != -1 and board[i][j] != 'E')"], ["Line 27: (dx, dy in dirs)", "Line 27: (dx, dy in dirs)", "Line 37: (dp[i][j] != -1 and board[i][j] != 'E')", "Line 24: (j in reversed(range(n)))", "Line 27: (dx, dy in dirs)"]]}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "difficulty": 2, "func_name": "findTheCity", "description": "There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where\n`edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted\nedge between cities `fromi` and `toi`, and given the integer\n`distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through\nsome path and whose distance is at most `distanceThreshold`, If there are\nmultiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities i and j is equal to the\nsum of the edges' weights along that path.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "blocks": [{"type": "if", "start": 19, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 21], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      log_function('LOOP #1: Entered for loop at line 17-22\\n')\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        log_function('BRANCH #1: Covered if branch at line 19-21\\n')\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      log_function('LOOP #2: Entered for loop at line 28-30\\n')\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      log_function('LOOP #3: Entered for loop at line 31-34\\n')\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      log_function('LOOP #4: Entered for loop at line 35-39\\n')\n      for i in range(n):\n        log_function('LOOP #5: Entered for loop at line 36-39\\n')\n        for j in range(n):\n          log_function('LOOP #6: Entered for loop at line 37-39\\n')\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\ndef log_function(info_str):\n    with open(\"test_logs/Find the City With the Smallest Number of Neighbors at a Threshold Distance.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #5: Entered for loop at line 36-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n"], ["LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n"], ["LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #5: Entered for loop at line 36-39\n"], ["LOOP #6: Entered for loop at line 37-39\n", "LOOP #4: Entered for loop at line 35-39\n", "LOOP #5: Entered for loop at line 36-39\n", "LOOP #6: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 37-39\n"]], "sampled_condition_paths": [["Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 36: (i in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))"], ["Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))"], ["Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))", "Line 36: (i in range(n))"], ["Line 37: (j in range(n))", "Line 35: (k in range(n))", "Line 36: (i in range(n))", "Line 37: (j in range(n))", "Line 37: (j in range(n))"]]}
{"task_num": 1340, "task_title": "Jump Game V", "difficulty": 3, "func_name": "maxJumps", "description": "Given an array of integers `arr` and an integer `d`. In one step you can jump\nfrom index `i` to index:\n\n* `i + x` where: `i + x < arr.length` and ` 0 < x <= d`.\n* `i - x` where: `i - x >= 0` and ` 0 < x <= d`.\n\nIn addition, you can only jump from index `i` to index `j` if `arr[i] >\narr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More\nformally `min(i, j) < k < max(i, j)`).\n\nYou can choose any index of the array and start jumping. Return the maximum\nnumber of indices you can visit.\n\nNotice that you can not jump outside of the array at any time.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [24, 26], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      log_function('LOOP #1: Entered for loop at line 17-28\\n')\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        log_function('LOOP #2: Entered while loop at line 18-26\\n')\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          log_function('LOOP #3: Entered while loop at line 20-21\\n')\n          indices.append(stack.pop())\n        for j in indices:\n          log_function('LOOP #4: Entered for loop at line 22-26\\n')\n          if i < n and i - j <= d:\n            log_function('BRANCH #1: Covered if branch at line 23-24\\n')\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n\ndef log_function(info_str):\n    with open(\"test_logs/Jump Game V.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 18-26\n", "LOOP #4: Entered for loop at line 22-26\n", "BRANCH #1: Covered if branch at line 23-24\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #1: Entered for loop at line 17-28\n"], ["LOOP #2: Entered while loop at line 18-26\n", "LOOP #4: Entered for loop at line 22-26\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #2: Entered while loop at line 18-26\n", "LOOP #4: Entered for loop at line 22-26\n"], ["LOOP #2: Entered while loop at line 18-26\n", "LOOP #3: Entered while loop at line 20-21\n", "LOOP #3: Entered while loop at line 20-21\n", "LOOP #3: Entered while loop at line 20-21\n", "LOOP #3: Entered while loop at line 20-21\n"], ["LOOP #4: Entered for loop at line 22-26\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #2: Entered while loop at line 18-26\n", "LOOP #4: Entered for loop at line 22-26\n", "BRANCH #2: Covered if branch at line 25-26\n"], ["BRANCH #1: Covered if branch at line 23-24\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #1: Entered for loop at line 17-28\n", "LOOP #2: Entered while loop at line 18-26\n", "LOOP #4: Entered for loop at line 22-26\n"], ["LOOP #4: Entered for loop at line 22-26\n", "LOOP #4: Entered for loop at line 22-26\n", "LOOP #4: Entered for loop at line 22-26\n", "LOOP #4: Entered for loop at line 22-26\n", "LOOP #4: Entered for loop at line 22-26\n"]], "sampled_condition_paths": [["Line 18: (stack and (i == n or arr[stack[-1]] < arr[i]))", "Line 22: (j in indices)", "Line 23: (i < n and i - j <= d)", "Line 25: (stack and j - stack[-1] <= d)", "Line 17: (i in range(n + 1))"], ["Line 18: (stack and (i == n or arr[stack[-1]] < arr[i]))", "Line 22: (j in indices)", "Line 25: (stack and j - stack[-1] <= d)", "Line 18: (stack and (i == n or arr[stack[-1]] < arr[i]))", "Line 22: (j in indices)"], ["Line 18: (stack and (i == n or arr[stack[-1]] < arr[i]))", "Line 20: (stack and arr[stack[-1]] == arr[indices[0]])", "Line 20: (stack and arr[stack[-1]] == arr[indices[0]])", "Line 20: (stack and arr[stack[-1]] == arr[indices[0]])", "Line 20: (stack and arr[stack[-1]] == arr[indices[0]])"], ["Line 22: (j in indices)", "Line 25: (stack and j - stack[-1] <= d)", "Line 18: (stack and (i == n or arr[stack[-1]] < arr[i]))", "Line 22: (j in indices)", "Line 25: (stack and j - stack[-1] <= d)"], ["Line 23: (i < n and i - j <= d)", "Line 25: (stack and j - stack[-1] <= d)", "Line 17: (i in range(n + 1))", "Line 18: (stack and (i == n or arr[stack[-1]] < arr[i]))", "Line 22: (j in indices)"], ["Line 22: (j in indices)", "Line 22: (j in indices)", "Line 22: (j in indices)", "Line 22: (j in indices)", "Line 22: (j in indices)"]]}
{"task_num": 1345, "task_title": "Jump Game IV", "difficulty": 3, "func_name": "minJumps", "description": "Given an array of integers `arr`, you are initially positioned at the first\nindex of the array.\n\nIn one step you can jump from index `i` to index:\n\n* `i + 1` where: `i + 1 < arr.length`.\n* `i - 1` where: `i - 1 >= 0`.\n* `j` where: `arr[i] == arr[j]` and `i != j`.\n\nReturn the minimum number of steps to reach the last index of the array.\n\nNotice that you can not jump outside of the array at any time.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "blocks": [{"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [26, 30, 32, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      log_function('LOOP #1: Entered for loop at line 19-21\\n')\n      graph[a].append(i)\n\n    while q:\n      log_function('LOOP #2: Entered while loop at line 22-39\\n')\n      for _ in range(len(q)):\n        log_function('LOOP #3: Entered for loop at line 23-37\\n')\n        i = q.popleft()\n        if i == n - 1:\n          log_function('BRANCH #1: Covered if branch at line 25-26\\n')\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          log_function('BRANCH #2: Covered if branch at line 29-30\\n')\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          log_function('BRANCH #3: Covered if branch at line 31-32\\n')\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          log_function('LOOP #4: Entered for loop at line 33-36\\n')\n          if v in seen:\n            log_function('BRANCH #4: Covered if branch at line 34-35\\n')\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n\ndef log_function(info_str):\n    with open(\"test_logs/Jump Game IV.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 33-36\n", "LOOP #4: Entered for loop at line 33-36\n", "LOOP #4: Entered for loop at line 33-36\n", "BRANCH #4: Covered if branch at line 34-35\n", "LOOP #3: Entered for loop at line 23-37\n"], ["LOOP #1: Entered for loop at line 19-21\n", "LOOP #2: Entered while loop at line 22-39\n", "LOOP #3: Entered for loop at line 23-37\n", "BRANCH #1: Covered if branch at line 25-26\n"], ["LOOP #1: Entered for loop at line 19-21\n", "LOOP #2: Entered while loop at line 22-39\n", "LOOP #3: Entered for loop at line 23-37\n", "BRANCH #2: Covered if branch at line 29-30\n", "LOOP #4: Entered for loop at line 33-36\n"], ["BRANCH #4: Covered if branch at line 34-35\n", "LOOP #4: Entered for loop at line 33-36\n", "BRANCH #4: Covered if branch at line 34-35\n", "LOOP #3: Entered for loop at line 23-37\n", "BRANCH #1: Covered if branch at line 25-26\n"], ["LOOP #1: Entered for loop at line 19-21\n", "LOOP #1: Entered for loop at line 19-21\n", "LOOP #1: Entered for loop at line 19-21\n", "LOOP #1: Entered for loop at line 19-21\n", "LOOP #1: Entered for loop at line 19-21\n"]], "sampled_condition_paths": [["Line 33: (v in graph[u])", "Line 33: (v in graph[u])", "Line 33: (v in graph[u])", "Line 34: (v in seen)", "Line 23: (_ in range(len(q)))"], ["Line 19: (i, a in enumerate(arr))", "Line 22: (q)", "Line 23: (_ in range(len(q)))", "Line 25: (i == n - 1)"], ["Line 19: (i, a in enumerate(arr))", "Line 22: (q)", "Line 23: (_ in range(len(q)))", "Line 29: (i + 1 < n)", "Line 33: (v in graph[u])"], ["Line 34: (v in seen)", "Line 33: (v in graph[u])", "Line 34: (v in seen)", "Line 23: (_ in range(len(q)))", "Line 25: (i == n - 1)"], ["Line 19: (i, a in enumerate(arr))", "Line 19: (i, a in enumerate(arr))", "Line 19: (i, a in enumerate(arr))", "Line 19: (i, a in enumerate(arr))", "Line 19: (i, a in enumerate(arr))"]]}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "difficulty": 3, "func_name": "frogPosition", "description": "Given an undirected tree consisting of `n` vertices numbered from `1` to `n`.\nA frog starts jumping from vertex 1. In one second, the frog jumps from its\ncurrent vertex to another unvisited vertex if they are directly connected. The\nfrog can not jump back to a visited vertex. In case the frog can jump to\nseveral vertices, it jumps randomly to one of them with the same probability.\nOtherwise, when the frog can not jump to any unvisited vertex, it jumps\nforever on the same vertex.\n\nThe edges of the undirected tree are given in the array `edges`, where\n`edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai`\nand `bi`.\n\nReturn the probability that after `t` seconds the frog is on the vertex\n`target`. Answers within `10-5` of the actual answer will be accepted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "blocks": [{"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.96}], "target_lines": [31, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 21-24\\n')\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      log_function('LOOP #2: Entered for loop at line 25-37\\n')\n      for _ in range(len(q)):\n        log_function('LOOP #3: Entered for loop at line 26-37\\n')\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          log_function('LOOP #4: Entered for loop at line 29-34\\n')\n          if seen[b]:\n            log_function('BRANCH #1: Covered if branch at line 30-31\\n')\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          log_function('BRANCH #2: Covered if branch at line 35-36\\n')\n          prob[a] = 0\n\n    return prob[target]\n\ndef log_function(info_str):\n    with open(\"test_logs/Frog Position After T Seconds.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 29-34\n", "LOOP #4: Entered for loop at line 29-34\n", "BRANCH #2: Covered if branch at line 35-36\n", "LOOP #3: Entered for loop at line 26-37\n"], ["LOOP #1: Entered for loop at line 21-24\n", "LOOP #1: Entered for loop at line 21-24\n", "LOOP #1: Entered for loop at line 21-24\n", "LOOP #1: Entered for loop at line 21-24\n", "LOOP #1: Entered for loop at line 21-24\n"], ["BRANCH #2: Covered if branch at line 35-36\n", "LOOP #2: Entered for loop at line 25-37\n", "LOOP #3: Entered for loop at line 26-37\n", "LOOP #4: Entered for loop at line 29-34\n", "BRANCH #1: Covered if branch at line 30-31\n"], ["LOOP #3: Entered for loop at line 26-37\n", "LOOP #4: Entered for loop at line 29-34\n", "LOOP #4: Entered for loop at line 29-34\n", "LOOP #4: Entered for loop at line 29-34\n", "BRANCH #2: Covered if branch at line 35-36\n"]], "sampled_condition_paths": [["Line 30: (seen[b])", "Line 29: (b in tree[a])", "Line 29: (b in tree[a])", "Line 35: (nChildren > 0)", "Line 26: (_ in range(len(q)))"], ["Line 21: (u, v in edges)", "Line 21: (u, v in edges)", "Line 21: (u, v in edges)", "Line 21: (u, v in edges)", "Line 21: (u, v in edges)"], ["Line 35: (nChildren > 0)", "Line 25: (_ in range(t))", "Line 26: (_ in range(len(q)))", "Line 29: (b in tree[a])", "Line 30: (seen[b])"], ["Line 26: (_ in range(len(q)))", "Line 29: (b in tree[a])", "Line 29: (b in tree[a])", "Line 29: (b in tree[a])", "Line 35: (nChildren > 0)"]]}
{"task_num": 1417, "task_title": "Reformat The String", "difficulty": 1, "func_name": "reformat", "description": "You are given an alphanumeric string `s`. (Alphanumeric string is a string\nconsisting of lowercase English letters and digits).\n\nYou have to find a permutation of the string where no letter is followed by\nanother letter and no digit is followed by another digit. That is, no two\nadjacent characters have the same type.\n\nReturn the reformatted string or return an empty string if it is impossible to\nreformat the string.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 15, "end": 16, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [16, 20, 23, 25, 34], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      log_function('LOOP #1: Entered for loop at line 14-16\\n')\n      if c.isalpha():\n        log_function('BRANCH #1: Covered if branch at line 15-16\\n')\n        A.append(c)\n    B=[]\n    for c in s:\n      log_function('LOOP #2: Entered for loop at line 18-21\\n')\n      if c.isdigit():\n        log_function('BRANCH #2: Covered if branch at line 19-20\\n')\n        B.append(c)\n\n    if len(A) < len(B):\n      log_function('BRANCH #3: Covered if branch at line 22-23\\n')\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      log_function('BRANCH #4: Covered if branch at line 24-25\\n')\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      log_function('LOOP #3: Entered for loop at line 29-32\\n')\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      log_function('BRANCH #5: Covered if branch at line 33-34\\n')\n      ans.append(A[-1])\n    return ''.join(ans)\n\ndef log_function(info_str):\n    with open(\"test_logs/Reformat The String.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 15-16\n", "LOOP #1: Entered for loop at line 14-16\n", "BRANCH #1: Covered if branch at line 15-16\n", "LOOP #1: Entered for loop at line 14-16\n", "BRANCH #1: Covered if branch at line 15-16\n"], ["BRANCH #1: Covered if branch at line 15-16\n", "LOOP #1: Entered for loop at line 14-16\n", "LOOP #1: Entered for loop at line 14-16\n", "BRANCH #1: Covered if branch at line 15-16\n", "LOOP #1: Entered for loop at line 14-16\n"], ["LOOP #1: Entered for loop at line 14-16\n", "BRANCH #1: Covered if branch at line 15-16\n", "LOOP #1: Entered for loop at line 14-16\n", "LOOP #1: Entered for loop at line 14-16\n", "BRANCH #1: Covered if branch at line 15-16\n"], ["BRANCH #1: Covered if branch at line 15-16\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 18-21\n"], ["LOOP #2: Entered for loop at line 18-21\n", "BRANCH #2: Covered if branch at line 19-20\n", "LOOP #2: Entered for loop at line 18-21\n", "BRANCH #2: Covered if branch at line 19-20\n", "LOOP #2: Entered for loop at line 18-21\n"], ["BRANCH #2: Covered if branch at line 19-20\n", "LOOP #2: Entered for loop at line 18-21\n", "BRANCH #2: Covered if branch at line 19-20\n", "LOOP #2: Entered for loop at line 18-21\n", "BRANCH #2: Covered if branch at line 19-20\n"]], "sampled_condition_paths": [["Line 15: (c.isalpha())", "Line 14: (c in s)", "Line 15: (c.isalpha())", "Line 14: (c in s)", "Line 15: (c.isalpha())"], ["Line 15: (c.isalpha())", "Line 14: (c in s)", "Line 14: (c in s)", "Line 15: (c.isalpha())", "Line 14: (c in s)"], ["Line 14: (c in s)", "Line 15: (c.isalpha())", "Line 14: (c in s)", "Line 14: (c in s)", "Line 15: (c.isalpha())"], ["Line 15: (c.isalpha())", "Line 18: (c in s)", "Line 18: (c in s)", "Line 18: (c in s)", "Line 18: (c in s)"], ["Line 18: (c in s)", "Line 19: (c.isdigit())", "Line 18: (c in s)", "Line 19: (c.isdigit())", "Line 18: (c in s)"], ["Line 19: (c.isdigit())", "Line 18: (c in s)", "Line 19: (c.isdigit())", "Line 18: (c in s)", "Line 19: (c.isdigit())"]]}
{"task_num": 1462, "task_title": "Course Schedule IV", "difficulty": 2, "func_name": "checkIfPrerequisite", "description": "There are a total of `numCourses` courses you have to take, labeled from `0`\nto `numCourses - 1`. You are given an array `prerequisites` where\n`prerequisites[i] = [ai, bi]` indicates that you must take course `ai` first\nif you want to take course `bi`.\n\n* For example, the pair `[0, 1]` indicates that you have to take course `0` before you can take course `1`.\n\nPrerequisites can also be indirect. If course `a` is a prerequisite of course\n`b`, and course `b` is a prerequisite of course `c`, then course `a` is a\nprerequisite of course `c`.\n\nYou are also given an array `queries` where `queries[j] = [uj, vj]`. For the\n`jth` query, you should answer whether course `uj` is a prerequisite of course\n`vj` or not.\n\nReturn a boolean array `answer`, where `answer[j]` is the answer to the `jth`\nquery.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      log_function('LOOP #1: Entered for loop at line 16-18\\n')\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      log_function('LOOP #2: Entered for loop at line 19-21\\n')\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      log_function('LOOP #3: Entered for loop at line 25-30\\n')\n      if used[v]:\n        log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n\ndef log_function(info_str):\n    with open(\"test_logs/Course Schedule IV.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 19-21\n", "LOOP #2: Entered for loop at line 19-21\n"], ["LOOP #1: Entered for loop at line 16-18\n", "LOOP #2: Entered for loop at line 19-21\n", "LOOP #2: Entered for loop at line 19-21\n", "LOOP #3: Entered for loop at line 25-30\n"], ["LOOP #1: Entered for loop at line 16-18\n", "LOOP #2: Entered for loop at line 19-21\n", "LOOP #2: Entered for loop at line 19-21\n", "LOOP #3: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 25-30\n"], ["LOOP #3: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 25-30\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 19-21\n"]], "sampled_condition_paths": [["Line 19: (i in range(numCourses))", "Line 19: (i in range(numCourses))"], ["Line 16: (u, v in prerequisites)", "Line 19: (i in range(numCourses))", "Line 19: (i in range(numCourses))", "Line 25: (v in graph[u])"], ["Line 16: (u, v in prerequisites)", "Line 19: (i in range(numCourses))", "Line 19: (i in range(numCourses))", "Line 25: (v in graph[u])", "Line 25: (v in graph[u])"], ["Line 25: (v in graph[u])", "Line 25: (v in graph[u])", "Line 25: (v in graph[u])", "Line 26: (used[v])", "Line 19: (i in range(numCourses))"]]}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "difficulty": 3, "func_name": "findCriticalAndPseudoCriticalEdges", "description": "Given a weighted undirected connected graph with `n` vertices numbered from\n`0` to `n - 1`, and an array `edges` where `edges[i] = [ai, bi, weighti]`\nrepresents a bidirectional and weighted edge between nodes `ai` and `bi`. A\nminimum spanning tree (MST) is a subset of the graph's edges that connects all\nvertices without cycles and with the minimum possible total edge weight.\n\nFind all the critical and pseudo-critical edges in the given graph's minimum\nspanning tree (MST). An MST edge whose deletion from the graph would cause the\nMST weight to increase is called a critical edge. On the other hand, a pseudo-\ncritical edge is that which can appear in some MSTs but not all.\n\nNote that you can return the indices of the edges in any order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.93}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 63, "difficulty": 1, "eg_cov_prob": 0.78}, {"type": "if", "start": 71, "end": 72, "difficulty": 2, "eg_cov_prob": 0.33}, {"type": "if", "start": 54, "end": 55, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 56, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 73, "end": 74, "difficulty": 1, "eg_cov_prob": 0.69}], "target_lines": [20, 22, 24, 26, 27, 31, 50, 51, 55, 57, 63, 72, 74], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 30-31\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      log_function('LOOP #1: Entered for loop at line 40-42\\n')\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        log_function('BRANCH #6: Covered if branch at line 49-51\\n')\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        log_function('LOOP #2: Entered for loop at line 53-60\\n')\n        if index == deletedEdgeIndex:\n          log_function('BRANCH #7: Covered if branch at line 54-55\\n')\n          continue\n        if uf.find(u) == uf.find(v):\n          log_function('BRANCH #8: Covered if branch at line 56-57\\n')\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        log_function('BRANCH #9: Covered if branch at line 62-63\\n')\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      log_function('LOOP #3: Entered for loop at line 69-75\\n')\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        log_function('BRANCH #10: Covered if branch at line 71-72\\n')\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        log_function('BRANCH #11: Covered elif branch at line 73-74\\n')\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n\ndef log_function(info_str):\n    with open(\"test_logs/Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 53-60\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #8: Covered if branch at line 56-57\n", "LOOP #2: Entered for loop at line 53-60\n", "BRANCH #5: Covered if branch at line 30-31\n"], ["BRANCH #11: Covered elif branch at line 73-74\n", "LOOP #3: Entered for loop at line 69-75\n", "LOOP #2: Entered for loop at line 53-60\n", "BRANCH #4: Covered else branch at line 25-27\n", "LOOP #2: Entered for loop at line 53-60\n"], ["BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #6: Covered if branch at line 49-51\n", "BRANCH #4: Covered else branch at line 25-27\n", "LOOP #2: Entered for loop at line 53-60\n", "BRANCH #5: Covered if branch at line 30-31\n"], ["BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #2: Entered for loop at line 53-60\n", "BRANCH #5: Covered if branch at line 30-31\n"]], "sampled_condition_paths": [["Line 53: (u, v, weight, index in edges)", "Line 30: (self.id[u] != u)", "Line 56: (uf.find(u) == uf.find(v))", "Line 53: (u, v, weight, index in edges)", "Line 30: (self.id[u] != u)"], ["Line 71: NOT (getMSTWeight([], index) > mstWeight)", "Line 73: (getMSTWeight(edge, -1) == mstWeight)", "Line 69: (edge in edges)", "Line 53: (u, v, weight, index in edges)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 53: (u, v, weight, index in edges)"], ["Line 30: (self.id[u] != u)", "Line 49: (firstEdge)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 53: (u, v, weight, index in edges)", "Line 30: (self.id[u] != u)"], ["Line 30: (self.id[u] != u)", "Line 30: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 53: (u, v, weight, index in edges)", "Line 30: (self.id[u] != u)"]]}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "difficulty": 2, "func_name": "numWays", "description": "Given a binary string `s`, you can split `s` into 3 non-empty strings `s1`,\n`s2`, and `s3` where `s1 + s2 + s3 = s`.\n\nReturn the number of ways `s` can be split such that the number of ones is the\nsame in `s1`, `s2`, and `s3`. Since the answer may be too large, return it\nmodulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.73}, {"type": "if", "start": 17, "end": 19, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.27}, {"type": "if", "start": 30, "end": 31, "difficulty": 2, "eg_cov_prob": 0.27}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.27}, {"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.27}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.27}], "target_lines": [16, 18, 19, 29, 31, 33, 35, 37], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      log_function('BRANCH #1: Covered if branch at line 15-16\\n')\n      return 0\n    if ones == 0:\n      log_function('BRANCH #2: Covered if branch at line 17-19\\n')\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      log_function('LOOP #1: Entered for loop at line 27-38\\n')\n      if c == '1':\n        log_function('BRANCH #3: Covered if branch at line 28-29\\n')\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        log_function('BRANCH #4: Covered if branch at line 30-31\\n')\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        log_function('BRANCH #5: Covered elif branch at line 32-33\\n')\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        log_function('BRANCH #6: Covered if branch at line 34-35\\n')\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        log_function('BRANCH #7: Covered elif branch at line 36-37\\n')\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Ways to Split a String.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #4: Covered if branch at line 30-31\n", "LOOP #1: Entered for loop at line 27-38\n", "LOOP #1: Entered for loop at line 27-38\n", "BRANCH #3: Covered if branch at line 28-29\n", "BRANCH #5: Covered elif branch at line 32-33\n"], ["BRANCH #3: Covered if branch at line 28-29\n", "BRANCH #4: Covered if branch at line 30-31\n", "LOOP #1: Entered for loop at line 27-38\n", "LOOP #1: Entered for loop at line 27-38\n", "BRANCH #3: Covered if branch at line 28-29\n"], ["BRANCH #2: Covered if branch at line 17-19\n"], ["BRANCH #1: Covered if branch at line 15-16\n"]], "sampled_condition_paths": [["Line 30: (s1End == -1 and onesSoFar == ones // 3)", "Line 27: (i, c in enumerate(s))", "Line 27: (i, c in enumerate(s))", "Line 28: (c == '1')", "Line 30: NOT (s1End == -1 and onesSoFar == ones // 3)", "Line 32: (s2Start == -1 and onesSoFar == ones // 3 + 1)"], ["Line 28: (c == '1')", "Line 30: (s1End == -1 and onesSoFar == ones // 3)", "Line 27: (i, c in enumerate(s))", "Line 27: (i, c in enumerate(s))", "Line 28: (c == '1')"], ["Line 17: (ones == 0)"], ["Line 15: (ones % 3 != 0)"]]}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "difficulty": 2, "func_name": "findLengthOfShortestSubarray", "description": "Given an integer array `arr`, remove a subarray (can be empty) from `arr` such\nthat the remaining elements in `arr` are non-decreasing.\n\nReturn the length of the shortest subarray to remove.\n\nA subarray is a contiguous subsequence of the array.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.46}, {"type": "else", "start": 28, "end": 29, "difficulty": 1, "eg_cov_prob": 0.88}], "target_lines": [27, 29], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      log_function('LOOP #1: Entered while loop at line 17-18\\n')\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      log_function('LOOP #2: Entered while loop at line 19-20\\n')\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      log_function('LOOP #3: Entered while loop at line 25-31\\n')\n      if arr[i] <= arr[j]:\n        log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n        j -= 1\n      else:\n        log_function('BRANCH #2: Covered else branch at line 28-29\\n')\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Shortest Subarray to be Removed to Make Array Sorted.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered while loop at line 17-18\n", "LOOP #1: Entered while loop at line 17-18\n", "LOOP #2: Entered while loop at line 19-20\n", "LOOP #2: Entered while loop at line 19-20\n"], ["BRANCH #2: Covered else branch at line 28-29\n", "LOOP #3: Entered while loop at line 25-31\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #3: Entered while loop at line 25-31\n", "BRANCH #1: Covered if branch at line 26-27\n"], ["LOOP #3: Entered while loop at line 25-31\n", "BRANCH #2: Covered else branch at line 28-29\n"], ["LOOP #3: Entered while loop at line 25-31\n", "BRANCH #2: Covered else branch at line 28-29\n", "LOOP #3: Entered while loop at line 25-31\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #3: Entered while loop at line 25-31\n"]], "sampled_condition_paths": [["Line 17: (l < n - 1 and arr[l + 1] >= arr[l])", "Line 17: (l < n - 1 and arr[l + 1] >= arr[l])", "Line 19: (r > 0 and arr[r - 1] <= arr[r])", "Line 19: (r > 0 and arr[r - 1] <= arr[r])"], ["Line 26: NOT (arr[i] <= arr[j])", "Line 28: ", "Line 25: (i >= 0 and j >= r and j > i)", "Line 26: (arr[i] <= arr[j])", "Line 25: (i >= 0 and j >= r and j > i)", "Line 26: (arr[i] <= arr[j])"], ["Line 25: (i >= 0 and j >= r and j > i)", "Line 26: NOT (arr[i] <= arr[j])", "Line 28: "], ["Line 25: (i >= 0 and j >= r and j > i)", "Line 26: NOT (arr[i] <= arr[j])", "Line 28: ", "Line 25: (i >= 0 and j >= r and j > i)", "Line 26: (arr[i] <= arr[j])", "Line 25: (i >= 0 and j >= r and j > i)"]]}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "difficulty": 3, "func_name": "maxNumEdgesToRemove", "description": "Alice and Bob have an undirected graph of `n` nodes and three types of edges:\n\n* Type 1: Can be traversed by Alice only.\n* Type 2: Can be traversed by Bob only.\n* Type 3: Can be traversed by both Alice and Bob.\n\nGiven an array `edges` where `edges[i] = [typei, ui, vi]` represents a\nbidirectional edge of type `typei` between nodes `ui` and `vi`, find the\nmaximum number of edges you can remove so that after removing the edges, the\ngraph can still be fully traversed by both Alice and Bob. The graph is fully\ntraversed by Alice and Bob if starting from any node, they can reach all other\nnodes.\n\nReturn the maximum number of edges you can remove, or return `-1` if Alice and\nBob cannot fully traverse the graph.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 1, "eg_cov_prob": 0.72}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 57, "end": 58, "difficulty": 2, "eg_cov_prob": 0.05}, {"type": "else", "start": 59, "end": 60, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "else", "start": 26, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 48, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 50, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 51, "end": 52, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 54, "end": 55, "difficulty": 1, "eg_cov_prob": 0.95}], "target_lines": [21, 23, 25, 27, 28, 34, 48, 49, 51, 52, 53, 55, 58, 60], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n      return False\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 22-23\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 24-25\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 26-28\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 33-34\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      log_function('LOOP #1: Entered for loop at line 44-56\\n')\n      u -= 1\n      v -= 1\n      if type == 3:\n        log_function('BRANCH #6: Covered if branch at line 47-49\\n')\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          log_function('BRANCH #7: Covered if branch at line 48-49\\n')\n          requiredEdges += 1\n      elif type == 2:\n        log_function('BRANCH #8: Covered elif branch at line 50-53\\n')\n        if bob.unionByRank(u, v):\n          log_function('BRANCH #9: Covered if branch at line 51-52\\n')\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          log_function('BRANCH #10: Covered if branch at line 54-55\\n')\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        log_function('BRANCH #11: Covered if branch at line 57-58\\n')\n        return len(edges) - requiredEdges\n    else:\n        log_function('BRANCH #12: Covered else branch at line 59-60\\n')\n        return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Remove Max Number of Edges to Keep Graph Fully Traversable.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #4: Covered else branch at line 26-28\n", "BRANCH #7: Covered if branch at line 48-49\n", "LOOP #1: Entered for loop at line 44-56\n", "BRANCH #8: Covered elif branch at line 50-53\n", "BRANCH #3: Covered elif branch at line 24-25\n"], ["BRANCH #3: Covered elif branch at line 24-25\n", "BRANCH #10: Covered if branch at line 54-55\n", "LOOP #1: Entered for loop at line 44-56\n", "BRANCH #5: Covered if branch at line 33-34\n", "BRANCH #1: Covered if branch at line 20-21\n"], ["LOOP #1: Entered for loop at line 44-56\n", "BRANCH #5: Covered if branch at line 33-34\n", "BRANCH #3: Covered elif branch at line 24-25\n", "BRANCH #10: Covered if branch at line 54-55\n", "BRANCH #11: Covered if branch at line 57-58\n"], ["LOOP #1: Entered for loop at line 44-56\n", "BRANCH #5: Covered if branch at line 33-34\n", "BRANCH #5: Covered if branch at line 33-34\n", "BRANCH #1: Covered if branch at line 20-21\n", "BRANCH #11: Covered if branch at line 57-58\n"], ["BRANCH #9: Covered if branch at line 51-52\n", "LOOP #1: Entered for loop at line 44-56\n", "BRANCH #5: Covered if branch at line 33-34\n", "BRANCH #2: Covered if branch at line 22-23\n", "BRANCH #10: Covered if branch at line 54-55\n"], ["BRANCH #2: Covered if branch at line 22-23\n", "BRANCH #7: Covered if branch at line 48-49\n", "LOOP #1: Entered for loop at line 44-56\n", "BRANCH #8: Covered elif branch at line 50-53\n", "BRANCH #5: Covered if branch at line 33-34\n"]], "sampled_condition_paths": [["Line 22: NOT (self.rank[i] < self.rank[j])", "Line 24: NOT (self.rank[i] > self.rank[j])", "Line 26: ", "Line 48: (alice.unionByRank(u, v) | bob.unionByRank(u, v))", "Line 44: (type, u, v in sorted(edges, reverse=True))", "Line 47: NOT (type == 3)", "Line 50: (type == 2)", "Line 22: NOT (self.rank[i] < self.rank[j])", "Line 24: (self.rank[i] > self.rank[j])"], ["Line 22: NOT (self.rank[i] < self.rank[j])", "Line 24: (self.rank[i] > self.rank[j])", "Line 54: (alice.unionByRank(u, v))", "Line 44: (type, u, v in sorted(edges, reverse=True))", "Line 33: (self.id[u] != u)", "Line 20: (i == j)"], ["Line 44: (type, u, v in sorted(edges, reverse=True))", "Line 33: (self.id[u] != u)", "Line 22: NOT (self.rank[i] < self.rank[j])", "Line 24: (self.rank[i] > self.rank[j])", "Line 54: (alice.unionByRank(u, v))", "Line 57: (alice.count == 1 and bob.count == 1)"], ["Line 44: (type, u, v in sorted(edges, reverse=True))", "Line 33: (self.id[u] != u)", "Line 33: (self.id[u] != u)", "Line 20: (i == j)", "Line 57: (alice.count == 1 and bob.count == 1)"], ["Line 51: (bob.unionByRank(u, v))", "Line 44: (type, u, v in sorted(edges, reverse=True))", "Line 33: (self.id[u] != u)", "Line 22: (self.rank[i] < self.rank[j])", "Line 54: (alice.unionByRank(u, v))"], ["Line 22: (self.rank[i] < self.rank[j])", "Line 48: (alice.unionByRank(u, v) | bob.unionByRank(u, v))", "Line 44: (type, u, v in sorted(edges, reverse=True))", "Line 47: NOT (type == 3)", "Line 50: (type == 2)", "Line 33: (self.id[u] != u)"]]}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "difficulty": 1, "func_name": "numSpecial", "description": "Given an `m x n` binary matrix `mat`, return the number of special positions\nin `mat`.\n\nA position `(i, j)` is called special if `mat[i][j] == 1` and all other\nelements in row `i` and column `j` are `0` (rows and columns are 0-indexed).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [22, 23, 28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 19-24\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-24\\n')\n        if mat[i][j] == 1:\n          log_function('BRANCH #1: Covered if branch at line 21-23\\n')\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      log_function('LOOP #3: Entered for loop at line 25-29\\n')\n      for j in range(n):\n        log_function('LOOP #4: Entered for loop at line 26-29\\n')\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          log_function('BRANCH #2: Covered if branch at line 27-28\\n')\n          ans += 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Special Positions in a Binary Matrix.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 19-24\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #2: Entered for loop at line 20-24\n", "BRANCH #1: Covered if branch at line 21-23\n"], ["LOOP #4: Entered for loop at line 26-29\n", "LOOP #4: Entered for loop at line 26-29\n", "LOOP #3: Entered for loop at line 25-29\n", "LOOP #4: Entered for loop at line 26-29\n", "LOOP #4: Entered for loop at line 26-29\n"], ["LOOP #4: Entered for loop at line 26-29\n", "BRANCH #2: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 25-29\n", "LOOP #4: Entered for loop at line 26-29\n", "LOOP #4: Entered for loop at line 26-29\n"], ["LOOP #2: Entered for loop at line 20-24\n", "BRANCH #1: Covered if branch at line 21-23\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #1: Entered for loop at line 19-24\n"]], "sampled_condition_paths": [["Line 19: (i in range(m))", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 21: (mat[i][j] == 1)"], ["Line 26: (j in range(n))", "Line 26: (j in range(n))", "Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 26: (j in range(n))"], ["Line 26: (j in range(n))", "Line 27: (mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1)", "Line 25: (i in range(m))", "Line 26: (j in range(n))", "Line 26: (j in range(n))"], ["Line 20: (j in range(n))", "Line 21: (mat[i][j] == 1)", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 19: (i in range(m))"]]}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "difficulty": 2, "func_name": "unhappyFriends", "description": "You are given a list of `preferences` for `n` friends, where `n` is always\neven.\n\nFor each person `i`, `preferences[i]` contains a list of friends sorted in the\norder of preference. In other words, a friend earlier in the list is more\npreferred than a friend later in the list. Friends in each list are denoted by\nintegers from `0` to `n-1`.\n\nAll the friends are divided into pairs. The pairings are given in a list\n`pairs`, where `pairs[i] = [xi, yi]` denotes `xi` is paired with `yi` and `yi`\nis paired with `xi`.\n\nHowever, this pairing may cause some of the friends to be unhappy. A friend\n`x` is unhappy if `x` is paired with `y` and there exists a friend `u` who is\npaired with `v` but:\n\n* `x` prefers `u` over `y`, and\n* `u` prefers `x` over `v`.\n\nReturn the number of unhappy friends.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "blocks": [{"type": "if", "start": 29, "end": 31, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [30, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      log_function('LOOP #1: Entered for loop at line 17-20\\n')\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      log_function('LOOP #2: Entered for loop at line 21-24\\n')\n      for j in range(n - 1):\n        log_function('LOOP #3: Entered for loop at line 22-24\\n')\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      log_function('LOOP #4: Entered for loop at line 25-32\\n')\n      for u in prefer[x].keys():\n        log_function('LOOP #5: Entered for loop at line 26-32\\n')\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          log_function('BRANCH #1: Covered if branch at line 29-31\\n')\n          ans += 1\n          break\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Unhappy Friends.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 22-24\n", "LOOP #2: Entered for loop at line 21-24\n", "LOOP #3: Entered for loop at line 22-24\n", "LOOP #4: Entered for loop at line 25-32\n", "LOOP #5: Entered for loop at line 26-32\n"], ["LOOP #3: Entered for loop at line 22-24\n", "LOOP #3: Entered for loop at line 22-24\n", "LOOP #2: Entered for loop at line 21-24\n", "LOOP #3: Entered for loop at line 22-24\n", "LOOP #3: Entered for loop at line 22-24\n"], ["LOOP #2: Entered for loop at line 21-24\n", "LOOP #3: Entered for loop at line 22-24\n", "LOOP #4: Entered for loop at line 25-32\n", "LOOP #5: Entered for loop at line 26-32\n", "LOOP #4: Entered for loop at line 25-32\n"], ["LOOP #4: Entered for loop at line 25-32\n", "LOOP #5: Entered for loop at line 26-32\n", "BRANCH #1: Covered if branch at line 29-31\n", "LOOP #4: Entered for loop at line 25-32\n", "LOOP #5: Entered for loop at line 26-32\n"]], "sampled_condition_paths": [["Line 22: (j in range(n - 1))", "Line 21: (i in range(n))", "Line 22: (j in range(n - 1))", "Line 25: (x in range(n))", "Line 26: (u in prefer[x].keys())"], ["Line 22: (j in range(n - 1))", "Line 22: (j in range(n - 1))", "Line 21: (i in range(n))", "Line 22: (j in range(n - 1))", "Line 22: (j in range(n - 1))"], ["Line 21: (i in range(n))", "Line 22: (j in range(n - 1))", "Line 25: (x in range(n))", "Line 26: (u in prefer[x].keys())", "Line 25: (x in range(n))"], ["Line 25: (x in range(n))", "Line 26: (u in prefer[x].keys())", "Line 29: (prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v])", "Line 25: (x in range(n))", "Line 26: (u in prefer[x].keys())"]]}
{"task_num": 1591, "task_title": "Strange Printer II", "difficulty": 3, "func_name": "isPrintable", "description": "There is a strange printer with the following two special requirements:\n\n* On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n* Once the printer has used a color for the above operation, the same color cannot be used again.\n\nYou are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is\nthe color in the position `(row, col)` of the grid.\n\nReturn `true` if it is possible to print the matrix `targetGrid`, otherwise,\nreturn `false`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "blocks": [{"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 51, "end": 52, "difficulty": 2, "eg_cov_prob": 0.09}, {"type": "if", "start": 55, "end": 56, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 63, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [36, 37, 38, 39, 44, 50, 52, 56, 63], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      log_function('LOOP #1: Entered for loop at line 28-45\\n')\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        log_function('LOOP #2: Entered for loop at line 33-40\\n')\n        for j in range(n):\n          log_function('LOOP #3: Entered for loop at line 34-40\\n')\n          if targetGrid[i][j] == color:\n            log_function('BRANCH #1: Covered if branch at line 35-39\\n')\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        log_function('LOOP #4: Entered for loop at line 41-45\\n')\n        for j in range(minJ, maxJ + 1):\n          log_function('LOOP #5: Entered for loop at line 42-45\\n')\n          if targetGrid[i][j] != color:\n            log_function('BRANCH #2: Covered if branch at line 43-44\\n')\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        log_function('BRANCH #3: Covered if branch at line 49-50\\n')\n        return True\n      if states[u] == State.kVisited:\n        log_function('BRANCH #4: Covered if branch at line 51-52\\n')\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        log_function('BRANCH #5: Covered if branch at line 55-56\\n')\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      log_function('LOOP #6: Entered for loop at line 61-63\\n')\n      if hasCycle(i):\n        log_function('BRANCH #6: Covered if branch at line 62-63\\n')\n        return False\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Strange Printer II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 34-40\n", "LOOP #2: Entered for loop at line 33-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n"], ["LOOP #2: Entered for loop at line 33-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n"], ["LOOP #2: Entered for loop at line 33-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #2: Entered for loop at line 33-40\n"], ["LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #2: Entered for loop at line 33-40\n", "LOOP #3: Entered for loop at line 34-40\n"], ["LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #3: Entered for loop at line 34-40\n", "LOOP #2: Entered for loop at line 33-40\n"]], "sampled_condition_paths": [["Line 34: (j in range(n))", "Line 33: (i in range(m))", "Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 34: (j in range(n))"], ["Line 33: (i in range(m))", "Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 34: (j in range(n))"], ["Line 33: (i in range(m))", "Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 33: (i in range(m))"], ["Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 33: (i in range(m))", "Line 34: (j in range(n))"], ["Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 34: (j in range(n))", "Line 33: (i in range(m))"]]}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "difficulty": 2, "func_name": "alertNames", "description": "LeetCode company workers use key-cards to unlock office doors. Each time a\nworker uses their key-card, the security system saves the worker's name and\nthe time when it was used. The system emits an alert if any worker uses the\nkey-card three or more times in a one-hour period.\n\nYou are given a list of strings `keyName` and `keyTime` where `[keyName[i],\nkeyTime[i]]` corresponds to a person's name and the time when their key-card\nwas used in a single day.\n\nAccess times are given in the 24-hour time format \"HH:MM\", such as `\"23:51\"`\nand `\"09:49\"`.\n\nReturn a list of unique worker names who received an alert for frequent\nkeycard use. Sort the names in ascending order alphabetically.\n\nNotice that `\"10:00\"` \\- `\"11:00\"` is considered to be within a one-hour\nperiod, while `\"22:51\"` \\- `\"23:52\"` is not considered to be within a one-hour\nperiod.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.84}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [22, 27, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      log_function('LOOP #1: Entered for loop at line 15-18\\n')\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      log_function('LOOP #2: Entered for loop at line 20-22\\n')\n      if self._hasAlert(minutes):\n        log_function('BRANCH #1: Covered if branch at line 21-22\\n')\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      log_function('BRANCH #2: Covered if branch at line 26-27\\n')\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      log_function('LOOP #3: Entered for loop at line 29-31\\n')\n      if minutes[i - 2] + 60 >= minutes[i]:\n        log_function('BRANCH #3: Covered if branch at line 30-31\\n')\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n\ndef log_function(info_str):\n    with open(\"test_logs/Alert Using Same Key-Card Three or More Times in a One Hour Period.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 15-18\n", "LOOP #2: Entered for loop at line 20-22\n", "LOOP #3: Entered for loop at line 29-31\n", "BRANCH #3: Covered if branch at line 30-31\n", "BRANCH #1: Covered if branch at line 21-22\n"], ["LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #2: Entered for loop at line 20-22\n", "LOOP #3: Entered for loop at line 29-31\n"], ["LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #2: Entered for loop at line 20-22\n", "LOOP #3: Entered for loop at line 29-31\n", "LOOP #2: Entered for loop at line 20-22\n"], ["LOOP #3: Entered for loop at line 29-31\n", "LOOP #2: Entered for loop at line 20-22\n", "LOOP #3: Entered for loop at line 29-31\n", "BRANCH #3: Covered if branch at line 30-31\n", "BRANCH #1: Covered if branch at line 21-22\n"]], "sampled_condition_paths": [["Line 15: (name, time in zip(keyName, keyTime))", "Line 20: (name, minutes in nameToMinutes.items())", "Line 29: (i in range(2, len(minutes)))", "Line 30: (minutes[i - 2] + 60 >= minutes[i])", "Line 21: (self._hasAlert(minutes))"], ["Line 15: (name, time in zip(keyName, keyTime))", "Line 15: (name, time in zip(keyName, keyTime))", "Line 15: (name, time in zip(keyName, keyTime))", "Line 20: (name, minutes in nameToMinutes.items())", "Line 29: (i in range(2, len(minutes)))"], ["Line 15: (name, time in zip(keyName, keyTime))", "Line 15: (name, time in zip(keyName, keyTime))", "Line 20: (name, minutes in nameToMinutes.items())", "Line 29: (i in range(2, len(minutes)))", "Line 20: (name, minutes in nameToMinutes.items())"], ["Line 29: (i in range(2, len(minutes)))", "Line 20: (name, minutes in nameToMinutes.items())", "Line 29: (i in range(2, len(minutes)))", "Line 30: (minutes[i - 2] + 60 >= minutes[i])", "Line 21: (self._hasAlert(minutes))"]]}
{"task_num": 1615, "task_title": "Maximal Network Rank", "difficulty": 2, "func_name": "maximalNetworkRank", "description": "There is an infrastructure of `n` cities with some number of `roads`\nconnecting these cities. Each `roads[i] = [ai, bi]` indicates that there is a\nbidirectional road between cities `ai` and `bi`.\n\nThe network rank of two different cities is defined as the total number of\ndirectly connected roads to either city. If a road is directly connected to\nboth cities, it is only counted once.\n\nThe maximal network rank of the infrastructure is the maximum network rank of\nall pairs of different cities.\n\nGiven the integer `n` and the array `roads`, return the maximal network rank\nof the entire infrastructure.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "blocks": [{"type": "if", "start": 36, "end": 38, "difficulty": 1, "eg_cov_prob": 0.48}, {"type": "else", "start": 39, "end": 42, "difficulty": 1, "eg_cov_prob": 0.52}, {"type": "if", "start": 22, "end": 24, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 1, "eg_cov_prob": 0.79}, {"type": "if", "start": 25, "end": 26, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.48}], "target_lines": [23, 24, 26, 32, 34, 37, 38, 40, 41, 42, 48], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      log_function('LOOP #1: Entered for loop at line 15-18\\n')\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      log_function('LOOP #2: Entered for loop at line 21-27\\n')\n      if degree > maxDegree1:\n        log_function('BRANCH #1: Covered if branch at line 22-24\\n')\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        log_function('BRANCH #2: Covered elif branch at line 25-26\\n')\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      log_function('LOOP #3: Entered for loop at line 30-35\\n')\n      if degree == maxDegree1:\n        log_function('BRANCH #3: Covered if branch at line 31-32\\n')\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        log_function('BRANCH #4: Covered elif branch at line 33-34\\n')\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      log_function('BRANCH #5: Covered if branch at line 36-38\\n')\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      log_function('BRANCH #6: Covered else branch at line 39-42\\n')\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      log_function('LOOP #4: Entered for loop at line 46-48\\n')\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        log_function('BRANCH #7: Covered if branch at line 47-48\\n')\n        edgeCount += 1\n    return edgeCount\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximal Network Rank.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 30-35\n", "LOOP #3: Entered for loop at line 30-35\n", "BRANCH #4: Covered elif branch at line 33-34\n", "LOOP #3: Entered for loop at line 30-35\n", "BRANCH #3: Covered if branch at line 31-32\n"], ["LOOP #1: Entered for loop at line 15-18\n", "LOOP #2: Entered for loop at line 21-27\n", "BRANCH #1: Covered if branch at line 22-24\n", "LOOP #2: Entered for loop at line 21-27\n", "BRANCH #1: Covered if branch at line 22-24\n"], ["LOOP #4: Entered for loop at line 46-48\n", "BRANCH #7: Covered if branch at line 47-48\n", "LOOP #4: Entered for loop at line 46-48\n", "BRANCH #7: Covered if branch at line 47-48\n", "LOOP #4: Entered for loop at line 46-48\n"], ["LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #2: Entered for loop at line 21-27\n", "BRANCH #1: Covered if branch at line 22-24\n", "LOOP #2: Entered for loop at line 21-27\n"], ["LOOP #3: Entered for loop at line 30-35\n", "LOOP #3: Entered for loop at line 30-35\n", "BRANCH #3: Covered if branch at line 31-32\n", "LOOP #3: Entered for loop at line 30-35\n", "BRANCH #3: Covered if branch at line 31-32\n"]], "sampled_condition_paths": [["Line 30: (degree in degrees)", "Line 30: (degree in degrees)", "Line 31: NOT (degree == maxDegree1)", "Line 33: (degree == maxDegree2)", "Line 30: (degree in degrees)", "Line 31: (degree == maxDegree1)"], ["Line 15: (u, v in roads)", "Line 21: (degree in degrees)", "Line 22: (degree > maxDegree1)", "Line 21: (degree in degrees)", "Line 22: (degree > maxDegree1)"], ["Line 46: (u, v in roads)", "Line 47: (degrees[u] == degreeU and degrees[v] == degreeV)", "Line 46: (u, v in roads)", "Line 47: (degrees[u] == degreeU and degrees[v] == degreeV)", "Line 46: (u, v in roads)"], ["Line 15: (u, v in roads)", "Line 15: (u, v in roads)", "Line 21: (degree in degrees)", "Line 22: (degree > maxDegree1)", "Line 21: (degree in degrees)"], ["Line 30: (degree in degrees)", "Line 30: (degree in degrees)", "Line 31: (degree == maxDegree1)", "Line 30: (degree in degrees)", "Line 31: (degree == maxDegree1)"]]}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "difficulty": 2, "func_name": "checkPalindromeFormation", "description": "You are given two strings `a` and `b` of the same length. Choose an index and\nsplit both strings at the same index, splitting `a` into two strings:\n`aprefix` and `asuffix` where `a = aprefix + asuffix`, and splitting `b` into\ntwo strings: `bprefix` and `bsuffix` where `b = bprefix + bsuffix`. Check if\n`aprefix + bsuffix` or `bprefix + asuffix` forms a palindrome.\n\nWhen you split a string `s` into `sprefix` and `ssuffix`, either `ssuffix` or\n`sprefix` is allowed to be empty. For example, if `s = \"abc\"`, then `\"\" +\n\"abc\"`, `\"a\" + \"bc\"`, `\"ab\" + \"c\"` , and `\"abc\" + \"\"` are valid splits.\n\nReturn `true` if it is possible to form a palindrome string, otherwise return\n`false`.\n\nNotice that `x + y` denotes the concatenation of strings `x` and `y`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 27], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      log_function('LOOP #1: Entered while loop at line 17-21\\n')\n      if a[i] != b[j]:\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      log_function('LOOP #2: Entered while loop at line 25-29\\n')\n      if s[i] != s[j]:\n        log_function('BRANCH #2: Covered if branch at line 26-27\\n')\n        return False\n      i += 1\n      j -= 1\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Split Two Strings to Make Palindrome.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 18-19\n", "LOOP #2: Entered while loop at line 25-29\n", "BRANCH #2: Covered if branch at line 26-27\n", "LOOP #2: Entered while loop at line 25-29\n", "BRANCH #2: Covered if branch at line 26-27\n"], ["BRANCH #2: Covered if branch at line 26-27\n", "LOOP #2: Entered while loop at line 25-29\n", "BRANCH #2: Covered if branch at line 26-27\n", "LOOP #1: Entered while loop at line 17-21\n", "BRANCH #1: Covered if branch at line 18-19\n"], [], ["LOOP #1: Entered while loop at line 17-21\n", "LOOP #1: Entered while loop at line 17-21\n", "LOOP #1: Entered while loop at line 17-21\n"]], "sampled_condition_paths": [["Line 18: (a[i] != b[j])", "Line 25: (i < j)", "Line 26: (s[i] != s[j])", "Line 25: (i < j)", "Line 26: (s[i] != s[j])"], ["Line 26: (s[i] != s[j])", "Line 25: (i < j)", "Line 26: (s[i] != s[j])", "Line 17: (i < j)", "Line 18: (a[i] != b[j])"], [], ["Line 17: (i < j)", "Line 17: (i < j)", "Line 17: (i < j)"]]}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "difficulty": 3, "func_name": "countSubgraphsForEachDiameter", "description": "There are `n` cities numbered from `1` to `n`. You are given an array `edges`\nof size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge\nbetween cities `ui` and `vi`. There exists a unique path between each pair of\ncities. In other words, the cities form a tree.\n\nA subtree is a subset of cities where every city is reachable from every other\ncity in the subset, where the path between each pair passes through only the\ncities from the subset. Two subtrees are different if there is a city in one\nsubtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the\nmaximum distance between any two cities in the subtree is equal to `d`.\n\nReturn an array of size `n-1` where the `dth` element (1-indexed) is the\nnumber of subtrees in which the maximum distance between any two cities is\nequal to `d`.\n\nNotice that the distance between the two cities is the number of edges in the\npath between them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "blocks": [{"type": "if", "start": 56, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 58, "end": 59, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 46, "end": 47, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 47, 51, 53, 57, 59], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      log_function('LOOP #1: Entered for loop at line 17-21\\n')\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      log_function('LOOP #2: Entered for loop at line 27-29\\n')\n      dist[i][i] = 0\n\n    for u, v in edges:\n      log_function('LOOP #3: Entered for loop at line 30-33\\n')\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      log_function('LOOP #4: Entered for loop at line 34-38\\n')\n      for i in range(n):\n        log_function('LOOP #5: Entered for loop at line 35-38\\n')\n        for j in range(n):\n          log_function('LOOP #6: Entered for loop at line 36-38\\n')\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      log_function('LOOP #7: Entered for loop at line 45-55\\n')\n      if (mask >> u) & 1 == 0:\n        log_function('BRANCH #2: Covered if branch at line 46-47\\n')\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        log_function('LOOP #8: Entered for loop at line 49-55\\n')\n        if (mask >> v) & 1 == 0:\n          log_function('BRANCH #3: Covered if branch at line 50-51\\n')\n          continue\n        if dist[u][v] == 1:\n          log_function('BRANCH #4: Covered if branch at line 52-53\\n')\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      log_function('BRANCH #5: Covered if branch at line 56-57\\n')\n      return maxDist\n    else:\n      log_function('BRANCH #6: Covered else branch at line 58-59\\n')\n      return 0\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Subtrees With Max Distance Between Cities.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 27-29\n", "LOOP #3: Entered for loop at line 30-33\n", "LOOP #4: Entered for loop at line 34-38\n", "LOOP #5: Entered for loop at line 35-38\n", "LOOP #6: Entered for loop at line 36-38\n"], ["LOOP #8: Entered for loop at line 49-55\n", "BRANCH #3: Covered if branch at line 50-51\n", "LOOP #7: Entered for loop at line 45-55\n", "LOOP #8: Entered for loop at line 49-55\n", "BRANCH #3: Covered if branch at line 50-51\n"], ["LOOP #6: Entered for loop at line 36-38\n", "LOOP #6: Entered for loop at line 36-38\n", "LOOP #6: Entered for loop at line 36-38\n", "LOOP #4: Entered for loop at line 34-38\n", "LOOP #5: Entered for loop at line 35-38\n"], ["BRANCH #3: Covered if branch at line 50-51\n", "LOOP #8: Entered for loop at line 49-55\n", "LOOP #7: Entered for loop at line 45-55\n", "BRANCH #2: Covered if branch at line 46-47\n", "LOOP #7: Entered for loop at line 45-55\n"], ["BRANCH #6: Covered else branch at line 58-59\n", "LOOP #1: Entered for loop at line 17-21\n", "LOOP #7: Entered for loop at line 45-55\n", "LOOP #8: Entered for loop at line 49-55\n", "BRANCH #3: Covered if branch at line 50-51\n"], ["LOOP #6: Entered for loop at line 36-38\n", "LOOP #6: Entered for loop at line 36-38\n", "LOOP #5: Entered for loop at line 35-38\n", "LOOP #6: Entered for loop at line 36-38\n", "LOOP #6: Entered for loop at line 36-38\n"]], "sampled_condition_paths": [["Line 27: (i in range(n))", "Line 30: (u, v in edges)", "Line 34: (k in range(n))", "Line 35: (i in range(n))", "Line 36: (j in range(n))"], ["Line 49: (v in range(u + 1, n))", "Line 50: ((mask >> v) & 1 == 0)", "Line 45: (u in range(n))", "Line 49: (v in range(u + 1, n))", "Line 50: ((mask >> v) & 1 == 0)"], ["Line 36: (j in range(n))", "Line 36: (j in range(n))", "Line 36: (j in range(n))", "Line 34: (k in range(n))", "Line 35: (i in range(n))"], ["Line 50: ((mask >> v) & 1 == 0)", "Line 49: (v in range(u + 1, n))", "Line 45: (u in range(n))", "Line 46: ((mask >> u) & 1 == 0)", "Line 45: (u in range(n))"], ["Line 56: NOT (edgeCount == cityCount - 1)", "Line 58: ", "Line 17: (mask in range(maxMask))", "Line 45: (u in range(n))", "Line 49: (v in range(u + 1, n))", "Line 50: ((mask >> v) & 1 == 0)"], ["Line 36: (j in range(n))", "Line 36: (j in range(n))", "Line 35: (i in range(n))", "Line 36: (j in range(n))", "Line 36: (j in range(n))"]]}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "difficulty": 3, "func_name": "areConnected", "description": "We have `n` cities labeled from `1` to `n`. Two different cities with labels\n`x` and `y` are directly connected by a bidirectional road if and only if `x`\nand `y` share a common divisor strictly greater than some `threshold`. More\nformally, cities with labels `x` and `y` have a road between them if there\nexists an integer `z` such that all of the following are true:\n\n* `x % z == 0`,\n* `y % z == 0`, and\n* `z > threshold`.\n\nGiven the two integers, `n` and `threshold`, and an array of `queries`, you\nmust determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are\nconnected directly or indirectly. (i.e. there is some path between them).\n\nReturn an array `answer`, where `answer.length == queries.length` and\n`answer[i]` is `true` if for the `ith` query, there is a path between `ai` and\n`bi`, or `answer[i]` is `false` if there is no path.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.33}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.46}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.63}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.46}, {"type": "else", "start": 25, "end": 27, "difficulty": 1, "eg_cov_prob": 0.63}], "target_lines": [20, 22, 24, 26, 27, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return False\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 31-32\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      log_function('LOOP #1: Entered for loop at line 40-43\\n')\n      for x in range(z * 2, n + 1, z):\n        log_function('LOOP #2: Entered for loop at line 41-43\\n')\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n\ndef log_function(info_str):\n    with open(\"test_logs/Graph Connectivity With Threshold.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 40-43\n", "LOOP #1: Entered for loop at line 40-43\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #5: Covered if branch at line 31-32\n"], ["LOOP #2: Entered for loop at line 41-43\n", "BRANCH #4: Covered else branch at line 25-27\n", "LOOP #1: Entered for loop at line 40-43\n", "LOOP #1: Entered for loop at line 40-43\n", "LOOP #1: Entered for loop at line 40-43\n"], ["LOOP #1: Entered for loop at line 40-43\n", "LOOP #1: Entered for loop at line 40-43\n", "LOOP #1: Entered for loop at line 40-43\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #5: Covered if branch at line 31-32\n"], ["LOOP #1: Entered for loop at line 40-43\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #5: Covered if branch at line 31-32\n"]], "sampled_condition_paths": [["Line 40: (z in range(threshold + 1, n + 1))", "Line 40: (z in range(threshold + 1, n + 1))", "Line 31: (self.id[u] != u)", "Line 31: (self.id[u] != u)", "Line 31: (self.id[u] != u)"], ["Line 41: (x in range(z * 2, n + 1, z))", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 40: (z in range(threshold + 1, n + 1))", "Line 40: (z in range(threshold + 1, n + 1))", "Line 40: (z in range(threshold + 1, n + 1))"], ["Line 40: (z in range(threshold + 1, n + 1))", "Line 40: (z in range(threshold + 1, n + 1))", "Line 40: (z in range(threshold + 1, n + 1))", "Line 31: (self.id[u] != u)", "Line 31: (self.id[u] != u)"], ["Line 40: (z in range(threshold + 1, n + 1))", "Line 31: (self.id[u] != u)", "Line 31: (self.id[u] != u)", "Line 31: (self.id[u] != u)", "Line 31: (self.id[u] != u)"]]}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "difficulty": 2, "func_name": "minimumEffortPath", "description": "You are a hiker preparing for an upcoming hike. You are given `heights`, a 2D\narray of size `rows x columns`, where `heights[row][col]` represents the\nheight of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`,\nand you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e.,\n0-indexed). You can move up, down, left, or right, and you wish to find a\nroute that requires the minimum effort.\n\nA route's effort is the maximum absolute difference in heights between two\nconsecutive cells of the route.\n\nReturn the minimum effort required to travel from the top-left cell to the\nbottom-right cell.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [25, 31, 33, 37, 38], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      log_function('LOOP #1: Entered while loop at line 22-39\\n')\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        log_function('BRANCH #1: Covered if branch at line 24-25\\n')\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        log_function('LOOP #2: Entered for loop at line 27-39\\n')\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n          continue\n        if (x, y) in seen:\n          log_function('BRANCH #3: Covered if branch at line 32-33\\n')\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          log_function('BRANCH #4: Covered if branch at line 36-38\\n')\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n\ndef log_function(info_str):\n    with open(\"test_logs/Path With Minimum Effort.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 27-39\n", "BRANCH #4: Covered if branch at line 36-38\n", "LOOP #2: Entered for loop at line 27-39\n", "BRANCH #4: Covered if branch at line 36-38\n", "LOOP #2: Entered for loop at line 27-39\n"], ["LOOP #2: Entered for loop at line 27-39\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 27-39\n", "BRANCH #4: Covered if branch at line 36-38\n", "LOOP #2: Entered for loop at line 27-39\n"], ["LOOP #2: Entered for loop at line 27-39\n", "BRANCH #4: Covered if branch at line 36-38\n", "LOOP #2: Entered for loop at line 27-39\n", "LOOP #2: Entered for loop at line 27-39\n", "BRANCH #3: Covered if branch at line 32-33\n"], ["LOOP #1: Entered while loop at line 22-39\n", "LOOP #2: Entered for loop at line 27-39\n", "BRANCH #4: Covered if branch at line 36-38\n", "LOOP #2: Entered for loop at line 27-39\n", "BRANCH #4: Covered if branch at line 36-38\n"], ["LOOP #2: Entered for loop at line 27-39\n", "BRANCH #4: Covered if branch at line 36-38\n", "LOOP #2: Entered for loop at line 27-39\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 27-39\n"], ["BRANCH #4: Covered if branch at line 36-38\n", "LOOP #2: Entered for loop at line 27-39\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 27-39\n", "BRANCH #2: Covered if branch at line 30-31\n"]], "sampled_condition_paths": [["Line 27: (dx, dy in dirs)", "Line 36: (diff[x][y] > maxDiff)", "Line 27: (dx, dy in dirs)", "Line 36: (diff[x][y] > maxDiff)", "Line 27: (dx, dy in dirs)"], ["Line 27: (dx, dy in dirs)", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 27: (dx, dy in dirs)", "Line 36: (diff[x][y] > maxDiff)", "Line 27: (dx, dy in dirs)"], ["Line 27: (dx, dy in dirs)", "Line 36: (diff[x][y] > maxDiff)", "Line 27: (dx, dy in dirs)", "Line 27: (dx, dy in dirs)", "Line 32: ((x, y) in seen)"], ["Line 22: (minHeap)", "Line 27: (dx, dy in dirs)", "Line 36: (diff[x][y] > maxDiff)", "Line 27: (dx, dy in dirs)", "Line 36: (diff[x][y] > maxDiff)"], ["Line 27: (dx, dy in dirs)", "Line 36: (diff[x][y] > maxDiff)", "Line 27: (dx, dy in dirs)", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 27: (dx, dy in dirs)"], ["Line 36: (diff[x][y] > maxDiff)", "Line 27: (dx, dy in dirs)", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 27: (dx, dy in dirs)", "Line 30: (x < 0 or x == m or y < 0 or y == n)"]]}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "difficulty": 3, "func_name": "matrixRankTransform", "description": "Given an `m x n` `matrix`, return a new matrix `answer` where\n`answer[row][col]` is the rank of `matrix[row][col]`.\n\nThe rank is an integer that represents how large an element is compared to\nother elements. It is calculated using the following rules:\n\n* The rank is an integer starting from `1`.\n* If two elements `p` and `q` are in the same row or column, then: \n* If `p < q` then `rank(p) < rank(q)`\n* If `p == q` then `rank(p) == rank(q)`\n* If `p > q` then `rank(p) > rank(q)`\n* The rank should be as small as possible.\n\nThe test cases are generated so that `answer` is unique under the given rules.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      log_function('LOOP #1: Entered for loop at line 25-26\\n')\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      log_function('LOOP #2: Entered for loop at line 43-46\\n')\n      for j, val in enumerate(row):\n        log_function('LOOP #3: Entered for loop at line 44-46\\n')\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      log_function('LOOP #4: Entered for loop at line 47-57\\n')\n      uf = UnionFind()\n      for i, j in grids:\n        log_function('LOOP #5: Entered for loop at line 49-50\\n')\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        log_function('LOOP #6: Entered for loop at line 51-54\\n')\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          log_function('LOOP #7: Entered for loop at line 53-54\\n')\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        log_function('LOOP #8: Entered for loop at line 55-57\\n')\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Rank Transform of a Matrix.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 44-46\n", "LOOP #2: Entered for loop at line 43-46\n", "LOOP #3: Entered for loop at line 44-46\n", "LOOP #3: Entered for loop at line 44-46\n", "LOOP #4: Entered for loop at line 47-57\n"], ["LOOP #2: Entered for loop at line 43-46\n", "LOOP #3: Entered for loop at line 44-46\n", "LOOP #3: Entered for loop at line 44-46\n", "LOOP #4: Entered for loop at line 47-57\n", "LOOP #5: Entered for loop at line 49-50\n"], ["BRANCH #2: Covered if branch at line 30-31\n", "BRANCH #1: Covered if branch at line 20-21\n", "LOOP #5: Entered for loop at line 49-50\n", "BRANCH #2: Covered if branch at line 30-31\n", "BRANCH #1: Covered if branch at line 20-21\n"], ["LOOP #7: Entered for loop at line 53-54\n", "LOOP #8: Entered for loop at line 55-57\n", "LOOP #4: Entered for loop at line 47-57\n", "LOOP #5: Entered for loop at line 49-50\n", "BRANCH #1: Covered if branch at line 20-21\n"], ["BRANCH #1: Covered if branch at line 20-21\n", "LOOP #1: Entered for loop at line 25-26\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #1: Entered for loop at line 25-26\n", "LOOP #6: Entered for loop at line 51-54\n"], ["LOOP #6: Entered for loop at line 51-54\n", "LOOP #7: Entered for loop at line 53-54\n", "LOOP #7: Entered for loop at line 53-54\n", "LOOP #7: Entered for loop at line 53-54\n", "LOOP #8: Entered for loop at line 55-57\n"]], "sampled_condition_paths": [["Line 44: (j, val in enumerate(row))", "Line 43: (i, row in enumerate(matrix))", "Line 44: (j, val in enumerate(row))", "Line 44: (j, val in enumerate(row))", "Line 47: (_, grids in sorted(valToGrids.items()))"], ["Line 43: (i, row in enumerate(matrix))", "Line 44: (j, val in enumerate(row))", "Line 44: (j, val in enumerate(row))", "Line 47: (_, grids in sorted(valToGrids.items()))", "Line 49: (i, j in grids)"], ["Line 30: (self.id[u] != u)", "Line 20: (i != j)", "Line 49: (i, j in grids)", "Line 30: (self.id[u] != u)", "Line 20: (i != j)"], ["Line 53: (i in values)", "Line 55: (i, j in grids)", "Line 47: (_, grids in sorted(valToGrids.items()))", "Line 49: (i, j in grids)", "Line 20: (i != j)"], ["Line 20: (i != j)", "Line 25: (u in self.id.keys())", "Line 30: (self.id[u] != u)", "Line 25: (u in self.id.keys())", "Line 51: (values in uf.getGroupIdToValues().values())"], ["Line 51: (values in uf.getGroupIdToValues().values())", "Line 53: (i in values)", "Line 53: (i in values)", "Line 53: (i in values)", "Line 55: (i, j in grids)"]]}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "difficulty": 2, "func_name": "minimumJumps", "description": "A certain bug's home is on the x-axis at position `x`. Help them get there\nfrom position `0`.\n\nThe bug jumps according to the following rules:\n\n* It can jump exactly `a` positions forward (to the right).\n* It can jump exactly `b` positions backward (to the left).\n* It cannot jump backward twice in a row.\n* It cannot jump to any `forbidden` positions.\n\nThe bug may jump forward beyond its home, but it cannot jump to positions\nnumbered with negative integers.\n\nGiven an array of integers `forbidden`, where `forbidden[i]` means that the\nbug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and\n`x`, return the minimum number of jumps needed for the bug to reach its home.\nIf there is no possible sequence of jumps that lands the bug on position `x`,\nreturn `-1.`\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.18}, {"type": "if", "start": 35, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 40, "difficulty": 1, "eg_cov_prob": 0.79}], "target_lines": [32, 36, 37, 39, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      log_function('LOOP #1: Entered while loop at line 28-42\\n')\n      for _ in range(len(q)):\n        log_function('LOOP #2: Entered for loop at line 29-40\\n')\n        dir, pos = q.popleft()\n        if pos == x:\n          log_function('BRANCH #1: Covered if branch at line 31-32\\n')\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          log_function('BRANCH #2: Covered if branch at line 35-37\\n')\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          log_function('BRANCH #3: Covered if branch at line 38-40\\n')\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Jumps to Reach Home.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 29-40\n", "BRANCH #3: Covered if branch at line 38-40\n", "LOOP #2: Entered for loop at line 29-40\n", "BRANCH #2: Covered if branch at line 35-37\n", "LOOP #2: Entered for loop at line 29-40\n"], ["BRANCH #2: Covered if branch at line 35-37\n", "LOOP #1: Entered while loop at line 28-42\n", "LOOP #2: Entered for loop at line 29-40\n", "BRANCH #2: Covered if branch at line 35-37\n", "LOOP #1: Entered while loop at line 28-42\n"], ["BRANCH #3: Covered if branch at line 38-40\n", "LOOP #1: Entered while loop at line 28-42\n", "LOOP #2: Entered for loop at line 29-40\n", "BRANCH #3: Covered if branch at line 38-40\n", "LOOP #2: Entered for loop at line 29-40\n"], ["LOOP #1: Entered while loop at line 28-42\n", "LOOP #2: Entered for loop at line 29-40\n", "BRANCH #2: Covered if branch at line 35-37\n", "LOOP #1: Entered while loop at line 28-42\n", "LOOP #2: Entered for loop at line 29-40\n"], ["BRANCH #2: Covered if branch at line 35-37\n", "LOOP #1: Entered while loop at line 28-42\n", "LOOP #2: Entered for loop at line 29-40\n", "BRANCH #2: Covered if branch at line 35-37\n", "BRANCH #3: Covered if branch at line 38-40\n"], ["LOOP #1: Entered while loop at line 28-42\n", "LOOP #2: Entered for loop at line 29-40\n", "BRANCH #3: Covered if branch at line 38-40\n", "LOOP #1: Entered while loop at line 28-42\n", "LOOP #2: Entered for loop at line 29-40\n"]], "sampled_condition_paths": [["Line 29: (_ in range(len(q)))", "Line 38: (dir == Direction.kForward and backward >= 0 and backward not in seenBackward)", "Line 29: (_ in range(len(q)))", "Line 35: (forward <= furthest and forward not in seenForward)", "Line 29: (_ in range(len(q)))"], ["Line 35: (forward <= furthest and forward not in seenForward)", "Line 28: (q)", "Line 29: (_ in range(len(q)))", "Line 35: (forward <= furthest and forward not in seenForward)", "Line 28: (q)"], ["Line 38: (dir == Direction.kForward and backward >= 0 and backward not in seenBackward)", "Line 28: (q)", "Line 29: (_ in range(len(q)))", "Line 38: (dir == Direction.kForward and backward >= 0 and backward not in seenBackward)", "Line 29: (_ in range(len(q)))"], ["Line 28: (q)", "Line 29: (_ in range(len(q)))", "Line 35: (forward <= furthest and forward not in seenForward)", "Line 28: (q)", "Line 29: (_ in range(len(q)))"], ["Line 35: (forward <= furthest and forward not in seenForward)", "Line 28: (q)", "Line 29: (_ in range(len(q)))", "Line 35: (forward <= furthest and forward not in seenForward)", "Line 38: (dir == Direction.kForward and backward >= 0 and backward not in seenBackward)"], ["Line 28: (q)", "Line 29: (_ in range(len(q)))", "Line 38: (dir == Direction.kForward and backward >= 0 and backward not in seenBackward)", "Line 28: (q)", "Line 29: (_ in range(len(q)))"]]}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "difficulty": 3, "func_name": "canDistribute", "description": "You are given an array of `n` integers, `nums`, where there are at most `50`\nunique values in the array. You are also given an array of `m` customer order\nquantities, `quantity`, where `quantity[i]` is the amount of integers the\n`ith` customer ordered. Determine if it is possible to distribute `nums` such\nthat:\n\n* The `ith` customer gets exactly `quantity[i]` integers,\n* The integers the `ith` customer gets are all equal, and\n* Every customer is satisfied.\n\nReturn `true` if it is possible to distribute `nums` according to the above\nconditions.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "blocks": [{"type": "if", "start": 45, "end": 46, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.13}], "target_lines": [28, 39, 46], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      log_function('LOOP #1: Entered for loop at line 21-30\\n')\n      for mask in range(maxMask):\n        log_function('LOOP #2: Entered for loop at line 22-30\\n')\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          log_function('LOOP #3: Entered while loop at line 26-30\\n')\n          if validDistribution[i][submask]:\n            log_function('BRANCH #1: Covered if branch at line 27-28\\n')\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      log_function('LOOP #4: Entered for loop at line 36-39\\n')\n      for mask in range(maxMask):\n        log_function('LOOP #5: Entered for loop at line 37-39\\n')\n        if freq >= self._getQuantitySum(quantity, mask):\n          log_function('BRANCH #2: Covered if branch at line 38-39\\n')\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      log_function('LOOP #6: Entered for loop at line 44-46\\n')\n      if mask >> i & 1:\n        log_function('BRANCH #3: Covered if branch at line 45-46\\n')\n        res.append(q)\n    return sum(res)\n\ndef log_function(info_str):\n    with open(\"test_logs/Distribute Repeating Integers.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered while loop at line 26-30\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #2: Entered for loop at line 22-30\n", "LOOP #1: Entered for loop at line 21-30\n", "LOOP #2: Entered for loop at line 22-30\n"], ["BRANCH #3: Covered if branch at line 45-46\n", "LOOP #1: Entered for loop at line 21-30\n", "LOOP #2: Entered for loop at line 22-30\n", "LOOP #3: Entered while loop at line 26-30\n", "LOOP #2: Entered for loop at line 22-30\n"], ["LOOP #1: Entered for loop at line 21-30\n", "LOOP #2: Entered for loop at line 22-30\n", "LOOP #3: Entered while loop at line 26-30\n", "LOOP #2: Entered for loop at line 22-30\n", "LOOP #1: Entered for loop at line 21-30\n"], ["BRANCH #3: Covered if branch at line 45-46\n", "BRANCH #2: Covered if branch at line 38-39\n", "LOOP #1: Entered for loop at line 21-30\n", "LOOP #2: Entered for loop at line 22-30\n", "LOOP #3: Entered while loop at line 26-30\n"], ["BRANCH #1: Covered if branch at line 27-28\n", "LOOP #2: Entered for loop at line 22-30\n", "LOOP #3: Entered while loop at line 26-30\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #2: Entered for loop at line 22-30\n"], ["LOOP #5: Entered for loop at line 37-39\n", "LOOP #6: Entered for loop at line 44-46\n", "LOOP #6: Entered for loop at line 44-46\n", "BRANCH #3: Covered if branch at line 45-46\n", "BRANCH #2: Covered if branch at line 38-39\n"]], "sampled_condition_paths": [["Line 26: (submask > 0)", "Line 27: (validDistribution[i][submask])", "Line 22: (mask in range(maxMask))", "Line 21: (i in range(n - 1, -1, -1))", "Line 22: (mask in range(maxMask))"], ["Line 45: (mask >> i & 1)", "Line 21: (i in range(n - 1, -1, -1))", "Line 22: (mask in range(maxMask))", "Line 26: (submask > 0)", "Line 22: (mask in range(maxMask))"], ["Line 21: (i in range(n - 1, -1, -1))", "Line 22: (mask in range(maxMask))", "Line 26: (submask > 0)", "Line 22: (mask in range(maxMask))", "Line 21: (i in range(n - 1, -1, -1))"], ["Line 45: (mask >> i & 1)", "Line 38: (freq >= self._getQuantitySum(quantity, mask))", "Line 21: (i in range(n - 1, -1, -1))", "Line 22: (mask in range(maxMask))", "Line 26: (submask > 0)"], ["Line 27: (validDistribution[i][submask])", "Line 22: (mask in range(maxMask))", "Line 26: (submask > 0)", "Line 27: (validDistribution[i][submask])", "Line 22: (mask in range(maxMask))"], ["Line 37: (mask in range(maxMask))", "Line 44: (i, q in enumerate(quantity))", "Line 44: (i, q in enumerate(quantity))", "Line 45: (mask >> i & 1)", "Line 38: (freq >= self._getQuantitySum(quantity, mask))"]]}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "difficulty": 3, "func_name": "minimumIncompatibility", "description": "You are given an integer array `nums`\u200b\u200b\u200b and an integer `k`. You are asked to\ndistribute this array into `k` subsets of equal size such that there are no\ntwo equal elements in the same subset.\n\nA subset's incompatibility is the difference between the maximum and minimum\nelements in that array.\n\nReturn the minimum possible sum of incompatibilities of the `k` subsets after\ndistributing the array optimally, or return `-1` if it is not possible.\n\nA subset is a group integers that appear in the array with no particular\norder.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "blocks": [{"type": "if", "start": 34, "end": 35, "difficulty": 1, "eg_cov_prob": 0.91}, {"type": "else", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.09}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.36}, {"type": "if", "start": 43, "end": 44, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 58, "end": 60, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.97}], "target_lines": [27, 31, 35, 37, 44, 51, 59, 60], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      log_function('LOOP #1: Entered for loop at line 25-33\\n')\n      if mask.bit_count() % subsetSize != 0:\n        log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n        continue\n      submask = mask\n      while submask > 0:\n        log_function('LOOP #2: Entered while loop at line 29-33\\n')\n        if incompatibilities[submask] != -1:\n          log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      log_function('BRANCH #3: Covered if branch at line 34-35\\n')\n      return dp[-1]\n    else:\n      log_function('BRANCH #4: Covered else branch at line 36-37\\n')\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      log_function('LOOP #3: Entered for loop at line 42-44\\n')\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        log_function('BRANCH #5: Covered if branch at line 43-44\\n')\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      log_function('LOOP #4: Entered for loop at line 49-51\\n')\n      if mask >> i & 1:\n        log_function('BRANCH #6: Covered if branch at line 50-51\\n')\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      log_function('LOOP #5: Entered for loop at line 57-60\\n')\n      if mask >> i & 1:\n        log_function('BRANCH #7: Covered if branch at line 58-60\\n')\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Incompatibility.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 30-31\n", "LOOP #2: Entered while loop at line 29-33\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #2: Entered while loop at line 29-33\n", "LOOP #2: Entered while loop at line 29-33\n"], ["LOOP #4: Entered for loop at line 49-51\n", "BRANCH #6: Covered if branch at line 50-51\n", "LOOP #4: Entered for loop at line 49-51\n", "LOOP #4: Entered for loop at line 49-51\n", "LOOP #4: Entered for loop at line 49-51\n"], ["LOOP #2: Entered while loop at line 29-33\n", "LOOP #1: Entered for loop at line 25-33\n", "LOOP #2: Entered while loop at line 29-33\n", "LOOP #2: Entered while loop at line 29-33\n", "LOOP #2: Entered while loop at line 29-33\n"], ["BRANCH #6: Covered if branch at line 50-51\n", "BRANCH #5: Covered if branch at line 43-44\n", "LOOP #5: Entered for loop at line 57-60\n", "LOOP #5: Entered for loop at line 57-60\n", "BRANCH #7: Covered if branch at line 58-60\n"], ["BRANCH #6: Covered if branch at line 50-51\n", "BRANCH #5: Covered if branch at line 43-44\n", "LOOP #5: Entered for loop at line 57-60\n", "BRANCH #7: Covered if branch at line 58-60\n", "LOOP #5: Entered for loop at line 57-60\n"]], "sampled_condition_paths": [["Line 30: (incompatibilities[submask] != -1)", "Line 29: (submask > 0)", "Line 30: (incompatibilities[submask] != -1)", "Line 29: (submask > 0)", "Line 29: (submask > 0)"], ["Line 49: (i, num in enumerate(nums))", "Line 50: (mask >> i & 1)", "Line 49: (i, num in enumerate(nums))", "Line 49: (i, num in enumerate(nums))", "Line 49: (i, num in enumerate(nums))"], ["Line 29: (submask > 0)", "Line 25: (mask in range(1, maxMask))", "Line 29: (submask > 0)", "Line 29: (submask > 0)", "Line 29: (submask > 0)"], ["Line 50: (mask >> i & 1)", "Line 43: (mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize))", "Line 57: (i, num in enumerate(nums))", "Line 57: (i, num in enumerate(nums))", "Line 58: (mask >> i & 1)"], ["Line 50: (mask >> i & 1)", "Line 43: (mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize))", "Line 57: (i, num in enumerate(nums))", "Line 58: (mask >> i & 1)", "Line 57: (i, num in enumerate(nums))"]]}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "difficulty": 3, "func_name": "boxDelivering", "description": "You have the task of delivering some boxes from storage to their ports using\nonly one ship. However, this ship has a limit on the number of boxes and the\ntotal weight that it can carry.\n\nYou are given an array `boxes`, where `boxes[i] = [ports\u200b\u200bi\u200b, weighti]`, and\nthree integers `portsCount`, `maxBoxes`, and `maxWeight`.\n\n* `ports\u200b\u200bi` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.\n* `portsCount` is the number of ports.\n* `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered in the order they are given. The ship will\nfollow these steps:\n\n* The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.\n* For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.\n* The ship then makes a return trip to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\n\nReturn the minimum number of trips the ship needs to make to deliver all boxes\nto their respective ports.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      log_function('LOOP #1: Entered for loop at line 19-32\\n')\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        log_function('BRANCH #1: Covered if branch at line 22-23\\n')\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        log_function('LOOP #2: Entered while loop at line 25-30\\n')\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          log_function('BRANCH #2: Covered if branch at line 27-28\\n')\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n\ndef log_function(info_str):\n    with open(\"test_logs/Delivering Boxes from Storage to Ports.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 19-32\n", "LOOP #1: Entered for loop at line 19-32\n", "LOOP #2: Entered while loop at line 25-30\n", "BRANCH #2: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 19-32\n"], ["BRANCH #2: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 19-32\n", "BRANCH #1: Covered if branch at line 22-23\n", "LOOP #2: Entered while loop at line 25-30\n", "LOOP #2: Entered while loop at line 25-30\n"], ["LOOP #1: Entered for loop at line 19-32\n", "LOOP #2: Entered while loop at line 25-30\n", "LOOP #2: Entered while loop at line 25-30\n", "BRANCH #2: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 19-32\n"], ["BRANCH #2: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 19-32\n", "BRANCH #1: Covered if branch at line 22-23\n", "LOOP #1: Entered for loop at line 19-32\n", "LOOP #2: Entered while loop at line 25-30\n"], ["LOOP #1: Entered for loop at line 19-32\n", "LOOP #1: Entered for loop at line 19-32\n", "BRANCH #1: Covered if branch at line 22-23\n", "LOOP #1: Entered for loop at line 19-32\n", "BRANCH #1: Covered if branch at line 22-23\n"]], "sampled_condition_paths": [["Line 19: (r in range(n))", "Line 19: (r in range(n))", "Line 25: (r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]))", "Line 27: (boxes[l][0] != boxes[l + 1][0])", "Line 19: (r in range(n))"], ["Line 27: (boxes[l][0] != boxes[l + 1][0])", "Line 19: (r in range(n))", "Line 22: (r > 0 and boxes[r][0] != boxes[r - 1][0])", "Line 25: (r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]))", "Line 25: (r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]))"], ["Line 19: (r in range(n))", "Line 25: (r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]))", "Line 25: (r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]))", "Line 27: (boxes[l][0] != boxes[l + 1][0])", "Line 19: (r in range(n))"], ["Line 27: (boxes[l][0] != boxes[l + 1][0])", "Line 19: (r in range(n))", "Line 22: (r > 0 and boxes[r][0] != boxes[r - 1][0])", "Line 19: (r in range(n))", "Line 25: (r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]))"], ["Line 19: (r in range(n))", "Line 19: (r in range(n))", "Line 22: (r > 0 and boxes[r][0] != boxes[r - 1][0])", "Line 19: (r in range(n))", "Line 22: (r > 0 and boxes[r][0] != boxes[r - 1][0])"]]}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "difficulty": 2, "func_name": "eatenApples", "description": "There is a special kind of apple tree that grows apples every day for `n`\ndays. On the `ith` day, the tree grows `apples[i]` apples that will rot after\n`days[i]` days, that is on day `i + days[i]` the apples will be rotten and\ncannot be eaten. On some days, the apple tree does not grow any apples, which\nare denoted by `apples[i] == 0` and `days[i] == 0`.\n\nYou decided to eat at most one apple a day (to keep the doctors away). Note\nthat you can keep eating after the first `n` days.\n\nGiven two integer arrays `days` and `apples` of length `n`, return the maximum\nnumber of apples you can eat.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 24, 25, 26, 27], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      log_function('LOOP #1: Entered while loop at line 18-29\\n')\n      while minHeap and minHeap[0][0] <= i:\n        log_function('LOOP #2: Entered while loop at line 19-20\\n')\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        log_function('BRANCH #1: Covered if branch at line 21-22\\n')\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        log_function('BRANCH #2: Covered if branch at line 23-27\\n')\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          log_function('BRANCH #3: Covered if branch at line 25-26\\n')\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Number of Eaten Apples.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 23-27\n", "LOOP #1: Entered while loop at line 18-29\n", "LOOP #2: Entered while loop at line 19-20\n", "BRANCH #1: Covered if branch at line 21-22\n", "BRANCH #2: Covered if branch at line 23-27\n"], ["BRANCH #1: Covered if branch at line 21-22\n", "BRANCH #2: Covered if branch at line 23-27\n", "LOOP #1: Entered while loop at line 18-29\n", "LOOP #2: Entered while loop at line 19-20\n", "BRANCH #1: Covered if branch at line 21-22\n"], ["LOOP #1: Entered while loop at line 18-29\n", "BRANCH #1: Covered if branch at line 21-22\n", "BRANCH #2: Covered if branch at line 23-27\n", "BRANCH #3: Covered if branch at line 25-26\n", "LOOP #1: Entered while loop at line 18-29\n"], ["BRANCH #1: Covered if branch at line 21-22\n", "BRANCH #2: Covered if branch at line 23-27\n", "BRANCH #3: Covered if branch at line 25-26\n", "LOOP #1: Entered while loop at line 18-29\n", "BRANCH #2: Covered if branch at line 23-27\n"]], "sampled_condition_paths": [["Line 23: (minHeap)", "Line 18: (i < n or minHeap)", "Line 19: (minHeap and minHeap[0][0] <= i)", "Line 21: (i < n and apples[i] > 0)", "Line 23: (minHeap)"], ["Line 21: (i < n and apples[i] > 0)", "Line 23: (minHeap)", "Line 18: (i < n or minHeap)", "Line 19: (minHeap and minHeap[0][0] <= i)", "Line 21: (i < n and apples[i] > 0)"], ["Line 18: (i < n or minHeap)", "Line 21: (i < n and apples[i] > 0)", "Line 23: (minHeap)", "Line 25: (numApples > 1)", "Line 18: (i < n or minHeap)"], ["Line 21: (i < n and apples[i] > 0)", "Line 23: (minHeap)", "Line 25: (numApples > 1)", "Line 18: (i < n or minHeap)", "Line 23: (minHeap)"]]}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "difficulty": 2, "func_name": "findBall", "description": "You have a 2-D `grid` of size `m x n` representing a box, and you have `n`\nballs. The box is open on the top and bottom sides.\n\nEach cell in the box has a diagonal board spanning two corners of the cell\nthat can redirect a ball to the right or to the left.\n\n* A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`.\n* A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.\n\nWe drop one ball at the top of each column of the box. Each ball can get stuck\nin the box or fall out of the bottom. A ball gets stuck if it hits a \"V\"\nshaped pattern between two boards or if a board redirects the ball into either\nwall of the box.\n\nReturn an array `answer` of size `n` where `answer[i]` is the column that the\nball falls out of at the bottom after dropping the ball from the `ith` column\nat the top, or `-1` if the ball gets stuck in the box.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.05}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [22, 24, 30], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 18-27\\n')\n      newDp = [-1] * n\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-25\\n')\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          log_function('BRANCH #1: Covered if branch at line 21-22\\n')\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          log_function('BRANCH #2: Covered if branch at line 23-24\\n')\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      log_function('LOOP #3: Entered for loop at line 28-31\\n')\n      if ball != -1:\n        log_function('BRANCH #3: Covered if branch at line 29-30\\n')\n        ans[ball] = i\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Where Will the Ball Fall.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 18-27\n", "LOOP #2: Entered for loop at line 20-25\n", "BRANCH #1: Covered if branch at line 21-22\n", "LOOP #3: Entered for loop at line 28-31\n"], ["LOOP #2: Entered for loop at line 20-25\n", "LOOP #2: Entered for loop at line 20-25\n", "LOOP #2: Entered for loop at line 20-25\n", "LOOP #2: Entered for loop at line 20-25\n", "BRANCH #1: Covered if branch at line 21-22\n"], ["LOOP #2: Entered for loop at line 20-25\n", "LOOP #1: Entered for loop at line 18-27\n", "LOOP #2: Entered for loop at line 20-25\n", "LOOP #2: Entered for loop at line 20-25\n", "LOOP #2: Entered for loop at line 20-25\n"], ["LOOP #2: Entered for loop at line 20-25\n", "BRANCH #1: Covered if branch at line 21-22\n", "LOOP #2: Entered for loop at line 20-25\n", "LOOP #2: Entered for loop at line 20-25\n", "LOOP #2: Entered for loop at line 20-25\n"], ["LOOP #2: Entered for loop at line 20-25\n", "BRANCH #2: Covered if branch at line 23-24\n", "LOOP #2: Entered for loop at line 20-25\n", "BRANCH #2: Covered if branch at line 23-24\n", "LOOP #2: Entered for loop at line 20-25\n"]], "sampled_condition_paths": [["Line 18: (i in range(m))", "Line 20: (j in range(n))", "Line 21: (j + grid[i][j] < 0 or j + grid[i][j] == n)", "Line 28: (i, ball in enumerate(dp))"], ["Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 21: (j + grid[i][j] < 0 or j + grid[i][j] == n)"], ["Line 20: (j in range(n))", "Line 18: (i in range(m))", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 20: (j in range(n))"], ["Line 20: (j in range(n))", "Line 21: (j + grid[i][j] < 0 or j + grid[i][j] == n)", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 20: (j in range(n))"], ["Line 20: (j in range(n))", "Line 23: (grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1)", "Line 20: (j in range(n))", "Line 23: (grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1)", "Line 20: (j in range(n))"]]}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "difficulty": 3, "func_name": "maximizeXor", "description": "You are given an array `nums` consisting of non-negative integers. You are\nalso given a `queries` array, where `queries[i] = [xi, mi]`.\n\nThe answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and\nany element of `nums` that does not exceed `mi`. In other words, the answer is\n`max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements\nin `nums` are larger than `mi`, then the answer is `-1`.\n\nReturn an integer array `answer` where `answer.length == queries.length` and\n`answer[i]` is the answer to the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "blocks": [{"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 70, "end": 71, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 40, "end": 41, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [26, 36, 37, 39, 41, 71], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      log_function('LOOP #1: Entered for loop at line 23-28\\n')\n      bit = num >> i & 1\n      if not node.children[bit]:\n        log_function('BRANCH #1: Covered if branch at line 25-26\\n')\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      log_function('LOOP #2: Entered for loop at line 32-41\\n')\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        log_function('BRANCH #2: Covered if branch at line 35-37\\n')\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        log_function('BRANCH #3: Covered elif branch at line 38-39\\n')\n        node = node.children[bit]\n      else:\n        log_function('BRANCH #4: Covered else branch at line 40-41\\n')\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      log_function('LOOP #3: Entered for loop at line 66-72\\n')\n      while i < len(nums) and nums[i] <= m:\n        log_function('LOOP #4: Entered while loop at line 67-69\\n')\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        log_function('BRANCH #5: Covered if branch at line 70-71\\n')\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum XOR With an Element From Array.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #5: Covered if branch at line 70-71\n", "LOOP #2: Entered for loop at line 32-41\n", "BRANCH #3: Covered elif branch at line 38-39\n", "LOOP #2: Entered for loop at line 32-41\n", "BRANCH #2: Covered if branch at line 35-37\n"], ["LOOP #1: Entered for loop at line 23-28\n", "BRANCH #1: Covered if branch at line 25-26\n", "LOOP #1: Entered for loop at line 23-28\n", "BRANCH #1: Covered if branch at line 25-26\n", "BRANCH #5: Covered if branch at line 70-71\n"], ["LOOP #1: Entered for loop at line 23-28\n", "BRANCH #1: Covered if branch at line 25-26\n", "BRANCH #5: Covered if branch at line 70-71\n", "LOOP #2: Entered for loop at line 32-41\n", "BRANCH #3: Covered elif branch at line 38-39\n"]], "sampled_condition_paths": [["Line 70: (i > 0 and nums[i - 1] <= m)", "Line 32: (i in range(self.maxBit, -1, -1))", "Line 35: NOT (node.children[toggleBit])", "Line 38: (node.children[bit])", "Line 32: (i in range(self.maxBit, -1, -1))", "Line 35: (node.children[toggleBit])"], ["Line 23: (i in range(self.maxBit, -1, -1))", "Line 25: (not node.children[bit])", "Line 23: (i in range(self.maxBit, -1, -1))", "Line 25: (not node.children[bit])", "Line 70: (i > 0 and nums[i - 1] <= m)"], ["Line 23: (i in range(self.maxBit, -1, -1))", "Line 25: (not node.children[bit])", "Line 70: (i > 0 and nums[i - 1] <= m)", "Line 32: (i in range(self.maxBit, -1, -1))", "Line 35: NOT (node.children[toggleBit])", "Line 38: (node.children[bit])"]]}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "difficulty": 2, "func_name": "maximumGain", "description": "You are given a string `s` and two integers `x` and `y`. You can perform two\ntypes of operations any number of times.\n\n* Remove substring `\"ab\"` and gain `x` points. \n* For example, when removing `\"ab\"` from `\"cabxbae\"` it becomes `\"cxbae\"`.\n* Remove substring `\"ba\"` and gain `y` points. \n* For example, when removing `\"ba\"` from `\"cabxbae\"` it becomes `\"cabxe\"`.\n\nReturn the maximum points you can gain after applying the above operations on\n`s`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 1, "eg_cov_prob": 0.5714285714285714}, {"type": "else", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.42857142857142855}, {"type": "if", "start": 24, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 33, "difficulty": 1, "eg_cov_prob": 0.9795918367346939}, {"type": "else", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 16, 25, 26, 28, 32, 33, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      log_function('BRANCH #2: Covered else branch at line 15-16\\n')\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      log_function('LOOP #1: Entered for loop at line 23-29\\n')\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        log_function('BRANCH #3: Covered if branch at line 24-26\\n')\n        stack1.pop()\n        points += point1\n      else:\n        log_function('BRANCH #4: Covered else branch at line 27-28\\n')\n        stack1.append(c)\n\n    for c in stack1:\n      log_function('LOOP #2: Entered for loop at line 30-36\\n')\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        log_function('BRANCH #5: Covered if branch at line 31-33\\n')\n        stack2.pop()\n        points += point2\n      else:\n        log_function('BRANCH #6: Covered else branch at line 34-35\\n')\n        stack2.append(c)\n\n    return points\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Score From Removing Substrings.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 23-29\n", "BRANCH #4: Covered else branch at line 27-28\n", "LOOP #1: Entered for loop at line 23-29\n", "BRANCH #4: Covered else branch at line 27-28\n", "LOOP #1: Entered for loop at line 23-29\n"], ["LOOP #1: Entered for loop at line 23-29\n", "BRANCH #4: Covered else branch at line 27-28\n", "LOOP #2: Entered for loop at line 30-36\n", "BRANCH #6: Covered else branch at line 34-35\n", "LOOP #2: Entered for loop at line 30-36\n"], ["BRANCH #4: Covered else branch at line 27-28\n", "LOOP #1: Entered for loop at line 23-29\n", "BRANCH #3: Covered if branch at line 24-26\n", "LOOP #1: Entered for loop at line 23-29\n", "BRANCH #4: Covered else branch at line 27-28\n"]], "sampled_condition_paths": [["Line 23: (c in s)", "Line 24: NOT (stack1 and stack1[-1] == sub1[0] and c == sub1[1])", "Line 27: ", "Line 23: (c in s)", "Line 24: NOT (stack1 and stack1[-1] == sub1[0] and c == sub1[1])", "Line 27: ", "Line 23: (c in s)"], ["Line 23: (c in s)", "Line 24: NOT (stack1 and stack1[-1] == sub1[0] and c == sub1[1])", "Line 27: ", "Line 30: (c in stack1)", "Line 31: NOT (stack2 and stack2[-1] == sub2[0] and c == sub2[1])", "Line 34: ", "Line 30: (c in stack1)"], ["Line 24: NOT (stack1 and stack1[-1] == sub1[0] and c == sub1[1])", "Line 27: ", "Line 23: (c in s)", "Line 24: (stack1 and stack1[-1] == sub1[0] and c == sub1[1])", "Line 23: (c in s)", "Line 24: NOT (stack1 and stack1[-1] == sub1[0] and c == sub1[1])", "Line 27: "]]}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "difficulty": 3, "func_name": "checkWays", "description": "You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and:\n\n* There are no duplicates.\n* `xi < yi`\n\nLet `ways` be the number of rooted trees that satisfy the following\nconditions:\n\n* The tree consists of nodes whose values appeared in `pairs`.\n* A pair `[xi, yi]` exists in `pairs` if and only if `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.\n* Note: the tree does not have to be a binary tree.\n\nTwo ways are considered to be different if there is at least one node that has\ndifferent parents in both ways.\n\nReturn:\n\n* `0` if `ways == 0`\n* `1` if `ways == 1`\n* `2` if `ways > 1`\n\nA rooted tree is a tree that has a single root node, and all edges are\noriented to be outgoing from the root.\n\nAn ancestor of a node is any node on the path from the root to that node\n(excluding the node itself). The root has no ancestors.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "blocks": [{"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 54, "end": 55, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 56, "end": 57, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 46, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [31, 40, 44, 46, 48, 53, 55, 57], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      log_function('LOOP #1: Entered for loop at line 18-25\\n')\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      log_function('LOOP #2: Entered for loop at line 26-28\\n')\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      log_function('BRANCH #1: Covered if branch at line 30-31\\n')\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        log_function('LOOP #3: Entered for loop at line 38-40\\n')\n        if not connected[u][ancestor]:\n          log_function('BRANCH #2: Covered if branch at line 39-40\\n')\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        log_function('LOOP #4: Entered for loop at line 42-48\\n')\n        if seen[v]:\n          log_function('BRANCH #3: Covered if branch at line 43-44\\n')\n          continue\n        if degrees[v] == degrees[u]:\n          log_function('BRANCH #4: Covered if branch at line 45-46\\n')\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          log_function('BRANCH #5: Covered if branch at line 47-48\\n')\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      log_function('BRANCH #6: Covered if branch at line 52-53\\n')\n      return 0\n    if hasMoreThanOneWay:\n      log_function('BRANCH #7: Covered if branch at line 54-55\\n')\n      return 2\n    else:\n      log_function('BRANCH #8: Covered else branch at line 56-57\\n')\n      return 1\n\ndef log_function(info_str):\n    with open(\"test_logs/Number Of Ways To Reconstruct A Tree.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 38-40\n", "LOOP #4: Entered for loop at line 42-48\n", "BRANCH #3: Covered if branch at line 43-44\n", "LOOP #4: Entered for loop at line 42-48\n", "LOOP #3: Entered for loop at line 38-40\n"], ["LOOP #1: Entered for loop at line 18-25\n", "LOOP #2: Entered for loop at line 26-28\n", "LOOP #2: Entered for loop at line 26-28\n", "LOOP #2: Entered for loop at line 26-28\n", "LOOP #2: Entered for loop at line 26-28\n"], ["LOOP #4: Entered for loop at line 42-48\n", "BRANCH #3: Covered if branch at line 43-44\n", "LOOP #4: Entered for loop at line 42-48\n", "LOOP #3: Entered for loop at line 38-40\n", "LOOP #4: Entered for loop at line 42-48\n"], ["LOOP #1: Entered for loop at line 18-25\n", "LOOP #1: Entered for loop at line 18-25\n", "LOOP #2: Entered for loop at line 26-28\n", "LOOP #2: Entered for loop at line 26-28\n", "LOOP #2: Entered for loop at line 26-28\n"], ["LOOP #1: Entered for loop at line 18-25\n", "LOOP #1: Entered for loop at line 18-25\n", "LOOP #1: Entered for loop at line 18-25\n", "LOOP #2: Entered for loop at line 26-28\n", "LOOP #2: Entered for loop at line 26-28\n"], ["BRANCH #4: Covered if branch at line 45-46\n", "LOOP #3: Entered for loop at line 38-40\n", "LOOP #4: Entered for loop at line 42-48\n", "BRANCH #3: Covered if branch at line 43-44\n", "LOOP #4: Entered for loop at line 42-48\n"]], "sampled_condition_paths": [["Line 38: (ancestor in ancestors)", "Line 42: (v in graph[u])", "Line 43: (seen[v])", "Line 42: (v in graph[u])", "Line 38: (ancestor in ancestors)"], ["Line 18: (u, v in pairs)", "Line 26: (_, children in graph.items())", "Line 26: (_, children in graph.items())", "Line 26: (_, children in graph.items())", "Line 26: (_, children in graph.items())"], ["Line 42: (v in graph[u])", "Line 43: (seen[v])", "Line 42: (v in graph[u])", "Line 38: (ancestor in ancestors)", "Line 42: (v in graph[u])"], ["Line 18: (u, v in pairs)", "Line 18: (u, v in pairs)", "Line 26: (_, children in graph.items())", "Line 26: (_, children in graph.items())", "Line 26: (_, children in graph.items())"], ["Line 18: (u, v in pairs)", "Line 18: (u, v in pairs)", "Line 18: (u, v in pairs)", "Line 26: (_, children in graph.items())", "Line 26: (_, children in graph.items())"], ["Line 45: (degrees[v] == degrees[u])", "Line 38: (ancestor in ancestors)", "Line 42: (v in graph[u])", "Line 43: (seen[v])", "Line 42: (v in graph[u])"]]}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "difficulty": 2, "func_name": "minimumHammingDistance", "description": "You are given two integer arrays, `source` and `target`, both of length `n`.\nYou are also given an array `allowedSwaps` where each `allowedSwaps[i] = [ai,\nbi]` indicates that you are allowed to swap the elements at index `ai` and\nindex `bi` (0-indexed) of array `source`. Note that you can swap elements at a\nspecific pair of indices multiple times and in any order.\n\nThe Hamming distance of two arrays of the same length, `source` and `target`,\nis the number of positions where the elements are different. Formally, it is\nthe number of indices `i` for `0 <= i <= n-1` where `source[i] != target[i]`\n(0-indexed).\n\nReturn the minimum Hamming distance of `source` and `target` after performing\nany amount of swap operations on array `source`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.7755102040816326}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 53, "end": 56, "difficulty": 1, "eg_cov_prob": 0.9285714285714286}, {"type": "if", "start": 55, "end": 56, "difficulty": 1, "eg_cov_prob": 0.9285714285714286}], "target_lines": [20, 22, 24, 26, 27, 31, 52, 54, 55, 56], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 30-31\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      log_function('LOOP #1: Entered for loop at line 42-44\\n')\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      log_function('LOOP #2: Entered for loop at line 45-47\\n')\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      log_function('LOOP #3: Entered for loop at line 48-57\\n')\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        log_function('BRANCH #6: Covered if branch at line 51-52\\n')\n        ans += 1\n      else:\n        log_function('BRANCH #7: Covered else branch at line 53-56\\n')\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          log_function('BRANCH #8: Covered if branch at line 55-56\\n')\n          del count[target[i]]\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimize Hamming Distance After Swap Operations.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #8: Covered if branch at line 55-56\n", "LOOP #3: Entered for loop at line 48-57\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #7: Covered else branch at line 53-56\n", "BRANCH #8: Covered if branch at line 55-56\n"], ["BRANCH #8: Covered if branch at line 55-56\n", "LOOP #3: Entered for loop at line 48-57\n", "BRANCH #7: Covered else branch at line 53-56\n", "BRANCH #8: Covered if branch at line 55-56\n", "LOOP #3: Entered for loop at line 48-57\n"], ["BRANCH #7: Covered else branch at line 53-56\n", "BRANCH #8: Covered if branch at line 55-56\n", "LOOP #3: Entered for loop at line 48-57\n", "BRANCH #6: Covered if branch at line 51-52\n", "LOOP #3: Entered for loop at line 48-57\n"], ["LOOP #1: Entered for loop at line 42-44\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #1: Entered for loop at line 42-44\n", "BRANCH #4: Covered else branch at line 25-27\n", "LOOP #1: Entered for loop at line 42-44\n"], ["LOOP #3: Entered for loop at line 48-57\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #7: Covered else branch at line 53-56\n", "BRANCH #8: Covered if branch at line 55-56\n", "LOOP #3: Entered for loop at line 48-57\n"], ["BRANCH #8: Covered if branch at line 55-56\n", "LOOP #3: Entered for loop at line 48-57\n", "BRANCH #6: Covered if branch at line 51-52\n", "LOOP #3: Entered for loop at line 48-57\n", "BRANCH #6: Covered if branch at line 51-52\n"]], "sampled_condition_paths": [["Line 55: (count[target[i]] == 0)", "Line 48: (i in range(n))", "Line 30: (self.id[u] != u)", "Line 51: NOT (target[i] not in count)", "Line 53: ", "Line 55: (count[target[i]] == 0)"], ["Line 55: (count[target[i]] == 0)", "Line 48: (i in range(n))", "Line 51: NOT (target[i] not in count)", "Line 53: ", "Line 55: (count[target[i]] == 0)", "Line 48: (i in range(n))"], ["Line 51: NOT (target[i] not in count)", "Line 53: ", "Line 55: (count[target[i]] == 0)", "Line 48: (i in range(n))", "Line 51: (target[i] not in count)", "Line 48: (i in range(n))"], ["Line 42: (a, b in allowedSwaps)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 42: (a, b in allowedSwaps)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 42: (a, b in allowedSwaps)"], ["Line 48: (i in range(n))", "Line 30: (self.id[u] != u)", "Line 51: NOT (target[i] not in count)", "Line 53: ", "Line 55: (count[target[i]] == 0)", "Line 48: (i in range(n))"], ["Line 55: (count[target[i]] == 0)", "Line 48: (i in range(n))", "Line 51: (target[i] not in count)", "Line 48: (i in range(n))", "Line 51: (target[i] not in count)"]]}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "difficulty": 3, "func_name": "waysToFillArray", "description": "You are given a 2D integer array, `queries`. For each `queries[i]`, where\n`queries[i] = [ni, ki]`, find the number of different ways you can place\npositive integers into an array of size `ni` such that the product of the\nintegers is `ki`. As the number of ways may be too large, the answer to the\n`ith` query is the number of ways modulo `109 + 7`.\n\nReturn an integer array `answer` where `answer.length == queries.length`, and\n`answer[i]` is the answer to the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "blocks": [{"type": "if", "start": 42, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [43, 44], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      log_function('LOOP #1: Entered for loop at line 31-36\\n')\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        log_function('LOOP #2: Entered for loop at line 33-34\\n')\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      log_function('LOOP #3: Entered for loop at line 41-44\\n')\n      if minPrimeFactors[i] == i:\n        log_function('BRANCH #1: Covered if branch at line 42-44\\n')\n        for j in range(i * i, n, i):\n          log_function('LOOP #4: Entered for loop at line 43-44\\n')\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      log_function('LOOP #5: Entered while loop at line 49-53\\n')\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        log_function('LOOP #6: Entered while loop at line 51-53\\n')\n        num //= divisor\n        count[divisor] += 1\n    return count\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Ways to Make Array With Product.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 43-44\n", "LOOP #4: Entered for loop at line 43-44\n", "LOOP #4: Entered for loop at line 43-44\n", "LOOP #4: Entered for loop at line 43-44\n", "LOOP #4: Entered for loop at line 43-44\n"]], "sampled_condition_paths": [["Line 43: (j in range(i * i, n, i))", "Line 43: (j in range(i * i, n, i))", "Line 43: (j in range(i * i, n, i))", "Line 43: (j in range(i * i, n, i))", "Line 43: (j in range(i * i, n, i))"]]}
{"task_num": 1765, "task_title": "Map of Highest Peak", "difficulty": 2, "func_name": "highestPeak", "description": "You are given an integer matrix `isWater` of size `m x n` that represents a\nmap of land and water cells.\n\n* If `isWater[i][j] == 0`, cell `(i, j)` is a land cell.\n* If `isWater[i][j] == 1`, cell `(i, j)` is a water cell.\n\nYou must assign each cell a height in a way that follows these rules:\n\n* The height of each cell must be non-negative.\n* If the cell is a water cell, its height must be `0`.\n* Any two adjacent cells must have an absolute height difference of at most `1`. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\nFind an assignment of heights such that the maximum height in the matrix is\nmaximized.\n\nReturn an integer matrix `height` of size `m x n` where `height[i][j]` is cell\n`(i, j)`'s height. If there are multiple solutions, return any of them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 31, 33], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 19-24\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-24\\n')\n        if isWater[i][j] == 1:\n          log_function('BRANCH #1: Covered if branch at line 21-23\\n')\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      log_function('LOOP #3: Entered while loop at line 25-36\\n')\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        log_function('LOOP #4: Entered for loop at line 27-36\\n')\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n          continue\n        if ans[x][y] != -1:\n          log_function('BRANCH #3: Covered if branch at line 32-33\\n')\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Map of Highest Peak.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 21-23\n", "LOOP #1: Entered for loop at line 19-24\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #3: Entered while loop at line 25-36\n"], ["LOOP #4: Entered for loop at line 27-36\n", "BRANCH #3: Covered if branch at line 32-33\n", "LOOP #3: Entered while loop at line 25-36\n", "LOOP #4: Entered for loop at line 27-36\n", "BRANCH #3: Covered if branch at line 32-33\n"], ["BRANCH #2: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 27-36\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 27-36\n", "BRANCH #3: Covered if branch at line 32-33\n"], ["LOOP #3: Entered while loop at line 25-36\n", "LOOP #4: Entered for loop at line 27-36\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 27-36\n", "LOOP #4: Entered for loop at line 27-36\n"]], "sampled_condition_paths": [["Line 21: (isWater[i][j] == 1)", "Line 19: (i in range(m))", "Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 25: (q)"], ["Line 27: (dx, dy in dirs)", "Line 32: (ans[x][y] != -1)", "Line 25: (q)", "Line 27: (dx, dy in dirs)", "Line 32: (ans[x][y] != -1)"], ["Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 27: (dx, dy in dirs)", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 27: (dx, dy in dirs)", "Line 32: (ans[x][y] != -1)"], ["Line 25: (q)", "Line 27: (dx, dy in dirs)", "Line 30: (x < 0 or x == m or y < 0 or y == n)", "Line 27: (dx, dy in dirs)", "Line 27: (dx, dy in dirs)"]]}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "difficulty": 3, "func_name": "countPairs", "description": "You are given an undirected graph defined by an integer `n`, the number of\nnodes, and a 2D integer array `edges`, the edges in the graph, where `edges[i]\n= [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`.\nYou are also given an integer array `queries`.\n\nLet `incident(a, b)` be defined as the number of edges that are connected to\neither node `a` or `b`.\n\nThe answer to the `jth` query is the number of pairs of nodes `(a, b)` that\nsatisfy both of the following conditions:\n\n* `a < b`\n* `incident(a, b) > queries[j]`\n\nReturn an array `answers` such that `answers.length == queries.length` and\n`answers[j]` is the answer of the `jth` query.\n\nNote that there can be multiple edges between the same two nodes.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 30, "end": 32, "difficulty": 2, "eg_cov_prob": 0.04081632653061224}, {"type": "else", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.030612244897959183}], "target_lines": [31, 32, 34, 38], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 19-23\\n')\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      log_function('LOOP #2: Entered for loop at line 26-39\\n')\n      i = 1\n      j = n\n      while i < j:\n        log_function('LOOP #3: Entered while loop at line 29-34\\n')\n        if sortedCount[i] + sortedCount[j] > query:\n          log_function('BRANCH #1: Covered if branch at line 30-32\\n')\n          ans[k] += j - i\n          j -= 1\n        else:\n          log_function('BRANCH #2: Covered else branch at line 33-34\\n')\n          i += 1\n      for i in range(1, n + 1):\n        log_function('LOOP #4: Entered for loop at line 35-39\\n')\n        for j, sh in shared[i].items():\n          log_function('LOOP #5: Entered for loop at line 36-39\\n')\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            log_function('BRANCH #3: Covered if branch at line 37-38\\n')\n            ans[k] -= 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Pairs Of Nodes.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 30-32\n", "LOOP #4: Entered for loop at line 35-39\n", "LOOP #5: Entered for loop at line 36-39\n", "LOOP #5: Entered for loop at line 36-39\n", "LOOP #4: Entered for loop at line 35-39\n"], ["BRANCH #2: Covered else branch at line 33-34\n", "LOOP #4: Entered for loop at line 35-39\n", "LOOP #5: Entered for loop at line 36-39\n", "LOOP #5: Entered for loop at line 36-39\n", "LOOP #4: Entered for loop at line 35-39\n"], ["LOOP #4: Entered for loop at line 35-39\n", "LOOP #2: Entered for loop at line 26-39\n", "LOOP #3: Entered while loop at line 29-34\n", "BRANCH #1: Covered if branch at line 30-32\n", "LOOP #3: Entered while loop at line 29-34\n"], ["LOOP #4: Entered for loop at line 35-39\n", "LOOP #5: Entered for loop at line 36-39\n", "LOOP #5: Entered for loop at line 36-39\n", "LOOP #4: Entered for loop at line 35-39\n", "LOOP #5: Entered for loop at line 36-39\n"]], "sampled_condition_paths": [["Line 30: (sortedCount[i] + sortedCount[j] > query)", "Line 35: (i in range(1, n + 1))", "Line 36: (j, sh in shared[i].items())", "Line 36: (j, sh in shared[i].items())", "Line 35: (i in range(1, n + 1))"], ["Line 30: NOT (sortedCount[i] + sortedCount[j] > query)", "Line 33: ", "Line 35: (i in range(1, n + 1))", "Line 36: (j, sh in shared[i].items())", "Line 36: (j, sh in shared[i].items())", "Line 35: (i in range(1, n + 1))"], ["Line 35: (i in range(1, n + 1))", "Line 26: (k, query in enumerate(queries))", "Line 29: (i < j)", "Line 30: (sortedCount[i] + sortedCount[j] > query)", "Line 29: (i < j)"], ["Line 35: (i in range(1, n + 1))", "Line 36: (j, sh in shared[i].items())", "Line 36: (j, sh in shared[i].items())", "Line 35: (i in range(1, n + 1))", "Line 36: (j, sh in shared[i].items())"]]}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "difficulty": 2, "func_name": "countRestrictedPaths", "description": "There is an undirected weighted connected graph. You are given a positive\ninteger `n` which denotes that the graph has `n` nodes labeled from `1` to\n`n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes\nthat there is an edge between nodes `ui` and `vi` with weight equal to\n`weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2,\n..., zk]` such that `z0 = start` and `zk = end` and there is an edge between\n`zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let\n`distanceToLastNode(x)` denote the shortest distance of a path between node\n`n` and node `x`. A restricted path is a path that also satisfies that\n`distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn the number of restricted paths from node `1` to node `n`. Since that\nnumber may be too large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "blocks": [{"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [33, 36, 37, 39, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      log_function('LOOP #1: Entered for loop at line 15-18\\n')\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      log_function('LOOP #2: Entered while loop at line 30-41\\n')\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        log_function('BRANCH #1: Covered if branch at line 32-33\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #3: Entered for loop at line 34-41\\n')\n        if d + w < dist[v]:\n          log_function('BRANCH #2: Covered if branch at line 35-37\\n')\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          log_function('BRANCH #3: Covered if branch at line 38-40\\n')\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Restricted Paths From First to Last Node.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 30-41\n", "LOOP #3: Entered for loop at line 34-41\n", "BRANCH #2: Covered if branch at line 35-37\n", "LOOP #3: Entered for loop at line 34-41\n", "BRANCH #2: Covered if branch at line 35-37\n"], ["LOOP #3: Entered for loop at line 34-41\n", "BRANCH #3: Covered if branch at line 38-40\n", "LOOP #2: Entered while loop at line 30-41\n", "LOOP #3: Entered for loop at line 34-41\n", "BRANCH #2: Covered if branch at line 35-37\n"], ["BRANCH #3: Covered if branch at line 38-40\n", "LOOP #3: Entered for loop at line 34-41\n", "BRANCH #3: Covered if branch at line 38-40\n", "LOOP #3: Entered for loop at line 34-41\n", "BRANCH #2: Covered if branch at line 35-37\n"], ["LOOP #2: Entered while loop at line 30-41\n", "LOOP #3: Entered for loop at line 34-41\n", "BRANCH #3: Covered if branch at line 38-40\n", "LOOP #3: Entered for loop at line 34-41\n", "BRANCH #3: Covered if branch at line 38-40\n"]], "sampled_condition_paths": [["Line 30: (minHeap)", "Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v])", "Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v])"], ["Line 34: (v, w in graph[u])", "Line 38: (dist[v] < dist[u])", "Line 30: (minHeap)", "Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v])"], ["Line 38: (dist[v] < dist[u])", "Line 34: (v, w in graph[u])", "Line 38: (dist[v] < dist[u])", "Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v])"], ["Line 30: (minHeap)", "Line 34: (v, w in graph[u])", "Line 38: (dist[v] < dist[u])", "Line 34: (v, w in graph[u])", "Line 38: (dist[v] < dist[u])"]]}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "difficulty": 3, "func_name": "maximumScore", "description": "You are given an array of integers `nums` (0-indexed) and an integer `k`.\n\nThe score of a subarray `(i, j)` is defined as `min(nums[i], nums[i+1], ...,\nnums[j]) * (j - i + 1)`. A good subarray is a subarray where `i <= k <= j`.\n\nReturn the maximum possible score of a good subarray.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      log_function('LOOP #1: Entered for loop at line 16-23\\n')\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        log_function('LOOP #2: Entered while loop at line 17-21\\n')\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Score of a Good Subarray.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 16-23\n", "LOOP #2: Entered while loop at line 17-21\n", "LOOP #2: Entered while loop at line 17-21\n", "LOOP #2: Entered while loop at line 17-21\n", "BRANCH #1: Covered if branch at line 20-21\n"], ["LOOP #1: Entered for loop at line 16-23\n", "LOOP #2: Entered while loop at line 17-21\n", "BRANCH #1: Covered if branch at line 20-21\n", "LOOP #1: Entered for loop at line 16-23\n", "LOOP #1: Entered for loop at line 16-23\n"], ["LOOP #2: Entered while loop at line 17-21\n", "LOOP #2: Entered while loop at line 17-21\n", "BRANCH #1: Covered if branch at line 20-21\n", "LOOP #1: Entered for loop at line 16-23\n", "LOOP #1: Entered for loop at line 16-23\n"], ["LOOP #1: Entered for loop at line 16-23\n", "LOOP #1: Entered for loop at line 16-23\n", "LOOP #2: Entered while loop at line 17-21\n", "BRANCH #1: Covered if branch at line 20-21\n", "LOOP #1: Entered for loop at line 16-23\n"]], "sampled_condition_paths": [["Line 16: (i in range(len(nums) + 1))", "Line 17: (stack and (i == len(nums) or nums[stack[-1]] > nums[i]))", "Line 17: (stack and (i == len(nums) or nums[stack[-1]] > nums[i]))", "Line 17: (stack and (i == len(nums) or nums[stack[-1]] > nums[i]))", "Line 20: ((not stack or stack[-1] + 1 <= k) and i - 1 >= k)"], ["Line 16: (i in range(len(nums) + 1))", "Line 17: (stack and (i == len(nums) or nums[stack[-1]] > nums[i]))", "Line 20: ((not stack or stack[-1] + 1 <= k) and i - 1 >= k)", "Line 16: (i in range(len(nums) + 1))", "Line 16: (i in range(len(nums) + 1))"], ["Line 17: (stack and (i == len(nums) or nums[stack[-1]] > nums[i]))", "Line 17: (stack and (i == len(nums) or nums[stack[-1]] > nums[i]))", "Line 20: ((not stack or stack[-1] + 1 <= k) and i - 1 >= k)", "Line 16: (i in range(len(nums) + 1))", "Line 16: (i in range(len(nums) + 1))"], ["Line 16: (i in range(len(nums) + 1))", "Line 16: (i in range(len(nums) + 1))", "Line 17: (stack and (i == len(nums) or nums[stack[-1]] > nums[i]))", "Line 20: ((not stack or stack[-1] + 1 <= k) and i - 1 >= k)", "Line 16: (i in range(len(nums) + 1))"]]}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "difficulty": 1, "func_name": "numDifferentIntegers", "description": "You are given a string `word` that consists of digits and lowercase English\nletters.\n\nYou will replace every non-digit character with a space. For example,\n`\"a123bc34d8ef34\"` will become `\" 123 34 8 34\"`. Notice that you are left with\nsome integers that are separated by at least one space: `\"123\"`, `\"34\"`,\n`\"8\"`, and `\"34\"`.\n\nReturn the number of different integers after performing the replacement\noperations on `word`.\n\nTwo integers are considered different if their decimal representations without\nany leading zeros are different.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 2, "eg_cov_prob": 0.29591836734693877}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.9489795918367347}, {"type": "else", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [18, 20, 21, 24, 31, 33], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      log_function('LOOP #1: Entered for loop at line 16-22\\n')\n      if c.isdigit():\n        log_function('BRANCH #1: Covered if branch at line 17-18\\n')\n        curr.append(c)\n      elif curr:\n        log_function('BRANCH #2: Covered elif branch at line 19-21\\n')\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      log_function('BRANCH #3: Covered if branch at line 23-24\\n')\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      log_function('BRANCH #4: Covered if branch at line 30-31\\n')\n      return ['0']\n    else:\n      log_function('BRANCH #5: Covered else branch at line 32-33\\n')\n      return s[index:]\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Different Integers in a String.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 17-18\n", "LOOP #1: Entered for loop at line 16-22\n", "BRANCH #1: Covered if branch at line 17-18\n", "LOOP #1: Entered for loop at line 16-22\n", "BRANCH #1: Covered if branch at line 17-18\n"], ["BRANCH #1: Covered if branch at line 17-18\n", "LOOP #1: Entered for loop at line 16-22\n", "BRANCH #2: Covered elif branch at line 19-21\n", "BRANCH #5: Covered else branch at line 32-33\n", "LOOP #1: Entered for loop at line 16-22\n"], ["LOOP #1: Entered for loop at line 16-22\n", "BRANCH #1: Covered if branch at line 17-18\n", "LOOP #1: Entered for loop at line 16-22\n", "BRANCH #1: Covered if branch at line 17-18\n", "LOOP #1: Entered for loop at line 16-22\n"], ["BRANCH #5: Covered else branch at line 32-33\n", "LOOP #1: Entered for loop at line 16-22\n", "BRANCH #1: Covered if branch at line 17-18\n", "LOOP #1: Entered for loop at line 16-22\n", "BRANCH #2: Covered elif branch at line 19-21\n"]], "sampled_condition_paths": [["Line 17: (c.isdigit())", "Line 16: (c in word)", "Line 17: (c.isdigit())", "Line 16: (c in word)", "Line 17: (c.isdigit())"], ["Line 17: (c.isdigit())", "Line 16: (c in word)", "Line 17: NOT (c.isdigit())", "Line 19: (curr)", "Line 30: NOT (index == -1)", "Line 32: ", "Line 16: (c in word)"], ["Line 16: (c in word)", "Line 17: (c.isdigit())", "Line 16: (c in word)", "Line 17: (c.isdigit())", "Line 16: (c in word)"], ["Line 30: NOT (index == -1)", "Line 32: ", "Line 16: (c in word)", "Line 17: (c.isdigit())", "Line 16: (c in word)", "Line 17: NOT (c.isdigit())", "Line 19: (curr)"]]}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "difficulty": 3, "func_name": "largestPathValue", "description": "There is a directed graph of `n` colored nodes and `m` edges. The nodes are\nnumbered from `0` to `n - 1`.\n\nYou are given a string `colors` where `colors[i]` is a lowercase English\nletter representing the color of the `ith` node in this graph (0-indexed). You\nare also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that\nthere is a directed edge from node `aj` to node `bj`.\n\nA valid path in the graph is a sequence of nodes `x1 -> x2 -> x3 -> ... -> xk`\nsuch that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`.\nThe color value of the path is the number of nodes that are colored the most\nfrequently occurring color along that path.\n\nReturn the largest color value of any valid path in the given graph, or `-1`\nif the graph contains a cycle.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "blocks": [{"type": "if", "start": 41, "end": 42, "difficulty": 2, "eg_cov_prob": 0.17346938775510204}, {"type": "else", "start": 43, "end": 44, "difficulty": 1, "eg_cov_prob": 0.826530612244898}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.9183673469387755}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.9081632653061225}], "target_lines": [27, 39, 42, 44], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 21-24\\n')\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      log_function('LOOP #2: Entered for loop at line 25-28\\n')\n      if degree == 0:\n        log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n        q.append(i)\n\n    while q:\n      log_function('LOOP #3: Entered while loop at line 29-40\\n')\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        log_function('LOOP #4: Entered for loop at line 34-40\\n')\n        for i in range(26):\n          log_function('LOOP #5: Entered for loop at line 35-36\\n')\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          log_function('BRANCH #2: Covered if branch at line 38-39\\n')\n          q.append(v)\n\n    if processed == n:\n      log_function('BRANCH #3: Covered if branch at line 41-42\\n')\n      return ans\n    else:\n      log_function('BRANCH #4: Covered else branch at line 43-44\\n')\n      return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Largest Color Value in a Directed Graph.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 21-24\n", "LOOP #2: Entered for loop at line 25-28\n", "BRANCH #4: Covered else branch at line 43-44\n"], ["LOOP #5: Entered for loop at line 35-36\n", "LOOP #5: Entered for loop at line 35-36\n", "LOOP #5: Entered for loop at line 35-36\n", "LOOP #5: Entered for loop at line 35-36\n", "LOOP #5: Entered for loop at line 35-36\n"]], "sampled_condition_paths": [["Line 21: (u, v in edges)", "Line 25: (i, degree in enumerate(inDegrees))", "Line 41: NOT (processed == n)", "Line 43: "], ["Line 35: (i in range(26))", "Line 35: (i in range(26))", "Line 35: (i in range(26))", "Line 35: (i in range(26))", "Line 35: (i in range(26))"]]}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "difficulty": 2, "func_name": "getBiggestThree", "description": "You are given an `m x n` integer matrix `grid`\u200b\u200b\u200b.\n\nA rhombus sum is the sum of the elements that form the border of a regular\nrhombus shape in `grid`\u200b\u200b\u200b. The rhombus must have the shape of a square\nrotated 45 degrees with each of the corners centered in a grid cell. Below is\nan image of four valid rhombus shapes with the corresponding colored cells\nthat should be included in each rhombus sum:\n\nNote that the rhombus can have an area of 0, which is depicted by the purple\nrhombus in the bottom right corner.\n\nReturn the biggest three distinct rhombus sums in the `grid` in descending\norder. If there are less than three distinct values, return all of them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 20-29\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 21-29\\n')\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          log_function('LOOP #3: Entered while loop at line 23-29\\n')\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      log_function('LOOP #4: Entered for loop at line 37-41\\n')\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      log_function('LOOP #5: Entered for loop at line 42-46\\n')\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      log_function('LOOP #6: Entered for loop at line 47-51\\n')\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      log_function('LOOP #7: Entered for loop at line 52-56\\n')\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n\ndef log_function(info_str):\n    with open(\"test_logs/Get Biggest Three Rhombus Sums in a Grid.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 21-29\n", "LOOP #3: Entered while loop at line 23-29\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #1: Entered for loop at line 20-29\n", "LOOP #2: Entered for loop at line 21-29\n"], ["LOOP #3: Entered while loop at line 23-29\n", "LOOP #2: Entered for loop at line 21-29\n", "LOOP #3: Entered while loop at line 23-29\n", "LOOP #2: Entered for loop at line 21-29\n", "LOOP #3: Entered while loop at line 23-29\n"], ["LOOP #6: Entered for loop at line 47-51\n", "LOOP #7: Entered for loop at line 52-56\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 21-29\n", "LOOP #3: Entered while loop at line 23-29\n"], ["LOOP #2: Entered for loop at line 21-29\n", "LOOP #3: Entered while loop at line 23-29\n", "LOOP #2: Entered for loop at line 21-29\n", "LOOP #3: Entered while loop at line 23-29\n", "LOOP #2: Entered for loop at line 21-29\n"], ["BRANCH #1: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 21-29\n", "LOOP #3: Entered while loop at line 23-29\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #1: Entered for loop at line 20-29\n"], ["LOOP #3: Entered while loop at line 23-29\n", "LOOP #4: Entered for loop at line 37-41\n", "LOOP #5: Entered for loop at line 42-46\n", "LOOP #6: Entered for loop at line 47-51\n", "LOOP #7: Entered for loop at line 52-56\n"]], "sampled_condition_paths": [["Line 21: (j in range(n))", "Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)", "Line 26: (len(sums) > 3)", "Line 20: (i in range(m))", "Line 21: (j in range(n))"], ["Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)", "Line 21: (j in range(n))", "Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)", "Line 21: (j in range(n))", "Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)"], ["Line 47: (_ in range(sz))", "Line 52: (_ in range(sz))", "Line 26: (len(sums) > 3)", "Line 21: (j in range(n))", "Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)"], ["Line 21: (j in range(n))", "Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)", "Line 21: (j in range(n))", "Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)", "Line 21: (j in range(n))"], ["Line 26: (len(sums) > 3)", "Line 21: (j in range(n))", "Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)", "Line 26: (len(sums) > 3)", "Line 20: (i in range(m))"], ["Line 23: (i + sz < m and i - sz >= 0 and j + 2 * sz < n)", "Line 37: (_ in range(sz))", "Line 42: (_ in range(sz))", "Line 47: (_ in range(sz))", "Line 52: (_ in range(sz))"]]}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "difficulty": 3, "func_name": "minOperationsToFlip", "description": "You are given a valid boolean expression as a string `expression` consisting\nof the characters `'1'`,`'0'`,`'&'` (bitwise AND operator),`'|'` (bitwise OR\noperator),`'('`, and `')'`.\n\n* For example, `\"()1|1\"` and `\"(1)&()\"` are not valid while `\"1\"`, `\"(((1))|(0))\"`, and `\"1|(0&(1))\"` are valid expressions.\n\nReturn the minimum cost to change the final value of the expression.\n\n* For example, if `expression = \"1|1|(0&0)&1\"`, its value is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the new expression evaluates to `0`.\n\nThe cost of changing the final value of an expression is the number of\noperations performed on the expression. The types of operations are described\nas follows:\n\n* Turn a `'1'` into a `'0'`.\n* Turn a `'0'` into a `'1'`.\n* Turn a `'&'` into a `'|'`.\n* Turn a `'|'` into a `'&'`.\n\nNote: `'&'` does not take precedence over `'|'` in the order of calculation.\nEvaluate parentheses first, then in left-to-right order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "blocks": [{"type": "if", "start": 16, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 21, "difficulty": 1, "eg_cov_prob": 0.7755102040816326}, {"type": "else", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 37, "difficulty": 1, "eg_cov_prob": 0.8367346938775511}, {"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.4387755102040816}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.40816326530612246}, {"type": "if", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.5204081632653061}, {"type": "else", "start": 35, "end": 36, "difficulty": 1, "eg_cov_prob": 0.4489795918367347}, {"type": "if", "start": 42, "end": 43, "difficulty": 1, "eg_cov_prob": 0.45918367346938777}, {"type": "else", "start": 44, "end": 45, "difficulty": 1, "eg_cov_prob": 0.40816326530612246}], "target_lines": [17, 18, 20, 21, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 42, 43, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      log_function('LOOP #1: Entered for loop at line 15-47\\n')\n      if e in '(&|':\n        log_function('BRANCH #1: Covered if branch at line 16-18\\n')\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        log_function('BRANCH #2: Covered if branch at line 19-21\\n')\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        log_function('BRANCH #3: Covered else branch at line 22-23\\n')\n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        log_function('BRANCH #4: Covered if branch at line 24-45\\n')\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          log_function('BRANCH #5: Covered if branch at line 28-37\\n')\n          if a == '0' and b == '0':\n            log_function('BRANCH #6: Covered if branch at line 29-30\\n')\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            log_function('BRANCH #7: Covered elif branch at line 31-32\\n')\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            log_function('BRANCH #8: Covered elif branch at line 33-34\\n')\n            lastPair = ('0', 1)\n          else:\n            log_function('BRANCH #9: Covered else branch at line 35-36\\n')\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            log_function('BRANCH #10: Covered if branch at line 38-39\\n')\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            log_function('BRANCH #11: Covered elif branch at line 40-41\\n')\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            log_function('BRANCH #12: Covered elif branch at line 42-43\\n')\n            lastPair = ('1', 1)\n          else:\n            log_function('BRANCH #13: Covered else branch at line 44-45\\n')\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Cost to Change the Final Value of Expression.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 16-18\n", "LOOP #1: Entered for loop at line 15-47\n", "BRANCH #3: Covered else branch at line 22-23\n", "BRANCH #4: Covered if branch at line 24-45\n", "BRANCH #5: Covered if branch at line 28-37\n"], ["LOOP #1: Entered for loop at line 15-47\n", "BRANCH #1: Covered if branch at line 16-18\n", "LOOP #1: Entered for loop at line 15-47\n", "BRANCH #3: Covered else branch at line 22-23\n", "BRANCH #4: Covered if branch at line 24-45\n"], ["BRANCH #3: Covered else branch at line 22-23\n", "LOOP #1: Entered for loop at line 15-47\n", "BRANCH #1: Covered if branch at line 16-18\n", "LOOP #1: Entered for loop at line 15-47\n", "BRANCH #3: Covered else branch at line 22-23\n"], ["LOOP #1: Entered for loop at line 15-47\n", "BRANCH #3: Covered else branch at line 22-23\n", "BRANCH #4: Covered if branch at line 24-45\n", "BRANCH #5: Covered if branch at line 28-37\n", "BRANCH #6: Covered if branch at line 29-30\n"], ["BRANCH #4: Covered if branch at line 24-45\n", "BRANCH #11: Covered elif branch at line 40-41\n", "LOOP #1: Entered for loop at line 15-47\n", "BRANCH #2: Covered if branch at line 19-21\n", "BRANCH #4: Covered if branch at line 24-45\n"]], "sampled_condition_paths": [["Line 16: (e in '(&|')", "Line 15: (e in expression)", "Line 19: NOT (e == ')')", "Line 22: ", "Line 24: (stack and stack[-1][0] in '&|')", "Line 28: (op == '&')"], ["Line 15: (e in expression)", "Line 16: (e in '(&|')", "Line 15: (e in expression)", "Line 19: NOT (e == ')')", "Line 22: ", "Line 24: (stack and stack[-1][0] in '&|')"], ["Line 19: NOT (e == ')')", "Line 22: ", "Line 15: (e in expression)", "Line 16: (e in '(&|')", "Line 15: (e in expression)", "Line 19: NOT (e == ')')", "Line 22: "], ["Line 15: (e in expression)", "Line 19: NOT (e == ')')", "Line 22: ", "Line 24: (stack and stack[-1][0] in '&|')", "Line 28: (op == '&')", "Line 29: (a == '0' and b == '0')"], ["Line 24: (stack and stack[-1][0] in '&|')", "Line 38: NOT (a == '0' and b == '0')", "Line 40: (a == '0' and b == '1')", "Line 15: (e in expression)", "Line 19: (e == ')')", "Line 24: (stack and stack[-1][0] in '&|')"]]}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "difficulty": 2, "func_name": "minDifference", "description": "The minimum absolute difference of an array `a` is defined as the minimum\nvalue of `|a[i] - a[j]|`, where `0 <= i < j < a.length` and `a[i] != a[j]`. If\nall elements of `a` are the same, the minimum absolute difference is `-1`.\n\n* For example, the minimum absolute difference of the array `[5,2,3,7,2]` is `|2 - 3| = 1`. Note that it is not `0` because `a[i]` and `a[j]` must be different.\n\nYou are given an integer array `nums` and the array `queries` where\n`queries[i] = [li, ri]`. For each query `i`, compute the minimum absolute\ndifference of the subarray `nums[li...ri]` containing the elements of `nums`\nbetween the 0-based indices `li` and `ri` (inclusive).\n\nReturn an array `ans` where `ans[i]` is the answer to the `ith` query.\n\nA subarray is a contiguous sequence of elements in an array.\n\nThe value of `|x|` is defined as:\n\n* `x` if `x >= 0`.\n* `-x` if `x < 0`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 31, 33], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      log_function('LOOP #1: Entered for loop at line 16-18\\n')\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      log_function('LOOP #2: Entered for loop at line 24-36\\n')\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        log_function('LOOP #3: Entered for loop at line 27-34\\n')\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n          continue\n        if prevNum != -1:\n          log_function('BRANCH #3: Covered if branch at line 32-33\\n')\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Absolute Difference Queries.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 27-34\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 27-34\n", "BRANCH #2: Covered if branch at line 30-31\n"], ["LOOP #3: Entered for loop at line 27-34\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 27-34\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 27-34\n"]], "sampled_condition_paths": [["Line 30: (i == len(indices) or indices[i] > r)", "Line 27: (num in range(1, 101))", "Line 30: (i == len(indices) or indices[i] > r)", "Line 27: (num in range(1, 101))", "Line 30: (i == len(indices) or indices[i] > r)"], ["Line 27: (num in range(1, 101))", "Line 30: (i == len(indices) or indices[i] > r)", "Line 27: (num in range(1, 101))", "Line 30: (i == len(indices) or indices[i] > r)", "Line 27: (num in range(1, 101))"]]}
{"task_num": 1923, "task_title": "Longest Common Subpath", "difficulty": 3, "func_name": "longestCommonSubpath", "description": "There is a country of `n` cities numbered from `0` to `n - 1`. In this\ncountry, there is a road connecting every pair of cities.\n\nThere are `m` friends numbered from `0` to `m - 1` who are traveling through\nthe country. Each one of them will take a path consisting of some cities. Each\npath is represented by an integer array that contains the visited cities in\norder. The path may contain a city more than once, but the same city will not\nbe listed consecutively.\n\nGiven an integer `n` and a 2D integer array `paths` where `paths[i]` is an\ninteger array representing the path of the `ith` friend, return the length of\nthe longest common subpath that is shared by every friend's path, or `0` if\nthere is no common subpath at all.\n\nA subpath of a path is a contiguous sequence of cities within that path.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 46, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 47, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 25, 34, 46, 48, 50], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      log_function('LOOP #1: Entered while loop at line 20-26\\n')\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        log_function('BRANCH #1: Covered if branch at line 22-23\\n')\n        l = m\n      else:\n        log_function('BRANCH #2: Covered else branch at line 24-25\\n')\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      log_function('LOOP #2: Entered for loop at line 32-35\\n')\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        log_function('BRANCH #3: Covered if branch at line 33-34\\n')\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      log_function('LOOP #3: Entered for loop at line 43-51\\n')\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        log_function('BRANCH #4: Covered if branch at line 45-46\\n')\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        log_function('BRANCH #5: Covered else branch at line 47-48\\n')\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        log_function('BRANCH #6: Covered if branch at line 49-50\\n')\n        hashes.add(hash)\n\n    return hashes\n\ndef log_function(info_str):\n    with open(\"test_logs/Longest Common Subpath.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #6: Covered if branch at line 49-50\n", "LOOP #3: Entered for loop at line 43-51\n", "BRANCH #4: Covered if branch at line 45-46\n", "BRANCH #6: Covered if branch at line 49-50\n", "LOOP #2: Entered for loop at line 32-35\n"], ["BRANCH #4: Covered if branch at line 45-46\n", "BRANCH #6: Covered if branch at line 49-50\n", "LOOP #3: Entered for loop at line 43-51\n", "BRANCH #4: Covered if branch at line 45-46\n", "BRANCH #6: Covered if branch at line 49-50\n"], ["BRANCH #4: Covered if branch at line 45-46\n", "BRANCH #6: Covered if branch at line 49-50\n", "LOOP #3: Entered for loop at line 43-51\n", "BRANCH #5: Covered else branch at line 47-48\n", "LOOP #3: Entered for loop at line 43-51\n"], ["BRANCH #6: Covered if branch at line 49-50\n", "LOOP #3: Entered for loop at line 43-51\n", "BRANCH #5: Covered else branch at line 47-48\n", "BRANCH #6: Covered if branch at line 49-50\n", "LOOP #2: Entered for loop at line 32-35\n"], ["LOOP #3: Entered for loop at line 43-51\n", "BRANCH #5: Covered else branch at line 47-48\n", "BRANCH #6: Covered if branch at line 49-50\n", "LOOP #3: Entered for loop at line 43-51\n", "BRANCH #5: Covered else branch at line 47-48\n"]], "sampled_condition_paths": [["Line 49: (i >= m - 1)", "Line 43: (i, num in enumerate(path))", "Line 45: (i >= m)", "Line 49: (i >= m - 1)", "Line 32: (subpathHash in hashSets[0])"], ["Line 45: (i >= m)", "Line 49: (i >= m - 1)", "Line 43: (i, num in enumerate(path))", "Line 45: (i >= m)", "Line 49: (i >= m - 1)"], ["Line 45: (i >= m)", "Line 49: (i >= m - 1)", "Line 43: (i, num in enumerate(path))", "Line 45: NOT (i >= m)", "Line 47: ", "Line 43: (i, num in enumerate(path))"], ["Line 49: (i >= m - 1)", "Line 43: (i, num in enumerate(path))", "Line 45: NOT (i >= m)", "Line 47: ", "Line 49: (i >= m - 1)", "Line 32: (subpathHash in hashSets[0])"], ["Line 43: (i, num in enumerate(path))", "Line 45: NOT (i >= m)", "Line 47: ", "Line 49: (i >= m - 1)", "Line 43: (i, num in enumerate(path))", "Line 45: NOT (i >= m)", "Line 47: "]]}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "difficulty": 2, "func_name": "nearestExit", "description": "You are given an `m x n` matrix `maze` (0-indexed) with empty cells\n(represented as `'.'`) and walls (represented as `'+'`). You are also given\nthe `entrance` of the maze, where `entrance = [entrancerow, entrancecol]`\ndenotes the row and column of the cell you are initially standing at.\n\nIn one step, you can move one cell up, down, left, or right. You cannot step\ninto a cell with a wall, and you cannot step outside the maze. Your goal is to\nfind the nearest exit from the `entrance`. An exit is defined as an empty cell\nthat is at the border of the `maze`. The `entrance` does not count as an exit.\n\nReturn the number of steps in the shortest path from the `entrance` to the\nnearest exit, or `-1` if no such path exists.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.12244897959183673}, {"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.9081632653061225}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.5204081632653061}], "target_lines": [28, 30, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      log_function('LOOP #1: Entered while loop at line 20-35\\n')\n      ans += 1\n      for _ in range(len(q)):\n        log_function('LOOP #2: Entered for loop at line 22-35\\n')\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          log_function('LOOP #3: Entered for loop at line 24-35\\n')\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            log_function('BRANCH #1: Covered if branch at line 27-28\\n')\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            log_function('BRANCH #2: Covered if branch at line 29-30\\n')\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            log_function('BRANCH #3: Covered if branch at line 31-32\\n')\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Nearest Exit from Entrance in Maze.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 24-35\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 24-35\n", "BRANCH #2: Covered if branch at line 29-30\n", "LOOP #1: Entered while loop at line 20-35\n"], ["LOOP #3: Entered for loop at line 24-35\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 24-35\n", "BRANCH #2: Covered if branch at line 29-30\n", "LOOP #3: Entered for loop at line 24-35\n"], ["LOOP #3: Entered for loop at line 24-35\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 24-35\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 24-35\n"], ["BRANCH #1: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 24-35\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 24-35\n", "BRANCH #1: Covered if branch at line 27-28\n"], ["LOOP #2: Entered for loop at line 22-35\n", "LOOP #3: Entered for loop at line 24-35\n", "LOOP #3: Entered for loop at line 24-35\n", "BRANCH #2: Covered if branch at line 29-30\n", "LOOP #3: Entered for loop at line 24-35\n"], ["BRANCH #1: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 24-35\n", "BRANCH #2: Covered if branch at line 29-30\n", "LOOP #3: Entered for loop at line 24-35\n", "LOOP #3: Entered for loop at line 24-35\n"]], "sampled_condition_paths": [["Line 24: (dx, dy in dirs)", "Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)", "Line 29: ((x, y) in seen or maze[x][y] == '+')", "Line 20: (q)"], ["Line 24: (dx, dy in dirs)", "Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)", "Line 29: ((x, y) in seen or maze[x][y] == '+')", "Line 24: (dx, dy in dirs)"], ["Line 24: (dx, dy in dirs)", "Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)", "Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)"], ["Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)", "Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)", "Line 27: (x < 0 or x == m or y < 0 or y == n)"], ["Line 22: (_ in range(len(q)))", "Line 24: (dx, dy in dirs)", "Line 24: (dx, dy in dirs)", "Line 29: ((x, y) in seen or maze[x][y] == '+')", "Line 24: (dx, dy in dirs)"], ["Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)", "Line 29: ((x, y) in seen or maze[x][y] == '+')", "Line 24: (dx, dy in dirs)", "Line 24: (dx, dy in dirs)"]]}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "difficulty": 3, "func_name": "minCost", "description": "There is a country of `n` cities numbered from `0` to `n - 1` where all the\ncities are connected by bi-directional roads. The roads are represented as a\n2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road\nbetween cities `xi` and `yi` that takes `timei` minutes to travel. There may\nbe multiple roads of differing travel times connecting the same two cities,\nbut no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is\nrepresented as a 0-indexed integer array `passingFees` of length `n` where\n`passingFees[j]` is the amount of dollars you must pay when you pass through\ncity `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in\n`maxTime` minutes or less. The cost of your journey is the summation of\npassing fees for each city that you passed through at some moment of your\njourney (including the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return the minimum cost to\ncomplete your journey, or `-1` if you cannot complete it within `maxTime`\nminutes.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "blocks": [{"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.09183673469387756}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.01020408163265306}, {"type": "if", "start": 37, "end": 38, "difficulty": 1, "eg_cov_prob": 0.9081632653061225}, {"type": "if", "start": 39, "end": 42, "difficulty": 1, "eg_cov_prob": 0.6938775510204082}, {"type": "if", "start": 43, "end": 45, "difficulty": 2, "eg_cov_prob": 0.061224489795918366}], "target_lines": [33, 35, 38, 40, 41, 42, 44, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      log_function('LOOP #1: Entered for loop at line 16-19\\n')\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      log_function('LOOP #2: Entered while loop at line 30-46\\n')\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        log_function('BRANCH #1: Covered if branch at line 32-33\\n')\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        log_function('BRANCH #2: Covered if branch at line 34-35\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #3: Entered for loop at line 36-46\\n')\n        if d + w > maxTime:\n          log_function('BRANCH #3: Covered if branch at line 37-38\\n')\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          log_function('BRANCH #4: Covered if branch at line 39-42\\n')\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          log_function('BRANCH #5: Covered elif branch at line 43-45\\n')\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Cost to Reach Destination in Time.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 30-46\n", "LOOP #3: Entered for loop at line 36-46\n", "LOOP #3: Entered for loop at line 36-46\n", "BRANCH #4: Covered if branch at line 39-42\n", "LOOP #2: Entered while loop at line 30-46\n"], ["BRANCH #3: Covered if branch at line 37-38\n", "LOOP #2: Entered while loop at line 30-46\n", "LOOP #3: Entered for loop at line 36-46\n", "LOOP #3: Entered for loop at line 36-46\n", "BRANCH #4: Covered if branch at line 39-42\n"], ["LOOP #3: Entered for loop at line 36-46\n", "BRANCH #4: Covered if branch at line 39-42\n", "LOOP #3: Entered for loop at line 36-46\n", "BRANCH #4: Covered if branch at line 39-42\n", "LOOP #2: Entered while loop at line 30-46\n"], ["LOOP #3: Entered for loop at line 36-46\n", "LOOP #3: Entered for loop at line 36-46\n", "BRANCH #4: Covered if branch at line 39-42\n", "LOOP #2: Entered while loop at line 30-46\n", "LOOP #3: Entered for loop at line 36-46\n"], ["BRANCH #4: Covered if branch at line 39-42\n", "LOOP #2: Entered while loop at line 30-46\n", "LOOP #3: Entered for loop at line 36-46\n", "BRANCH #3: Covered if branch at line 37-38\n", "LOOP #3: Entered for loop at line 36-46\n"], ["BRANCH #4: Covered if branch at line 39-42\n", "LOOP #2: Entered while loop at line 30-46\n", "LOOP #3: Entered for loop at line 36-46\n", "LOOP #3: Entered for loop at line 36-46\n", "BRANCH #4: Covered if branch at line 39-42\n"]], "sampled_condition_paths": [["Line 30: (minHeap)", "Line 36: (v, w in graph[u])", "Line 36: (v, w in graph[u])", "Line 39: (currCost + passingFees[v] < cost[v])", "Line 30: (minHeap)"], ["Line 37: (d + w > maxTime)", "Line 30: (minHeap)", "Line 36: (v, w in graph[u])", "Line 36: (v, w in graph[u])", "Line 39: (currCost + passingFees[v] < cost[v])"], ["Line 36: (v, w in graph[u])", "Line 39: (currCost + passingFees[v] < cost[v])", "Line 36: (v, w in graph[u])", "Line 39: (currCost + passingFees[v] < cost[v])", "Line 30: (minHeap)"], ["Line 36: (v, w in graph[u])", "Line 36: (v, w in graph[u])", "Line 39: (currCost + passingFees[v] < cost[v])", "Line 30: (minHeap)", "Line 36: (v, w in graph[u])"], ["Line 39: (currCost + passingFees[v] < cost[v])", "Line 30: (minHeap)", "Line 36: (v, w in graph[u])", "Line 37: (d + w > maxTime)", "Line 36: (v, w in graph[u])"], ["Line 39: (currCost + passingFees[v] < cost[v])", "Line 30: (minHeap)", "Line 36: (v, w in graph[u])", "Line 36: (v, w in graph[u])", "Line 39: (currCost + passingFees[v] < cost[v])"]]}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "difficulty": 3, "func_name": "maxGeneticDifference", "description": "There is a rooted tree consisting of `n` nodes numbered `0` to `n - 1`. Each\nnode's number denotes its unique genetic value (i.e. the genetic value of node\n`x` is `x`). The genetic difference between two genetic values is defined as\nthe bitwise-XOR of their values. You are given the integer array `parents`,\nwhere `parents[i]` is the parent for node `i`. If node `x` is the root of the\ntree, then `parents[x] == -1`.\n\nYou are also given the array `queries` where `queries[i] = [nodei, vali]`. For\neach query `i`, find the maximum genetic difference between `vali` and `pi`,\nwhere `pi` is the genetic value of any node that is on the path between\n`nodei` and the root (including `nodei` and the root). More formally, you want\nto maximize `vali XOR pi`.\n\nReturn an array `ans` where `ans[i]` is the answer to the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 39, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "else", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 55, "end": 56, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 57, "end": 58, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 38, 39, 41, 56, 58], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      log_function('LOOP #1: Entered for loop at line 24-30\\n')\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      log_function('LOOP #2: Entered for loop at line 34-41\\n')\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        log_function('BRANCH #2: Covered if branch at line 37-39\\n')\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        log_function('BRANCH #3: Covered else branch at line 40-41\\n')\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      log_function('LOOP #3: Entered for loop at line 54-59\\n')\n      if parent == -1:\n        log_function('BRANCH #4: Covered if branch at line 55-56\\n')\n        rootVal = i\n      else:\n        log_function('BRANCH #5: Covered else branch at line 57-58\\n')\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      log_function('LOOP #4: Entered for loop at line 60-62\\n')\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        log_function('LOOP #5: Entered for loop at line 66-68\\n')\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        log_function('LOOP #6: Entered for loop at line 69-71\\n')\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Genetic Difference Query.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 34-41\n", "BRANCH #3: Covered else branch at line 40-41\n", "LOOP #2: Entered for loop at line 34-41\n", "BRANCH #3: Covered else branch at line 40-41\n", "LOOP #2: Entered for loop at line 34-41\n"], ["BRANCH #3: Covered else branch at line 40-41\n", "LOOP #2: Entered for loop at line 34-41\n", "BRANCH #3: Covered else branch at line 40-41\n", "LOOP #2: Entered for loop at line 34-41\n", "BRANCH #3: Covered else branch at line 40-41\n"], ["LOOP #1: Entered for loop at line 24-30\n", "LOOP #1: Entered for loop at line 24-30\n", "LOOP #1: Entered for loop at line 24-30\n", "LOOP #1: Entered for loop at line 24-30\n", "LOOP #1: Entered for loop at line 24-30\n"]], "sampled_condition_paths": [["Line 34: (i in range(self.kHeight, -1, -1))", "Line 37: NOT (node.children[targetBit] and node.children[targetBit].count > 0)", "Line 40: ", "Line 34: (i in range(self.kHeight, -1, -1))", "Line 37: NOT (node.children[targetBit] and node.children[targetBit].count > 0)", "Line 40: ", "Line 34: (i in range(self.kHeight, -1, -1))"], ["Line 37: NOT (node.children[targetBit] and node.children[targetBit].count > 0)", "Line 40: ", "Line 34: (i in range(self.kHeight, -1, -1))", "Line 37: NOT (node.children[targetBit] and node.children[targetBit].count > 0)", "Line 40: ", "Line 34: (i in range(self.kHeight, -1, -1))", "Line 37: NOT (node.children[targetBit] and node.children[targetBit].count > 0)", "Line 40: "], ["Line 24: (i in range(self.kHeight, -1, -1))", "Line 24: (i in range(self.kHeight, -1, -1))", "Line 24: (i in range(self.kHeight, -1, -1))", "Line 24: (i in range(self.kHeight, -1, -1))", "Line 24: (i in range(self.kHeight, -1, -1))"]]}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "difficulty": 1, "func_name": "validPath", "description": "There is a bi-directional graph with `n` vertices, where each vertex is\nlabeled from `0` to `n - 1` (inclusive). The edges in the graph are\nrepresented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]`\ndenotes a bi-directional edge between vertex `ui` and vertex `vi`. Every\nvertex pair is connected by at most one edge, and no vertex has an edge to\nitself.\n\nYou want to determine if there is a valid path that exists from vertex\n`source` to vertex `destination`.\n\nGiven `edges` and the integers `n`, `source`, and `destination`, return `true`\nif there is a valid path from `source` to `destination`, or `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.7653061224489796}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 30-31\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 39-41\\n')\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n\ndef log_function(info_str):\n    with open(\"test_logs/Find if Path Exists in Graph.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #1: Entered for loop at line 39-41\n", "BRANCH #4: Covered else branch at line 25-27\n", "LOOP #1: Entered for loop at line 39-41\n", "BRANCH #3: Covered elif branch at line 23-24\n"], ["LOOP #1: Entered for loop at line 39-41\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #1: Covered if branch at line 19-20\n", "BRANCH #5: Covered if branch at line 30-31\n"], ["LOOP #1: Entered for loop at line 39-41\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #1: Entered for loop at line 39-41\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #5: Covered if branch at line 30-31\n"]], "sampled_condition_paths": [["Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 39: (u, v in edges)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 39: (u, v in edges)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])"], ["Line 39: (u, v in edges)", "Line 30: (self.id[u] != u)", "Line 30: (self.id[u] != u)", "Line 19: (i == j)", "Line 30: (self.id[u] != u)"], ["Line 39: (u, v in edges)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 39: (u, v in edges)", "Line 30: (self.id[u] != u)", "Line 30: (self.id[u] != u)"]]}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "difficulty": 2, "func_name": "countPaths", "description": "You are in a city that consists of `n` intersections numbered from `0` to `n -\n1` with bi-directional roads between some intersections. The inputs are\ngenerated such that you can reach any intersection from any other intersection\nand that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] =\n[ui, vi, timei]` means that there is a road between intersections `ui` and\n`vi` that takes `timei` minutes to travel. You want to know in how many ways\nyou can travel from intersection `0` to intersection `n - 1` in the shortest\namount of time.\n\nReturn the number of ways you can arrive at your destination in the shortest\namount of time. Since the answer may be large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "blocks": [{"type": "if", "start": 32, "end": 33, "difficulty": 1, "eg_cov_prob": 0.9897959183673469}, {"type": "if", "start": 35, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 41, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [33, 36, 37, 38, 40, 41], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      log_function('LOOP #1: Entered for loop at line 15-18\\n')\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      log_function('LOOP #2: Entered while loop at line 30-42\\n')\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        log_function('BRANCH #1: Covered if branch at line 32-33\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #3: Entered for loop at line 34-42\\n')\n        if d + w < dist[v]:\n          log_function('BRANCH #2: Covered if branch at line 35-38\\n')\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          log_function('BRANCH #3: Covered elif branch at line 39-41\\n')\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Ways to Arrive at Destination.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 30-42\n", "LOOP #3: Entered for loop at line 34-42\n", "BRANCH #2: Covered if branch at line 35-38\n", "LOOP #2: Entered while loop at line 30-42\n", "LOOP #3: Entered for loop at line 34-42\n"], ["LOOP #3: Entered for loop at line 34-42\n", "BRANCH #2: Covered if branch at line 35-38\n", "LOOP #3: Entered for loop at line 34-42\n", "BRANCH #2: Covered if branch at line 35-38\n", "LOOP #2: Entered while loop at line 30-42\n"], ["LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #2: Entered while loop at line 30-42\n"]], "sampled_condition_paths": [["Line 30: (minHeap)", "Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v])", "Line 30: (minHeap)", "Line 34: (v, w in graph[u])"], ["Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v])", "Line 34: (v, w in graph[u])", "Line 35: (d + w < dist[v])", "Line 30: (minHeap)"], ["Line 15: (u, v, w in roads)", "Line 15: (u, v, w in roads)", "Line 15: (u, v, w in roads)", "Line 15: (u, v, w in roads)", "Line 30: (minHeap)"]]}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "difficulty": 3, "func_name": "numberOfCombinations", "description": "You wrote down many positive integers in a string called `num`. However, you\nrealized that you forgot to add commas to seperate the different numbers. You\nremember that the list of integers was non-decreasing and that no integer had\nleading zeros.\n\nReturn the number of possible lists of integers that you could have written\ndown to get the string `num`. Since the answer may be large, return it modulo\n`109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.10204081632653061}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "if", "start": 33, "end": 35, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "if", "start": 36, "end": 38, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "if", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "else", "start": 42, "end": 43, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}], "target_lines": [14, 24, 32, 34, 35, 37, 38, 41, 43], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      log_function('LOOP #1: Entered for loop at line 21-25\\n')\n      for j in range(i + 1, n):\n        log_function('LOOP #2: Entered for loop at line 22-25\\n')\n        if num[i] == num[j]:\n          log_function('BRANCH #2: Covered if branch at line 23-24\\n')\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      log_function('LOOP #3: Entered for loop at line 26-44\\n')\n      for k in range(1, i + 2):\n        log_function('LOOP #4: Entered for loop at line 27-44\\n')\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          log_function('BRANCH #3: Covered if branch at line 31-32\\n')\n          continue\n        if s == 0:\n          log_function('BRANCH #4: Covered if branch at line 33-35\\n')\n          dp[i][k] += 1\n          continue\n        if s < k:\n          log_function('BRANCH #5: Covered if branch at line 36-38\\n')\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          log_function('BRANCH #6: Covered if branch at line 40-41\\n')\n          dp[i][k] += dp[s - 1][k]\n        else:\n          log_function('BRANCH #7: Covered else branch at line 42-43\\n')\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Ways to Separate Numbers.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #4: Covered if branch at line 33-35\n", "LOOP #3: Entered for loop at line 26-44\n", "LOOP #4: Entered for loop at line 27-44\n", "BRANCH #7: Covered else branch at line 42-43\n", "LOOP #4: Entered for loop at line 27-44\n"], ["BRANCH #1: Covered if branch at line 13-14\n"], ["LOOP #4: Entered for loop at line 27-44\n", "BRANCH #7: Covered else branch at line 42-43\n", "LOOP #4: Entered for loop at line 27-44\n", "BRANCH #4: Covered if branch at line 33-35\n", "LOOP #3: Entered for loop at line 26-44\n"]], "sampled_condition_paths": [["Line 33: (s == 0)", "Line 26: (i in range(n))", "Line 27: (k in range(1, i + 2))", "Line 40: NOT (l >= k or num[s - k + l] <= num[s + l])", "Line 42: ", "Line 27: (k in range(1, i + 2))"], ["Line 13: (num[0] == '0')"], ["Line 27: (k in range(1, i + 2))", "Line 40: NOT (l >= k or num[s - k + l] <= num[s + l])", "Line 42: ", "Line 27: (k in range(1, i + 2))", "Line 33: (s == 0)", "Line 26: (i in range(n))"]]}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "difficulty": 3, "func_name": "numberOfGoodSubsets", "description": "You are given an integer array `nums`. We call a subset of `nums` good if its\nproduct can be represented as a product of one or more distinct prime numbers.\n\n* For example, if `nums = [1, 2, 3, 4]`: \n* `[2, 3]`, `[1, 2, 3]`, and `[1, 3]` are good subsets with products `6 = 2*3`, `6 = 2*3`, and `3 = 3` respectively.\n* `[1, 4]` and `[4]` are not good subsets with products `4 = 2*2` and `4 = 2*2` respectively.\n\nReturn the number of different good subsets in `nums` modulo `109 + 7`.\n\nA subset of `nums` is any array that can be obtained by deleting some\n(possibly none or all) elements from `nums`. Two subsets are different if and\nonly if the chosen indices to delete are different.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 23, 27, 30], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      log_function('LOOP #1: Entered for loop at line 19-34\\n')\n      if num == 1:\n        log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        log_function('BRANCH #2: Covered if branch at line 22-23\\n')\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        log_function('LOOP #2: Entered for loop at line 25-27\\n')\n        if num % prime == 0:\n          log_function('BRANCH #3: Covered if branch at line 26-27\\n')\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        log_function('LOOP #3: Entered for loop at line 28-34\\n')\n        if primesMask & numPrimesMask > 0:\n          log_function('BRANCH #4: Covered if branch at line 29-30\\n')\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n\ndef log_function(info_str):\n    with open(\"test_logs/The Number of Good Subsets.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 28-34\n", "BRANCH #4: Covered if branch at line 29-30\n", "LOOP #3: Entered for loop at line 28-34\n", "LOOP #3: Entered for loop at line 28-34\n", "BRANCH #4: Covered if branch at line 29-30\n"], ["LOOP #3: Entered for loop at line 28-34\n", "LOOP #3: Entered for loop at line 28-34\n", "BRANCH #4: Covered if branch at line 29-30\n", "LOOP #3: Entered for loop at line 28-34\n", "LOOP #3: Entered for loop at line 28-34\n"]], "sampled_condition_paths": [["Line 28: (primesMask in range(n))", "Line 29: (primesMask & numPrimesMask > 0)", "Line 28: (primesMask in range(n))", "Line 28: (primesMask in range(n))", "Line 29: (primesMask & numPrimesMask > 0)"], ["Line 28: (primesMask in range(n))", "Line 28: (primesMask in range(n))", "Line 29: (primesMask & numPrimesMask > 0)", "Line 28: (primesMask in range(n))", "Line 28: (primesMask in range(n))"]]}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "difficulty": 3, "func_name": "gcdSort", "description": "You are given an integer array `nums`, and you can perform the following\noperation any number of times on `nums`:\n\n* Swap the positions of two elements `nums[i]` and `nums[j]` if `gcd(nums[i], nums[j]) > 1` where `gcd(nums[i], nums[j])` is the greatest common divisor of `nums[i]` and `nums[j]`.\n\nReturn `true` if it is possible to sort `nums` in non-decreasing order using\nthe above swap method, or `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 55, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 32, 48, 56, 57], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return False\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 31-32\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      log_function('LOOP #1: Entered for loop at line 42-45\\n')\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        log_function('LOOP #2: Entered for loop at line 43-45\\n')\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      log_function('LOOP #3: Entered for loop at line 46-49\\n')\n      if uf.find(a) != uf.find(b):\n        log_function('BRANCH #6: Covered if branch at line 47-48\\n')\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      log_function('LOOP #4: Entered for loop at line 54-57\\n')\n      if minPrimeFactors[i] == i:\n        log_function('BRANCH #7: Covered if branch at line 55-57\\n')\n        for j in range(i * i, n, i):\n          log_function('LOOP #5: Entered for loop at line 56-57\\n')\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      log_function('LOOP #6: Entered while loop at line 62-66\\n')\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        log_function('LOOP #7: Entered while loop at line 65-66\\n')\n        num //= divisor\n    return primeFactors\n\ndef log_function(info_str):\n    with open(\"test_logs/GCD Sort of an Array.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #6: Entered while loop at line 62-66\n", "LOOP #7: Entered while loop at line 65-66\n", "LOOP #7: Entered while loop at line 65-66\n", "LOOP #2: Entered for loop at line 43-45\n", "BRANCH #4: Covered else branch at line 25-27\n"], ["LOOP #5: Entered for loop at line 56-57\n", "LOOP #5: Entered for loop at line 56-57\n", "LOOP #4: Entered for loop at line 54-57\n", "BRANCH #7: Covered if branch at line 55-57\n", "LOOP #5: Entered for loop at line 56-57\n"], ["LOOP #6: Entered while loop at line 62-66\n", "LOOP #7: Entered while loop at line 65-66\n", "LOOP #2: Entered for loop at line 43-45\n", "BRANCH #1: Covered if branch at line 19-20\n", "LOOP #3: Entered for loop at line 46-49\n"], ["LOOP #2: Entered for loop at line 43-45\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #1: Entered for loop at line 42-45\n", "LOOP #6: Entered while loop at line 62-66\n"], ["LOOP #5: Entered for loop at line 56-57\n", "LOOP #1: Entered for loop at line 42-45\n", "LOOP #6: Entered while loop at line 62-66\n", "LOOP #7: Entered while loop at line 65-66\n", "LOOP #2: Entered for loop at line 43-45\n"], ["BRANCH #5: Covered if branch at line 31-32\n", "LOOP #3: Entered for loop at line 46-49\n", "BRANCH #5: Covered if branch at line 31-32\n", "BRANCH #5: Covered if branch at line 31-32\n", "LOOP #3: Entered for loop at line 46-49\n"]], "sampled_condition_paths": [["Line 62: (num > 1)", "Line 65: (num % divisor == 0)", "Line 65: (num % divisor == 0)", "Line 43: (primeFactor in self._getPrimeFactors(num, minPrimeFactors))", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: "], ["Line 56: (j in range(i * i, n, i))", "Line 56: (j in range(i * i, n, i))", "Line 54: (i in range(2, int(n**0.5) + 1))", "Line 55: (minPrimeFactors[i] == i)", "Line 56: (j in range(i * i, n, i))"], ["Line 62: (num > 1)", "Line 65: (num % divisor == 0)", "Line 43: (primeFactor in self._getPrimeFactors(num, minPrimeFactors))", "Line 19: (i == j)", "Line 46: (a, b in zip(nums, sorted(nums)))"], ["Line 43: (primeFactor in self._getPrimeFactors(num, minPrimeFactors))", "Line 31: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 42: (num in nums)", "Line 62: (num > 1)"], ["Line 56: (j in range(i * i, n, i))", "Line 42: (num in nums)", "Line 62: (num > 1)", "Line 65: (num % divisor == 0)", "Line 43: (primeFactor in self._getPrimeFactors(num, minPrimeFactors))"], ["Line 31: (self.id[u] != u)", "Line 46: (a, b in zip(nums, sorted(nums)))", "Line 31: (self.id[u] != u)", "Line 31: (self.id[u] != u)", "Line 46: (a, b in zip(nums, sorted(nums)))"]]}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "difficulty": 3, "func_name": "scoreOfStudents", "description": "You are given a string `s` that contains digits `0-9`, addition symbols `'+'`,\nand multiplication symbols `'*'` only, representing a valid math expression of\nsingle digit numbers (e.g., `3+5*2`). This expression was given to `n`\nelementary school students. The students were instructed to get the answer of\nthe expression by following this order of operations:\n\n1. Compute multiplication, reading from left to right; Then,\n2. Compute addition, reading from left to right.\n\nYou are given an integer array `answers` of length `n`, which are the\nsubmitted answers of the students in no particular order. You are asked to\ngrade the `answers`, by following these rules:\n\n* If an answer equals the correct answer of the expression, this student will be rewarded `5` points;\n* Otherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded `2` points;\n* Otherwise, this student will be rewarded `0` points.\n\nReturn the sum of the points of the students.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "blocks": [{"type": "if", "start": 36, "end": 37, "difficulty": 1, "eg_cov_prob": 0.7755102040816326}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.7346938775510204}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [31, 37, 39], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      log_function('LOOP #1: Entered for loop at line 19-21\\n')\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      log_function('LOOP #2: Entered for loop at line 22-32\\n')\n      for i in range(n - d):\n        log_function('LOOP #3: Entered for loop at line 23-32\\n')\n        j = i + d\n        for k in range(i, j):\n          log_function('LOOP #4: Entered for loop at line 25-32\\n')\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            log_function('LOOP #5: Entered for loop at line 27-32\\n')\n            for b in dp[k + 1][j]:\n              log_function('LOOP #6: Entered for loop at line 28-32\\n')\n              res = func[op](a, b)\n              if res <= 1000:\n                log_function('BRANCH #1: Covered if branch at line 30-31\\n')\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      log_function('LOOP #7: Entered for loop at line 35-40\\n')\n      if answer == correctAnswer:\n        log_function('BRANCH #2: Covered if branch at line 36-37\\n')\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        log_function('BRANCH #3: Covered elif branch at line 38-39\\n')\n        ans += 2 * freq\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/The Score of Students Solving Math Expression.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 23-32\n", "LOOP #4: Entered for loop at line 25-32\n", "LOOP #5: Entered for loop at line 27-32\n", "LOOP #6: Entered for loop at line 28-32\n", "BRANCH #1: Covered if branch at line 30-31\n"], ["LOOP #6: Entered for loop at line 28-32\n", "BRANCH #1: Covered if branch at line 30-31\n", "LOOP #3: Entered for loop at line 23-32\n", "LOOP #4: Entered for loop at line 25-32\n", "LOOP #5: Entered for loop at line 27-32\n"], ["BRANCH #1: Covered if branch at line 30-31\n", "LOOP #7: Entered for loop at line 35-40\n", "BRANCH #2: Covered if branch at line 36-37\n", "LOOP #7: Entered for loop at line 35-40\n", "LOOP #7: Entered for loop at line 35-40\n"], ["LOOP #2: Entered for loop at line 22-32\n", "LOOP #3: Entered for loop at line 23-32\n", "LOOP #4: Entered for loop at line 25-32\n", "LOOP #5: Entered for loop at line 27-32\n", "LOOP #6: Entered for loop at line 28-32\n"], ["LOOP #6: Entered for loop at line 28-32\n", "BRANCH #1: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 22-32\n", "LOOP #3: Entered for loop at line 23-32\n", "LOOP #4: Entered for loop at line 25-32\n"], ["LOOP #4: Entered for loop at line 25-32\n", "LOOP #5: Entered for loop at line 27-32\n", "LOOP #6: Entered for loop at line 28-32\n", "BRANCH #1: Covered if branch at line 30-31\n", "LOOP #4: Entered for loop at line 25-32\n"]], "sampled_condition_paths": [["Line 23: (i in range(n - d))", "Line 25: (k in range(i, j))", "Line 27: (a in dp[i][k])", "Line 28: (b in dp[k + 1][j])", "Line 30: (res <= 1000)"], ["Line 28: (b in dp[k + 1][j])", "Line 30: (res <= 1000)", "Line 23: (i in range(n - d))", "Line 25: (k in range(i, j))", "Line 27: (a in dp[i][k])"], ["Line 30: (res <= 1000)", "Line 35: (answer, freq in collections.Counter(answers).items())", "Line 36: (answer == correctAnswer)", "Line 35: (answer, freq in collections.Counter(answers).items())", "Line 35: (answer, freq in collections.Counter(answers).items())"], ["Line 22: (d in range(1, n))", "Line 23: (i in range(n - d))", "Line 25: (k in range(i, j))", "Line 27: (a in dp[i][k])", "Line 28: (b in dp[k + 1][j])"], ["Line 28: (b in dp[k + 1][j])", "Line 30: (res <= 1000)", "Line 22: (d in range(1, n))", "Line 23: (i in range(n - d))", "Line 25: (k in range(i, j))"], ["Line 25: (k in range(i, j))", "Line 27: (a in dp[i][k])", "Line 28: (b in dp[k + 1][j])", "Line 30: (res <= 1000)", "Line 25: (k in range(i, j))"]]}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "difficulty": 3, "func_name": "smallestSubsequence", "description": "You are given a string `s`, an integer `k`, a letter `letter`, and an integer\n`repetition`.\n\nReturn the lexicographically smallest subsequence of `s` of length `k` that\nhas the letter `letter` appear at least `repetition` times. The test cases are\ngenerated so that the `letter` appears in `s` at least `repetition` times.\n\nA subsequence is a string that can be derived from another string by deleting\nsome or no characters without changing the order of the remaining characters.\n\nA string `a` is lexicographically smaller than a string `b` if in the first\nposition where `a` and `b` differ, string `a` has a letter that appears\nearlier in the alphabet than the corresponding letter in `b`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "blocks": [{"type": "if", "start": 21, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.9795918367346939}, {"type": "if", "start": 22, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 23, 24, 25, 26, 28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      log_function('LOOP #1: Entered for loop at line 17-29\\n')\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        log_function('LOOP #2: Entered while loop at line 18-20\\n')\n        if stack.pop() == letter:\n          log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n          required += 1\n      if len(stack) < k:\n        log_function('BRANCH #2: Covered if branch at line 21-26\\n')\n        if c == letter:\n          log_function('BRANCH #3: Covered if branch at line 22-24\\n')\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          log_function('BRANCH #4: Covered elif branch at line 25-26\\n')\n          stack.append(c)\n      if c == letter:\n        log_function('BRANCH #5: Covered if branch at line 27-28\\n')\n        nLetters -= 1\n\n    return ''.join(stack)\n\ndef log_function(info_str):\n    with open(\"test_logs/Smallest K-Length Subsequence With Occurrences of a Letter.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 22-24\n", "BRANCH #5: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 17-29\n", "BRANCH #2: Covered if branch at line 21-26\n", "BRANCH #3: Covered if branch at line 22-24\n"], ["LOOP #1: Entered for loop at line 17-29\n", "BRANCH #2: Covered if branch at line 21-26\n", "BRANCH #3: Covered if branch at line 22-24\n", "BRANCH #5: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 17-29\n"], ["LOOP #1: Entered for loop at line 17-29\n", "BRANCH #2: Covered if branch at line 21-26\n", "BRANCH #4: Covered elif branch at line 25-26\n", "LOOP #1: Entered for loop at line 17-29\n", "LOOP #2: Entered while loop at line 18-20\n"], ["BRANCH #5: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 17-29\n", "BRANCH #2: Covered if branch at line 21-26\n", "BRANCH #3: Covered if branch at line 22-24\n", "BRANCH #5: Covered if branch at line 27-28\n"], ["BRANCH #2: Covered if branch at line 21-26\n", "BRANCH #3: Covered if branch at line 22-24\n", "BRANCH #5: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 17-29\n", "BRANCH #2: Covered if branch at line 21-26\n"]], "sampled_condition_paths": [["Line 22: (c == letter)", "Line 27: (c == letter)", "Line 17: (i, c in enumerate(s))", "Line 21: (len(stack) < k)", "Line 22: (c == letter)"], ["Line 17: (i, c in enumerate(s))", "Line 21: (len(stack) < k)", "Line 22: (c == letter)", "Line 27: (c == letter)", "Line 17: (i, c in enumerate(s))"], ["Line 17: (i, c in enumerate(s))", "Line 21: (len(stack) < k)", "Line 22: NOT (c == letter)", "Line 25: (k - len(stack) > required)", "Line 17: (i, c in enumerate(s))", "Line 18: (stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required))"], ["Line 27: (c == letter)", "Line 17: (i, c in enumerate(s))", "Line 21: (len(stack) < k)", "Line 22: (c == letter)", "Line 27: (c == letter)"], ["Line 21: (len(stack) < k)", "Line 22: (c == letter)", "Line 27: (c == letter)", "Line 17: (i, c in enumerate(s))", "Line 21: (len(stack) < k)"]]}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "difficulty": 3, "func_name": "kthSmallestProduct", "description": "Given two sorted 0-indexed integer arrays `nums1` and `nums2` as well as an\ninteger `k`, return the `kth` (1-based) smallest product of `nums1[i] *\nnums2[j]` where `0 <= i < nums1.length` and `0 <= j < nums2.length`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "blocks": [{"type": "if", "start": 20, "end": 22, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "else", "start": 23, "end": 26, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 22, 24, 25, 26, 43, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      log_function('BRANCH #1: Covered if branch at line 20-22\\n')\n      k -= negCount\n      sign = 1\n    else:\n      log_function('BRANCH #2: Covered else branch at line 23-26\\n')\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        log_function('LOOP #1: Entered for loop at line 31-34\\n')\n        while j >= 0 and A[i] * B[j] > m:\n          log_function('LOOP #2: Entered while loop at line 32-33\\n')\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      log_function('LOOP #3: Entered while loop at line 40-46\\n')\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        log_function('BRANCH #3: Covered if branch at line 42-43\\n')\n        r = m\n      else:\n        log_function('BRANCH #4: Covered else branch at line 44-45\\n')\n        l = m + 1\n\n    return sign * l\n\ndef log_function(info_str):\n    with open(\"test_logs/Kth Smallest Product of Two Sorted Arrays.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 31-34\n", "LOOP #1: Entered for loop at line 31-34\n", "BRANCH #3: Covered if branch at line 42-43\n", "LOOP #3: Entered while loop at line 40-46\n", "LOOP #1: Entered for loop at line 31-34\n"], ["LOOP #1: Entered for loop at line 31-34\n", "LOOP #1: Entered for loop at line 31-34\n", "LOOP #1: Entered for loop at line 31-34\n", "BRANCH #3: Covered if branch at line 42-43\n", "LOOP #3: Entered while loop at line 40-46\n"], ["BRANCH #3: Covered if branch at line 42-43\n", "LOOP #3: Entered while loop at line 40-46\n", "LOOP #1: Entered for loop at line 31-34\n", "LOOP #1: Entered for loop at line 31-34\n", "BRANCH #3: Covered if branch at line 42-43\n"]], "sampled_condition_paths": [["Line 31: (i in range(len(A)))", "Line 31: (i in range(len(A)))", "Line 42: (numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k)", "Line 40: (l < r)", "Line 31: (i in range(len(A)))"], ["Line 31: (i in range(len(A)))", "Line 31: (i in range(len(A)))", "Line 31: (i in range(len(A)))", "Line 42: (numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k)", "Line 40: (l < r)"], ["Line 42: (numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k)", "Line 40: (l < r)", "Line 31: (i in range(len(A)))", "Line 31: (i in range(len(A)))", "Line 42: (numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k)"]]}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "difficulty": 3, "func_name": "secondMinimum", "description": "A city is represented as a bi-directional connected graph with `n` vertices\nwhere each vertex is labeled from `1` to `n` (inclusive). The edges in the\ngraph are represented as a 2D integer array `edges`, where each `edges[i] =\n[ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`.\nEvery vertex pair is connected by at most one edge, and no vertex has an edge\nto itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from green to red and\nvice versa every `change` minutes. All signals change at the same time. You\ncan enter a vertex at any time, but can leave a vertex only when the signal is\ngreen. You cannot wait at a vertex if the signal is green.\n\nThe second minimum value is defined as the smallest value strictly larger than\nthe minimum value.\n\n* For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return the second minimum time it\nwill take to go from vertex `1` to vertex `n`.\n\nNotes:\n\n* You can go through any vertex any number of times, including `1` and `n`.\n* You can assume that when the journey starts, all signals have just turned green.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "blocks": [{"type": "if", "start": 29, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [30, 31, 33, 34, 35, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 18-21\\n')\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      log_function('LOOP #2: Entered while loop at line 22-37\\n')\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        log_function('LOOP #3: Entered for loop at line 28-37\\n')\n        if newTime < minTime[j][0]:\n          log_function('BRANCH #1: Covered if branch at line 29-31\\n')\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          log_function('BRANCH #2: Covered elif branch at line 32-36\\n')\n          if j == n:\n            log_function('BRANCH #3: Covered if branch at line 33-34\\n')\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n\ndef log_function(info_str):\n    with open(\"test_logs/Second Minimum Time to Reach Destination.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 18-21\n", "LOOP #1: Entered for loop at line 18-21\n", "LOOP #1: Entered for loop at line 18-21\n", "LOOP #2: Entered while loop at line 22-37\n", "LOOP #3: Entered for loop at line 28-37\n"], ["BRANCH #2: Covered elif branch at line 32-36\n", "LOOP #2: Entered while loop at line 22-37\n", "LOOP #3: Entered for loop at line 28-37\n", "BRANCH #2: Covered elif branch at line 32-36\n", "BRANCH #3: Covered if branch at line 33-34\n"], ["LOOP #2: Entered while loop at line 22-37\n", "LOOP #3: Entered for loop at line 28-37\n", "LOOP #3: Entered for loop at line 28-37\n", "BRANCH #2: Covered elif branch at line 32-36\n", "LOOP #2: Entered while loop at line 22-37\n"], ["LOOP #3: Entered for loop at line 28-37\n", "BRANCH #2: Covered elif branch at line 32-36\n", "LOOP #2: Entered while loop at line 22-37\n", "LOOP #3: Entered for loop at line 28-37\n", "BRANCH #2: Covered elif branch at line 32-36\n"]], "sampled_condition_paths": [["Line 18: (u, v in edges)", "Line 18: (u, v in edges)", "Line 18: (u, v in edges)", "Line 22: (q)", "Line 28: (j in graph[i])"], ["Line 29: NOT (newTime < minTime[j][0])", "Line 32: (minTime[j][0] < newTime < minTime[j][1])", "Line 22: (q)", "Line 28: (j in graph[i])", "Line 29: NOT (newTime < minTime[j][0])", "Line 32: (minTime[j][0] < newTime < minTime[j][1])", "Line 33: (j == n)"], ["Line 22: (q)", "Line 28: (j in graph[i])", "Line 28: (j in graph[i])", "Line 29: NOT (newTime < minTime[j][0])", "Line 32: (minTime[j][0] < newTime < minTime[j][1])", "Line 22: (q)"], ["Line 28: (j in graph[i])", "Line 29: NOT (newTime < minTime[j][0])", "Line 32: (minTime[j][0] < newTime < minTime[j][1])", "Line 22: (q)", "Line 28: (j in graph[i])", "Line 29: NOT (newTime < minTime[j][0])", "Line 32: (minTime[j][0] < newTime < minTime[j][1])"]]}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "difficulty": 2, "func_name": "minimumOperations", "description": "You are given a 0-indexed integer array `nums` containing distinct numbers, an\ninteger `start`, and an integer `goal`. There is an integer `x` that is\ninitially set to `start`, and you want to perform operations on `x` such that\nit is converted to `goal`. You can perform the following operation repeatedly\non the number `x`:\n\nIf `0 <= x <= 1000`, then for any index `i` in the array (`0 <= i <\nnums.length`), you can set `x` to any of the following:\n\n* `x + nums[i]`\n* `x - nums[i]`\n* `x ^ nums[i]` (bitwise-XOR)\n\nNote that you can use each `nums[i]` any number of times in any order.\nOperations that set `x` to be out of the range `0 <= x <= 1000` are valid, but\nno more operations can be done afterward.\n\nReturn the minimum number of operations needed to convert `x = start` into\n`goal`, and `-1` if it is not possible.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 26], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      log_function('LOOP #1: Entered while loop at line 17-29\\n')\n      ans += 1\n      for _ in range(len(q)):\n        log_function('LOOP #2: Entered for loop at line 19-29\\n')\n        x = q.popleft()\n        for num in nums:\n          log_function('LOOP #3: Entered for loop at line 21-29\\n')\n          for res in (x + num, x - num, x ^ num):\n            log_function('LOOP #4: Entered for loop at line 22-29\\n')\n            if res == goal:\n              log_function('BRANCH #1: Covered if branch at line 23-24\\n')\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Operations to Convert Number.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 22-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #3: Entered for loop at line 21-29\n", "LOOP #4: Entered for loop at line 22-29\n", "LOOP #4: Entered for loop at line 22-29\n"], ["LOOP #4: Entered for loop at line 22-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #4: Entered for loop at line 22-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #3: Entered for loop at line 21-29\n"], ["LOOP #4: Entered for loop at line 22-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #4: Entered for loop at line 22-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #2: Entered for loop at line 19-29\n"], ["LOOP #3: Entered for loop at line 21-29\n", "LOOP #4: Entered for loop at line 22-29\n", "LOOP #4: Entered for loop at line 22-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #4: Entered for loop at line 22-29\n"], ["BRANCH #2: Covered if branch at line 25-26\n", "LOOP #4: Entered for loop at line 22-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #1: Entered while loop at line 17-29\n", "LOOP #2: Entered for loop at line 19-29\n"], ["BRANCH #2: Covered if branch at line 25-26\n", "LOOP #3: Entered for loop at line 21-29\n", "LOOP #4: Entered for loop at line 22-29\n", "LOOP #4: Entered for loop at line 22-29\n", "BRANCH #2: Covered if branch at line 25-26\n"]], "sampled_condition_paths": [["Line 22: (res in (x + num, x - num, x ^ num))", "Line 25: (res < 0 or res > 1000 or res in seen)", "Line 21: (num in nums)", "Line 22: (res in (x + num, x - num, x ^ num))", "Line 22: (res in (x + num, x - num, x ^ num))"], ["Line 22: (res in (x + num, x - num, x ^ num))", "Line 25: (res < 0 or res > 1000 or res in seen)", "Line 22: (res in (x + num, x - num, x ^ num))", "Line 25: (res < 0 or res > 1000 or res in seen)", "Line 21: (num in nums)"], ["Line 22: (res in (x + num, x - num, x ^ num))", "Line 25: (res < 0 or res > 1000 or res in seen)", "Line 22: (res in (x + num, x - num, x ^ num))", "Line 25: (res < 0 or res > 1000 or res in seen)", "Line 19: (_ in range(len(q)))"], ["Line 21: (num in nums)", "Line 22: (res in (x + num, x - num, x ^ num))", "Line 22: (res in (x + num, x - num, x ^ num))", "Line 25: (res < 0 or res > 1000 or res in seen)", "Line 22: (res in (x + num, x - num, x ^ num))"], ["Line 25: (res < 0 or res > 1000 or res in seen)", "Line 22: (res in (x + num, x - num, x ^ num))", "Line 25: (res < 0 or res > 1000 or res in seen)", "Line 17: (q)", "Line 19: (_ in range(len(q)))"], ["Line 25: (res < 0 or res > 1000 or res in seen)", "Line 21: (num in nums)", "Line 22: (res in (x + num, x - num, x ^ num))", "Line 22: (res in (x + num, x - num, x ^ num))", "Line 25: (res < 0 or res > 1000 or res in seen)"]]}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "difficulty": 3, "func_name": "friendRequests", "description": "You are given an integer `n` indicating the number of people in a network.\nEach person is labeled from `0` to `n - 1`.\n\nYou are also given a 0-indexed 2D integer array `restrictions`, where\n`restrictions[i] = [xi, yi]` means that person `xi` and person `yi` cannot\nbecome friends, either directly or indirectly through other people.\n\nInitially, no one is friends with each other. You are given a list of friend\nrequests as a 0-indexed 2D integer array `requests`, where `requests[j] = [uj,\nvj]` is a friend request between person `uj` and person `vj`.\n\nA friend request is successful if `uj` and `vj` can be friends. Each friend\nrequest is processed in the given order (i.e., `requests[j]` occurs before\n`requests[j + 1]`), and upon a successful request, `uj` and `vj` become direct\nfriends for all future friend requests.\n\nReturn a boolean array `result`, where each `result[j]` is `true` if the `jth`\nfriend request is successful or `false` if it is not.\n\nNote: If `uj` and `vj` are already direct friends, the request is still\nsuccessful.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.826530612244898}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.9489795918367347}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.9693877551020408}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.9489795918367347}, {"type": "else", "start": 25, "end": 27, "difficulty": 1, "eg_cov_prob": 0.9693877551020408}, {"type": "if", "start": 44, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 1, "eg_cov_prob": 0.9693877551020408}, {"type": "if", "start": 48, "end": 50, "difficulty": 1, "eg_cov_prob": 0.9081632653061225}], "target_lines": [20, 22, 24, 26, 27, 31, 45, 46, 47, 48, 49, 50, 53], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 30-31\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      log_function('LOOP #1: Entered for loop at line 40-54\\n')\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        log_function('BRANCH #6: Covered if branch at line 44-50\\n')\n        for x, y in restrictions:\n          log_function('LOOP #2: Entered for loop at line 45-50\\n')\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            log_function('BRANCH #7: Covered if branch at line 48-50\\n')\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        log_function('BRANCH #8: Covered if branch at line 52-53\\n')\n        uf.unionByRank(pu, pv)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Process Restricted Friend Requests.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 40-54\n", "BRANCH #6: Covered if branch at line 44-50\n", "LOOP #2: Entered for loop at line 45-50\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #7: Covered if branch at line 48-50\n"], ["BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #6: Covered if branch at line 44-50\n", "LOOP #2: Entered for loop at line 45-50\n", "BRANCH #5: Covered if branch at line 30-31\n", "BRANCH #7: Covered if branch at line 48-50\n"], ["LOOP #2: Entered for loop at line 45-50\n", "LOOP #2: Entered for loop at line 45-50\n", "BRANCH #8: Covered if branch at line 52-53\n", "BRANCH #4: Covered else branch at line 25-27\n", "LOOP #1: Entered for loop at line 40-54\n"]], "sampled_condition_paths": [["Line 40: (u, v in requests)", "Line 44: (pu != pv)", "Line 45: (x, y in restrictions)", "Line 30: (self.id[u] != u)", "Line 48: ((pu, pv) in [(px, py), (py, px)])"], ["Line 30: (self.id[u] != u)", "Line 44: (pu != pv)", "Line 45: (x, y in restrictions)", "Line 30: (self.id[u] != u)", "Line 48: ((pu, pv) in [(px, py), (py, px)])"], ["Line 45: (x, y in restrictions)", "Line 45: (x, y in restrictions)", "Line 52: (isValid)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: NOT (self.rank[i] > self.rank[j])", "Line 25: ", "Line 40: (u, v in requests)"]]}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "difficulty": 2, "func_name": "minimumBuckets", "description": "You are given a 0-indexed string `hamsters` where `hamsters[i]` is either:\n\n* `'H'` indicating that there is a hamster at index `i`, or\n* `'.'` indicating that index `i` is empty.\n\nYou will add some number of food buckets at the empty indices in order to feed\nthe hamsters. A hamster can be fed if there is at least one food bucket to its\nleft or to its right. More formally, a hamster at index `i` can be fed if you\nplace a food bucket at index `i - 1` and/or at index `i + 1`.\n\nReturn the minimum number of food buckets you should place at empty indices to\nfeed all the hamsters or `-1` if it is impossible to feed all of them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "blocks": [{"type": "if", "start": 16, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 1, "eg_cov_prob": 0.5306122448979592}, {"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.6122448979591837}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.6632653061224489}, {"type": "else", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 18, 19, 20, 21, 22, 24], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      log_function('LOOP #1: Entered for loop at line 15-25\\n')\n      if c == 'H':\n        log_function('BRANCH #1: Covered if branch at line 16-24\\n')\n        if i > 0 and A[i - 1] == 'B':\n          log_function('BRANCH #2: Covered if branch at line 17-18\\n')\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          log_function('BRANCH #3: Covered if branch at line 19-20\\n')\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          log_function('BRANCH #4: Covered elif branch at line 21-22\\n')\n          A[i - 1] = 'B'\n        else:\n          log_function('BRANCH #5: Covered else branch at line 23-24\\n')\n          return -1\n\n    return A.count('B')\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Number of Food Buckets to Feed the Hamsters.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 15-25\n", "BRANCH #1: Covered if branch at line 16-24\n", "BRANCH #4: Covered elif branch at line 21-22\n", "LOOP #1: Entered for loop at line 15-25\n", "BRANCH #1: Covered if branch at line 16-24\n"], ["LOOP #1: Entered for loop at line 15-25\n", "LOOP #1: Entered for loop at line 15-25\n", "BRANCH #1: Covered if branch at line 16-24\n", "BRANCH #2: Covered if branch at line 17-18\n", "LOOP #1: Entered for loop at line 15-25\n"], ["BRANCH #3: Covered if branch at line 19-20\n", "LOOP #1: Entered for loop at line 15-25\n", "LOOP #1: Entered for loop at line 15-25\n", "LOOP #1: Entered for loop at line 15-25\n", "BRANCH #1: Covered if branch at line 16-24\n"], ["BRANCH #1: Covered if branch at line 16-24\n", "BRANCH #4: Covered elif branch at line 21-22\n", "LOOP #1: Entered for loop at line 15-25\n", "BRANCH #1: Covered if branch at line 16-24\n", "BRANCH #5: Covered else branch at line 23-24\n"]], "sampled_condition_paths": [["Line 15: (i, c in enumerate(A))", "Line 16: (c == 'H')", "Line 19: NOT (i + 1 < len(A) and A[i + 1] == '.')", "Line 21: (i > 0 and A[i - 1] == '.')", "Line 15: (i, c in enumerate(A))", "Line 16: (c == 'H')"], ["Line 15: (i, c in enumerate(A))", "Line 15: (i, c in enumerate(A))", "Line 16: (c == 'H')", "Line 17: (i > 0 and A[i - 1] == 'B')", "Line 15: (i, c in enumerate(A))"], ["Line 19: (i + 1 < len(A) and A[i + 1] == '.')", "Line 15: (i, c in enumerate(A))", "Line 15: (i, c in enumerate(A))", "Line 15: (i, c in enumerate(A))", "Line 16: (c == 'H')"], ["Line 16: (c == 'H')", "Line 19: NOT (i + 1 < len(A) and A[i + 1] == '.')", "Line 21: (i > 0 and A[i - 1] == '.')", "Line 15: (i, c in enumerate(A))", "Line 16: (c == 'H')", "Line 19: NOT (i + 1 < len(A) and A[i + 1] == '.')", "Line 21: NOT (i > 0 and A[i - 1] == '.')", "Line 23: "]]}
{"task_num": 2092, "task_title": "Find All People With Secret", "difficulty": 3, "func_name": "findAllPeople", "description": "You are given an integer `n` indicating there are `n` people numbered from `0`\nto `n - 1`. You are also given a 0-indexed 2D integer array `meetings` where\n`meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi`\nhave a meeting at `timei`. A person may attend multiple meetings at the same\ntime. Finally, you are given an integer `firstPerson`.\n\nPerson `0` has a secret and initially shares the secret with a person\n`firstPerson` at time `0`. This secret is then shared every time a meeting\ntakes place with a person that has the secret. More formally, for every\nmeeting, if a person `xi` has the secret at `timei`, then they will share the\nsecret with person `yi`, and vice versa.\n\nThe secrets are shared instantaneously. That is, a person may receive the\nsecret and share it with people in other meetings within the same time frame.\n\nReturn a list of all the people that have the secret after all the meetings\nhave taken place. You may return the answer in any order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.21428571428571427}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 1, "eg_cov_prob": 0.8163265306122449}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.9897959183673469}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 63, "end": 64, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 58, "end": 59, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 37, 59, 64], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 23-24\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 25-27\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 36-37\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      log_function('LOOP #1: Entered for loop at line 48-50\\n')\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      log_function('LOOP #2: Entered for loop at line 51-60\\n')\n      peopleUnioned = set()\n      for x, y in pairs:\n        log_function('LOOP #3: Entered for loop at line 53-56\\n')\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        log_function('LOOP #4: Entered for loop at line 57-60\\n')\n        if not uf.connected(person, 0):\n          log_function('BRANCH #6: Covered if branch at line 58-59\\n')\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      log_function('LOOP #5: Entered for loop at line 62-64\\n')\n      if uf.connected(i, 0):\n        log_function('BRANCH #7: Covered if branch at line 63-64\\n')\n        res.append(i)\n    return res\n\ndef log_function(info_str):\n    with open(\"test_logs/Find All People With Secret.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 57-60\n", "BRANCH #6: Covered if branch at line 58-59\n", "LOOP #2: Entered for loop at line 51-60\n", "LOOP #3: Entered for loop at line 53-56\n", "BRANCH #3: Covered elif branch at line 23-24\n"], ["BRANCH #7: Covered if branch at line 63-64\n", "LOOP #5: Entered for loop at line 62-64\n", "BRANCH #7: Covered if branch at line 63-64\n", "LOOP #5: Entered for loop at line 62-64\n", "LOOP #5: Entered for loop at line 62-64\n"], ["LOOP #4: Entered for loop at line 57-60\n", "LOOP #2: Entered for loop at line 51-60\n", "LOOP #3: Entered for loop at line 53-56\n", "BRANCH #5: Covered if branch at line 36-37\n", "BRANCH #3: Covered elif branch at line 23-24\n"], ["BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #4: Entered for loop at line 57-60\n", "LOOP #4: Entered for loop at line 57-60\n", "LOOP #4: Entered for loop at line 57-60\n", "LOOP #2: Entered for loop at line 51-60\n"], ["BRANCH #5: Covered if branch at line 36-37\n", "BRANCH #3: Covered elif branch at line 23-24\n", "LOOP #4: Entered for loop at line 57-60\n", "LOOP #4: Entered for loop at line 57-60\n", "LOOP #5: Entered for loop at line 62-64\n"]], "sampled_condition_paths": [["Line 57: (person in peopleUnioned)", "Line 58: (not uf.connected(person, 0))", "Line 51: (_, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]))", "Line 53: (x, y in pairs)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])"], ["Line 63: (uf.connected(i, 0))", "Line 62: (i in range(n))", "Line 63: (uf.connected(i, 0))", "Line 62: (i in range(n))", "Line 62: (i in range(n))"], ["Line 57: (person in peopleUnioned)", "Line 51: (_, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]))", "Line 53: (x, y in pairs)", "Line 36: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])"], ["Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 57: (person in peopleUnioned)", "Line 57: (person in peopleUnioned)", "Line 57: (person in peopleUnioned)", "Line 51: (_, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]))"], ["Line 36: (self.id[u] != u)", "Line 21: NOT (self.rank[i] < self.rank[j])", "Line 23: (self.rank[i] > self.rank[j])", "Line 57: (person in peopleUnioned)", "Line 57: (person in peopleUnioned)", "Line 62: (i in range(n))"]]}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "difficulty": 2, "func_name": "findAllRecipes", "description": "You have information about `n` different recipes. You are given a string array\n`recipes` and a 2D string array `ingredients`. The `ith` recipe has the name\n`recipes[i]`, and you can create it if you have all the needed ingredients\nfrom `ingredients[i]`. Ingredients to a recipe may need to be created from\nother recipes, i.e., `ingredients[i]` may contain a string that is in\n`recipes`.\n\nYou are also given a string array `supplies` containing all the ingredients\nthat you initially have, and you have an infinite supply of all of them.\n\nReturn a list of all the recipes that you can create. You may return the\nanswer in any order.\n\nNote that two recipes may contain each other in their ingredients.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [22, 23, 27, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      log_function('LOOP #1: Entered for loop at line 19-24\\n')\n      for ingredient in ingredients[i]:\n        log_function('LOOP #2: Entered for loop at line 20-24\\n')\n        if ingredient not in supplies:\n          log_function('BRANCH #1: Covered if branch at line 21-23\\n')\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      log_function('LOOP #3: Entered for loop at line 25-28\\n')\n      if inDegrees[recipe] == 0:\n        log_function('BRANCH #2: Covered if branch at line 26-27\\n')\n        q.append(recipe)\n\n    while q:\n      log_function('LOOP #4: Entered while loop at line 29-36\\n')\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        log_function('LOOP #5: Entered for loop at line 32-36\\n')\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          log_function('BRANCH #3: Covered if branch at line 34-35\\n')\n          q.append(v)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Find All Possible Recipes from Given Supplies.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 21-23\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #3: Entered for loop at line 25-28\n", "BRANCH #2: Covered if branch at line 26-27\n", "LOOP #3: Entered for loop at line 25-28\n"], ["LOOP #2: Entered for loop at line 20-24\n", "BRANCH #1: Covered if branch at line 21-23\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #3: Entered for loop at line 25-28\n", "BRANCH #2: Covered if branch at line 26-27\n"], ["LOOP #3: Entered for loop at line 25-28\n", "LOOP #4: Entered while loop at line 29-36\n", "LOOP #5: Entered for loop at line 32-36\n", "BRANCH #3: Covered if branch at line 34-35\n", "LOOP #5: Entered for loop at line 32-36\n"], ["LOOP #4: Entered while loop at line 29-36\n", "LOOP #5: Entered for loop at line 32-36\n", "BRANCH #3: Covered if branch at line 34-35\n", "LOOP #5: Entered for loop at line 32-36\n", "LOOP #4: Entered while loop at line 29-36\n"], ["LOOP #2: Entered for loop at line 20-24\n", "LOOP #2: Entered for loop at line 20-24\n", "LOOP #3: Entered for loop at line 25-28\n", "BRANCH #2: Covered if branch at line 26-27\n", "LOOP #4: Entered while loop at line 29-36\n"]], "sampled_condition_paths": [["Line 21: (ingredient not in supplies)", "Line 20: (ingredient in ingredients[i])", "Line 25: (recipe in recipes)", "Line 26: (inDegrees[recipe] == 0)", "Line 25: (recipe in recipes)"], ["Line 20: (ingredient in ingredients[i])", "Line 21: (ingredient not in supplies)", "Line 20: (ingredient in ingredients[i])", "Line 25: (recipe in recipes)", "Line 26: (inDegrees[recipe] == 0)"], ["Line 25: (recipe in recipes)", "Line 29: (q)", "Line 32: (v in graph[u])", "Line 34: (inDegrees[v] == 0)", "Line 32: (v in graph[u])"], ["Line 29: (q)", "Line 32: (v in graph[u])", "Line 34: (inDegrees[v] == 0)", "Line 32: (v in graph[u])", "Line 29: (q)"], ["Line 20: (ingredient in ingredients[i])", "Line 20: (ingredient in ingredients[i])", "Line 25: (recipe in recipes)", "Line 26: (inDegrees[recipe] == 0)", "Line 29: (q)"]]}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "difficulty": 3, "func_name": "maximumInvitations", "description": "A company is organizing a meeting and has a list of `n` employees, waiting to\nbe invited. They have arranged for a large circular table, capable of seating\nany number of employees.\n\nThe employees are numbered from `0` to `n - 1`. Each employee has a favorite\nperson and they will attend the meeting only if they can sit next to their\nfavorite person at the table. The favorite person of an employee is not\nthemself.\n\nGiven a 0-indexed integer array `favorite`, where `favorite[i]` denotes the\nfavorite person of the `ith` employee, return the maximum number of employees\nthat can be invited to the meeting.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "blocks": [{"type": "if", "start": 43, "end": 44, "difficulty": 2, "eg_cov_prob": 0.2641509433962264}, {"type": "if", "start": 69, "end": 70, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 56, "end": 58, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 59, "end": 65, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [39, 44, 57, 58, 60, 61, 62, 63, 64, 65, 70], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      log_function('LOOP #1: Entered for loop at line 28-31\\n')\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      log_function('LOOP #2: Entered while loop at line 34-41\\n')\n      u = q.popleft()\n      for v in graph[u]:\n        log_function('LOOP #3: Entered for loop at line 36-41\\n')\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          log_function('BRANCH #1: Covered if branch at line 38-39\\n')\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      log_function('LOOP #4: Entered for loop at line 42-45\\n')\n      if favorite[favorite[i]] == i:\n        log_function('BRANCH #2: Covered if branch at line 43-44\\n')\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        log_function('LOOP #5: Entered for loop at line 55-65\\n')\n        if v not in seen:\n          log_function('BRANCH #3: Covered if branch at line 56-58\\n')\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          log_function('BRANCH #4: Covered elif branch at line 59-65\\n')\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            log_function('LOOP #6: Entered while loop at line 62-64\\n')\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      log_function('LOOP #7: Entered for loop at line 68-71\\n')\n      if i not in seen:\n        log_function('BRANCH #5: Covered if branch at line 69-70\\n')\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Employees to Be Invited to a Meeting.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #6: Entered while loop at line 62-64\n", "LOOP #6: Entered while loop at line 62-64\n", "LOOP #7: Entered for loop at line 68-71\n", "LOOP #7: Entered for loop at line 68-71\n", "BRANCH #5: Covered if branch at line 69-70\n"], ["LOOP #7: Entered for loop at line 68-71\n", "BRANCH #5: Covered if branch at line 69-70\n", "LOOP #5: Entered for loop at line 55-65\n", "BRANCH #3: Covered if branch at line 56-58\n", "LOOP #5: Entered for loop at line 55-65\n"], ["LOOP #4: Entered for loop at line 42-45\n", "LOOP #4: Entered for loop at line 42-45\n", "LOOP #7: Entered for loop at line 68-71\n", "BRANCH #5: Covered if branch at line 69-70\n", "LOOP #5: Entered for loop at line 55-65\n"], ["LOOP #4: Entered for loop at line 42-45\n", "LOOP #4: Entered for loop at line 42-45\n", "BRANCH #2: Covered if branch at line 43-44\n", "LOOP #4: Entered for loop at line 42-45\n", "BRANCH #2: Covered if branch at line 43-44\n"], ["LOOP #4: Entered for loop at line 42-45\n", "BRANCH #2: Covered if branch at line 43-44\n", "LOOP #4: Entered for loop at line 42-45\n", "BRANCH #2: Covered if branch at line 43-44\n", "LOOP #4: Entered for loop at line 42-45\n"]], "sampled_condition_paths": [["Line 62: (curr != v)", "Line 62: (curr != v)", "Line 68: (i in range(n))", "Line 68: (i in range(n))", "Line 69: (i not in seen)"], ["Line 68: (i in range(n))", "Line 69: (i not in seen)", "Line 55: (v in graph[u])", "Line 56: (v not in seen)", "Line 55: (v in graph[u])"], ["Line 42: (i in range(n))", "Line 42: (i in range(n))", "Line 68: (i in range(n))", "Line 69: (i not in seen)", "Line 55: (v in graph[u])"], ["Line 42: (i in range(n))", "Line 42: (i in range(n))", "Line 43: (favorite[favorite[i]] == i)", "Line 42: (i in range(n))", "Line 43: (favorite[favorite[i]] == i)"], ["Line 42: (i in range(n))", "Line 43: (favorite[favorite[i]] == i)", "Line 42: (i in range(n))", "Line 43: (favorite[favorite[i]] == i)", "Line 42: (i in range(n))"]]}
{"task_num": 2132, "task_title": "Stamping the Grid", "difficulty": 3, "func_name": "possibleToStamp", "description": "You are given an `m x n` binary matrix `grid` where each cell is either `0`\n(empty) or `1` (occupied).\n\nYou are then given stamps of size `stampHeight x stampWidth`. We want to fit\nthe stamps such that they follow the given restrictions and requirements:\n\n1. Cover all the empty cells.\n2. Do not cover any of the occupied cells.\n3. We can put as many stamps as we want.\n4. Stamps can overlap with each other.\n5. Stamps are not allowed to be rotated.\n6. Stamps must stay completely inside the grid.\n\nReturn `true` if it is possible to fit the stamps while following the given\nrestrictions and requirements. Otherwise, return `false`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "blocks": [{"type": "if", "start": 22, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 24, 25, 26, 35, 36, 37, 38], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 19-27\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 20-27\\n')\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          log_function('BRANCH #1: Covered if branch at line 22-26\\n')\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n            fit[i][j] = True\n\n    for i in range(m):\n      log_function('LOOP #3: Entered for loop at line 28-31\\n')\n      for j in range(n):\n        log_function('LOOP #4: Entered for loop at line 29-31\\n')\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      log_function('LOOP #5: Entered for loop at line 32-39\\n')\n      for j in range(n):\n        log_function('LOOP #6: Entered for loop at line 33-39\\n')\n        if not grid[i][j]:\n          log_function('BRANCH #3: Covered if branch at line 34-38\\n')\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            log_function('BRANCH #4: Covered if branch at line 37-38\\n')\n            return False\n\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Stamping the Grid.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 29-31\n", "LOOP #3: Entered for loop at line 28-31\n", "LOOP #4: Entered for loop at line 29-31\n", "LOOP #4: Entered for loop at line 29-31\n", "LOOP #4: Entered for loop at line 29-31\n"], ["LOOP #2: Entered for loop at line 20-27\n", "BRANCH #1: Covered if branch at line 22-26\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #1: Entered for loop at line 19-27\n", "LOOP #2: Entered for loop at line 20-27\n"], ["LOOP #2: Entered for loop at line 20-27\n", "LOOP #2: Entered for loop at line 20-27\n", "BRANCH #1: Covered if branch at line 22-26\n", "LOOP #2: Entered for loop at line 20-27\n", "BRANCH #1: Covered if branch at line 22-26\n"], ["LOOP #2: Entered for loop at line 20-27\n", "BRANCH #1: Covered if branch at line 22-26\n", "LOOP #2: Entered for loop at line 20-27\n", "BRANCH #1: Covered if branch at line 22-26\n", "BRANCH #2: Covered if branch at line 25-26\n"]], "sampled_condition_paths": [["Line 29: (j in range(n))", "Line 28: (i in range(m))", "Line 29: (j in range(n))", "Line 29: (j in range(n))", "Line 29: (j in range(n))"], ["Line 20: (j in range(n))", "Line 22: (i + 1 >= stampHeight and j + 1 >= stampWidth)", "Line 25: (A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0)", "Line 19: (i in range(m))", "Line 20: (j in range(n))"], ["Line 20: (j in range(n))", "Line 20: (j in range(n))", "Line 22: (i + 1 >= stampHeight and j + 1 >= stampWidth)", "Line 20: (j in range(n))", "Line 22: (i + 1 >= stampHeight and j + 1 >= stampWidth)"], ["Line 20: (j in range(n))", "Line 22: (i + 1 >= stampHeight and j + 1 >= stampWidth)", "Line 20: (j in range(n))", "Line 22: (i + 1 >= stampHeight and j + 1 >= stampWidth)", "Line 25: (A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0)"]]}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "difficulty": 2, "func_name": "highestRankedKItems", "description": "You are given a 0-indexed 2D integer array `grid` of size `m x n` that\nrepresents a map of the items in a shop. The integers in the grid represent\nthe following:\n\n* `0` represents a wall that you cannot pass through.\n* `1` represents an empty cell that you can freely move to and from.\n* All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\n\nIt takes `1` step to travel between adjacent grid cells.\n\nYou are also given integer arrays `pricing` and `start` where `pricing = [low,\nhigh]` and `start = [row, col]` indicates that you start at the position\n`(row, col)` and are interested only in items with a price in the range of\n`[low, high]` (inclusive). You are further given an integer `k`.\n\nYou are interested in the positions of the `k` highest-ranked items whose\nprices are within the given price range. The rank is determined by the first\nof these criteria that is different:\n\n1. Distance, defined as the length of the shortest path from the `start` (shorter distance has a higher rank).\n2. Price (lower price has a higher rank, but it must be in the price range).\n3. The row number (smaller row number has a higher rank).\n4. The column number (smaller column number has a higher rank).\n\nReturn the `k` highest-ranked items within the price range sorted by their\nrank (highest to lowest). If there are fewer than `k` reachable items within\nthe price range, return all of them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "blocks": [{"type": "if", "start": 20, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 46, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}, {"type": "if", "start": 47, "end": 48, "difficulty": 2, "eg_cov_prob": 0.09433962264150944}, {"type": "if", "start": 35, "end": 36, "difficulty": 1, "eg_cov_prob": 0.5283018867924528}, {"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}], "target_lines": [21, 22, 23, 36, 38, 40, 46, 48], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      log_function('BRANCH #1: Covered if branch at line 20-23\\n')\n      ans.append([row, col])\n      if k == 1:\n        log_function('BRANCH #2: Covered if branch at line 22-23\\n')\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      log_function('LOOP #1: Entered while loop at line 28-49\\n')\n      neighbors = []\n      for _ in range(len(q)):\n        log_function('LOOP #2: Entered for loop at line 30-42\\n')\n        i, j = q.popleft()\n        for t in range(4):\n          log_function('LOOP #3: Entered for loop at line 32-42\\n')\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            log_function('BRANCH #3: Covered if branch at line 35-36\\n')\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            log_function('BRANCH #4: Covered if branch at line 37-38\\n')\n            continue\n          if low <= grid[x][y] <= high:\n            log_function('BRANCH #5: Covered if branch at line 39-40\\n')\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        log_function('LOOP #4: Entered for loop at line 44-49\\n')\n        if len(ans) < k:\n          log_function('BRANCH #6: Covered if branch at line 45-46\\n')\n          ans.append(neighbor)\n        if len(ans) == k:\n          log_function('BRANCH #7: Covered if branch at line 47-48\\n')\n          return ans\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/K Highest Ranked Items Within a Price Range.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 35-36\n", "LOOP #3: Entered for loop at line 32-42\n", "BRANCH #5: Covered if branch at line 39-40\n", "LOOP #3: Entered for loop at line 32-42\n", "BRANCH #5: Covered if branch at line 39-40\n"], ["LOOP #2: Entered for loop at line 30-42\n", "LOOP #3: Entered for loop at line 32-42\n", "BRANCH #3: Covered if branch at line 35-36\n", "LOOP #3: Entered for loop at line 32-42\n", "LOOP #3: Entered for loop at line 32-42\n"], ["LOOP #3: Entered for loop at line 32-42\n", "BRANCH #3: Covered if branch at line 35-36\n", "LOOP #3: Entered for loop at line 32-42\n", "LOOP #3: Entered for loop at line 32-42\n", "BRANCH #4: Covered if branch at line 37-38\n"], ["LOOP #3: Entered for loop at line 32-42\n", "BRANCH #3: Covered if branch at line 35-36\n", "LOOP #3: Entered for loop at line 32-42\n", "BRANCH #3: Covered if branch at line 35-36\n", "LOOP #4: Entered for loop at line 44-49\n"], ["BRANCH #3: Covered if branch at line 35-36\n", "LOOP #3: Entered for loop at line 32-42\n", "BRANCH #4: Covered if branch at line 37-38\n", "LOOP #4: Entered for loop at line 44-49\n", "BRANCH #6: Covered if branch at line 45-46\n"], ["LOOP #1: Entered while loop at line 28-49\n", "LOOP #2: Entered for loop at line 30-42\n", "LOOP #3: Entered for loop at line 32-42\n", "BRANCH #4: Covered if branch at line 37-38\n", "LOOP #3: Entered for loop at line 32-42\n"]], "sampled_condition_paths": [["Line 35: (x < 0 or x == m or y < 0 or y == n)", "Line 32: (t in range(4))", "Line 39: (low <= grid[x][y] <= high)", "Line 32: (t in range(4))", "Line 39: (low <= grid[x][y] <= high)"], ["Line 30: (_ in range(len(q)))", "Line 32: (t in range(4))", "Line 35: (x < 0 or x == m or y < 0 or y == n)", "Line 32: (t in range(4))", "Line 32: (t in range(4))"], ["Line 32: (t in range(4))", "Line 35: (x < 0 or x == m or y < 0 or y == n)", "Line 32: (t in range(4))", "Line 32: (t in range(4))", "Line 37: (not grid[x][y] or (x, y) in seen)"], ["Line 32: (t in range(4))", "Line 35: (x < 0 or x == m or y < 0 or y == n)", "Line 32: (t in range(4))", "Line 35: (x < 0 or x == m or y < 0 or y == n)", "Line 44: (neighbor in neighbors)"], ["Line 35: (x < 0 or x == m or y < 0 or y == n)", "Line 32: (t in range(4))", "Line 37: (not grid[x][y] or (x, y) in seen)", "Line 44: (neighbor in neighbors)", "Line 45: (len(ans) < k)"], ["Line 28: (q)", "Line 30: (_ in range(len(q)))", "Line 32: (t in range(4))", "Line 37: (not grid[x][y] or (x, y) in seen)", "Line 32: (t in range(4))"]]}
{"task_num": 2157, "task_title": "Groups of Strings", "difficulty": 3, "func_name": "groupStrings", "description": "You are given a 0-indexed array of strings `words`. Each string consists of\nlowercase English letters only. No letter occurs more than once in any string\nof `words`.\n\nTwo strings `s1` and `s2` are said to be connected if the set of letters of\n`s2` can be obtained from the set of letters of `s1` by any one of the\nfollowing operations:\n\n* Adding exactly one letter to the set of the letters of `s1`.\n* Deleting exactly one letter from the set of the letters of `s1`.\n* Replacing exactly one letter from the set of the letters of `s1` with any letter, including itself.\n\nThe array `words` can be divided into one or more non-intersecting groups. A\nstring belongs to a group if any one of the following is true:\n\n* It is connected to at least one other string of the group.\n* It is the only string present in the group.\n\nNote that the strings in `words` should be grouped in such a manner that a\nstring belonging to a group cannot be connected to a string present in any\nother group. It can be proved that such an arrangement is always unique.\n\nReturn an array `ans` of size `2` where:\n\n* `ans[0]` is the maximum number of groups `words` can be divided into, and\n* `ans[1]` is the size of the largest group.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 48, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 53, "end": 54, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 63, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 65, "end": 66, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 67, "end": 68, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 69, "end": 70, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 23, 24, 26, 27, 32, 49, 54, 63, 66, 68, 70], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n      return\n    if self.sz[i] < self.sz[j]:\n      log_function('BRANCH #2: Covered if branch at line 22-24\\n')\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      log_function('BRANCH #3: Covered else branch at line 25-27\\n')\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #4: Covered if branch at line 31-32\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        log_function('LOOP #1: Entered for loop at line 42-43\\n')\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        log_function('LOOP #2: Entered for loop at line 47-50\\n')\n        if not (mask >> i & 1):\n          log_function('BRANCH #5: Covered if branch at line 48-49\\n')\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        log_function('LOOP #3: Entered for loop at line 52-55\\n')\n        if mask >> i & 1:\n          log_function('BRANCH #6: Covered if branch at line 53-54\\n')\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      log_function('LOOP #4: Entered for loop at line 59-71\\n')\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        log_function('LOOP #5: Entered for loop at line 61-63\\n')\n        if m in maskToIndex:\n          log_function('BRANCH #7: Covered if branch at line 62-63\\n')\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        log_function('LOOP #6: Entered for loop at line 64-71\\n')\n        if m in maskToIndex:\n          log_function('BRANCH #8: Covered if branch at line 65-66\\n')\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          log_function('BRANCH #9: Covered if branch at line 67-68\\n')\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          log_function('BRANCH #10: Covered else branch at line 69-70\\n')\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n\ndef log_function(info_str):\n    with open(\"test_logs/Groups of Strings.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #5: Entered for loop at line 61-63\n", "LOOP #2: Entered for loop at line 47-50\n", "BRANCH #5: Covered if branch at line 48-49\n", "LOOP #5: Entered for loop at line 61-63\n", "LOOP #2: Entered for loop at line 47-50\n"], ["LOOP #2: Entered for loop at line 47-50\n", "BRANCH #5: Covered if branch at line 48-49\n", "LOOP #5: Entered for loop at line 61-63\n", "LOOP #2: Entered for loop at line 47-50\n", "BRANCH #5: Covered if branch at line 48-49\n"], ["LOOP #3: Entered for loop at line 52-55\n", "LOOP #3: Entered for loop at line 52-55\n", "LOOP #3: Entered for loop at line 52-55\n", "LOOP #3: Entered for loop at line 52-55\n", "LOOP #3: Entered for loop at line 52-55\n"]], "sampled_condition_paths": [["Line 61: (m in getAddedMasks(mask))", "Line 47: (i in range(26))", "Line 48: (not (mask >> i & 1))", "Line 61: (m in getAddedMasks(mask))", "Line 47: (i in range(26))"], ["Line 47: (i in range(26))", "Line 48: (not (mask >> i & 1))", "Line 61: (m in getAddedMasks(mask))", "Line 47: (i in range(26))", "Line 48: (not (mask >> i & 1))"], ["Line 52: (i in range(26))", "Line 52: (i in range(26))", "Line 52: (i in range(26))", "Line 52: (i in range(26))", "Line 52: (i in range(26))"]]}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "difficulty": 2, "func_name": "repeatLimitedString", "description": "You are given a string `s` and an integer `repeatLimit`. Construct a new\nstring `repeatLimitedString` using the characters of `s` such that no letter\nappears more than `repeatLimit` times in a row. You do not have to use all\ncharacters from `s`.\n\nReturn the lexicographically largest `repeatLimitedString` possible.\n\nA string `a` is lexicographically larger than a string `b` if in the first\nposition where `a` and `b` differ, string `a` has a letter that appears later\nin the alphabet than the corresponding letter in `b`. If the first\n`min(a.length, b.length)` characters do not differ, then the longer string is\nthe lexicographically larger one.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 30, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      log_function('LOOP #1: Entered while loop at line 16-24\\n')\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      log_function('LOOP #2: Entered for loop at line 28-30\\n')\n      if count[c]:\n        log_function('BRANCH #2: Covered if branch at line 29-30\\n')\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      log_function('LOOP #3: Entered for loop at line 34-36\\n')\n      if count[c] and (not ans or ans[-1] != c):\n        log_function('BRANCH #3: Covered if branch at line 35-36\\n')\n        return c\n    return ' '\n\ndef log_function(info_str):\n    with open(\"test_logs/Construct String With Repeat Limit.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 28-30\n", "LOOP #2: Entered for loop at line 28-30\n", "LOOP #2: Entered for loop at line 28-30\n", "LOOP #2: Entered for loop at line 28-30\n", "LOOP #2: Entered for loop at line 28-30\n"], ["LOOP #3: Entered for loop at line 34-36\n", "LOOP #3: Entered for loop at line 34-36\n", "LOOP #3: Entered for loop at line 34-36\n", "LOOP #3: Entered for loop at line 34-36\n", "LOOP #3: Entered for loop at line 34-36\n"], ["BRANCH #3: Covered if branch at line 35-36\n", "LOOP #1: Entered while loop at line 16-24\n", "LOOP #2: Entered for loop at line 28-30\n", "LOOP #2: Entered for loop at line 28-30\n", "LOOP #2: Entered for loop at line 28-30\n"], ["BRANCH #2: Covered if branch at line 29-30\n", "LOOP #3: Entered for loop at line 34-36\n", "LOOP #3: Entered for loop at line 34-36\n", "LOOP #3: Entered for loop at line 34-36\n", "LOOP #3: Entered for loop at line 34-36\n"]], "sampled_condition_paths": [["Line 28: (c in reversed(string.ascii_lowercase))", "Line 28: (c in reversed(string.ascii_lowercase))", "Line 28: (c in reversed(string.ascii_lowercase))", "Line 28: (c in reversed(string.ascii_lowercase))", "Line 28: (c in reversed(string.ascii_lowercase))"], ["Line 34: (c in reversed(string.ascii_lowercase))", "Line 34: (c in reversed(string.ascii_lowercase))", "Line 34: (c in reversed(string.ascii_lowercase))", "Line 34: (c in reversed(string.ascii_lowercase))", "Line 34: (c in reversed(string.ascii_lowercase))"], ["Line 35: (count[c] and (not ans or ans[-1] != c))", "Line 16: (True)", "Line 28: (c in reversed(string.ascii_lowercase))", "Line 28: (c in reversed(string.ascii_lowercase))", "Line 28: (c in reversed(string.ascii_lowercase))"], ["Line 29: (count[c])", "Line 34: (c in reversed(string.ascii_lowercase))", "Line 34: (c in reversed(string.ascii_lowercase))", "Line 34: (c in reversed(string.ascii_lowercase))", "Line 34: (c in reversed(string.ascii_lowercase))"]]}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "difficulty": 3, "func_name": "minimumWeight", "description": "You are given an integer `n` denoting the number of nodes of a weighted\ndirected graph. The nodes are numbered from `0` to `n - 1`.\n\nYou are also given a 2D integer array `edges` where `edges[i] = [fromi, toi,\nweighti]` denotes that there exists a directed edge from `fromi` to `toi` with\nweight `weighti`.\n\nLastly, you are given three distinct integers `src1`, `src2`, and `dest`\ndenoting three distinct nodes of the graph.\n\nReturn the minimum weight of a subgraph of the graph such that it is possible\nto reach `dest` from both `src1` and `src2` via a set of edges of this\nsubgraph. In case such a subgraph does not exist, return `-1`.\n\nA subgraph is a graph whose vertices and edges are subsets of the original\ngraph. The weight of a subgraph is the sum of weights of its constituent\nedges.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.7735849056603774}, {"type": "else", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.22641509433962265}, {"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.37735849056603776}, {"type": "if", "start": 40, "end": 42, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}], "target_lines": [25, 27, 38, 41, 42], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      log_function('LOOP #1: Entered for loop at line 16-19\\n')\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      log_function('BRANCH #1: Covered if branch at line 24-25\\n')\n      return -1\n    else:\n      log_function('BRANCH #2: Covered else branch at line 26-27\\n')\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      log_function('LOOP #2: Entered while loop at line 35-43\\n')\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        log_function('BRANCH #3: Covered if branch at line 37-38\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #3: Entered for loop at line 39-43\\n')\n        if d + w < dist[v]:\n          log_function('BRANCH #4: Covered if branch at line 40-42\\n')\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Weighted Subgraph With the Required Paths.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 35-43\n", "LOOP #2: Entered while loop at line 35-43\n", "LOOP #3: Entered for loop at line 39-43\n", "LOOP #2: Entered while loop at line 35-43\n", "BRANCH #3: Covered if branch at line 37-38\n"], ["BRANCH #4: Covered if branch at line 40-42\n", "LOOP #2: Entered while loop at line 35-43\n", "LOOP #2: Entered while loop at line 35-43\n", "LOOP #2: Entered while loop at line 35-43\n", "BRANCH #1: Covered if branch at line 24-25\n"], ["LOOP #1: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 16-19\n", "LOOP #1: Entered for loop at line 16-19\n"]], "sampled_condition_paths": [["Line 35: (minHeap)", "Line 35: (minHeap)", "Line 39: (v, w in graph[u])", "Line 35: (minHeap)", "Line 37: (d > dist[u])"], ["Line 40: (d + w < dist[v])", "Line 35: (minHeap)", "Line 35: (minHeap)", "Line 35: (minHeap)", "Line 24: (minWeight == math.inf)"], ["Line 16: (u, v, w in edges)", "Line 16: (u, v, w in edges)", "Line 16: (u, v, w in edges)", "Line 16: (u, v, w in edges)", "Line 16: (u, v, w in edges)"]]}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "difficulty": 3, "func_name": "maximumScore", "description": "There is an undirected graph with `n` nodes, numbered from `0` to `n - 1`.\n\nYou are given a 0-indexed integer array `scores` of length `n` where\n`scores[i]` denotes the score of node `i`. You are also given a 2D integer\narray `edges` where `edges[i] = [ai, bi]` denotes that there exists an\nundirected edge connecting nodes `ai` and `bi`.\n\nA node sequence is valid if it meets the following conditions:\n\n* There is an edge connecting every pair of adjacent nodes in the sequence.\n* No node appears more than once in the sequence.\n\nThe score of a node sequence is defined as the sum of the scores of the nodes\nin the sequence.\n\nReturn the maximum score of a valid node sequence with a length of `4`. If no\nsuch sequence exists, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}], "target_lines": [28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 17-20\\n')\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      log_function('LOOP #2: Entered for loop at line 21-23\\n')\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      log_function('LOOP #3: Entered for loop at line 24-29\\n')\n      for scoreA, a in graph[u]:\n        log_function('LOOP #4: Entered for loop at line 25-29\\n')\n        for scoreB, b in graph[v]:\n          log_function('LOOP #5: Entered for loop at line 26-29\\n')\n          if a != b and a != v and b != u:\n            log_function('BRANCH #1: Covered if branch at line 27-28\\n')\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Score of a Node Sequence.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 24-29\n", "LOOP #4: Entered for loop at line 25-29\n", "LOOP #5: Entered for loop at line 26-29\n", "LOOP #5: Entered for loop at line 26-29\n", "LOOP #5: Entered for loop at line 26-29\n"], ["LOOP #5: Entered for loop at line 26-29\n", "LOOP #5: Entered for loop at line 26-29\n", "LOOP #3: Entered for loop at line 24-29\n", "LOOP #4: Entered for loop at line 25-29\n", "LOOP #5: Entered for loop at line 26-29\n"], ["LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n"], ["LOOP #4: Entered for loop at line 25-29\n", "LOOP #5: Entered for loop at line 26-29\n", "LOOP #5: Entered for loop at line 26-29\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #3: Entered for loop at line 24-29\n"]], "sampled_condition_paths": [["Line 24: (u, v in edges)", "Line 25: (scoreA, a in graph[u])", "Line 26: (scoreB, b in graph[v])", "Line 26: (scoreB, b in graph[v])", "Line 26: (scoreB, b in graph[v])"], ["Line 26: (scoreB, b in graph[v])", "Line 26: (scoreB, b in graph[v])", "Line 24: (u, v in edges)", "Line 25: (scoreA, a in graph[u])", "Line 26: (scoreB, b in graph[v])"], ["Line 17: (u, v in edges)", "Line 17: (u, v in edges)", "Line 17: (u, v in edges)", "Line 17: (u, v in edges)", "Line 17: (u, v in edges)"], ["Line 25: (scoreA, a in graph[u])", "Line 26: (scoreB, b in graph[v])", "Line 26: (scoreB, b in graph[v])", "Line 27: (a != b and a != v and b != u)", "Line 24: (u, v in edges)"]]}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "difficulty": 2, "func_name": "maxTrailingZeros", "description": "You are given a 2D integer array `grid` of size `m x n`, where each cell\ncontains a positive integer.\n\nA cornered path is defined as a set of adjacent cells with at most one turn.\nMore specifically, the path should exclusively move either horizontally or\nvertically up to the turn (if there is one), without returning to a previously\nvisited cell. After the turn, the path will then move exclusively in the\nalternate direction: move vertically if it moved horizontally, and vice versa,\nalso without returning to a previously visited cell.\n\nThe product of a path is defined as the product of all the values in the path.\n\nReturn the maximum number of trailing zeros in the product of a cornered path\nfound in `grid`.\n\nNote:\n\n* Horizontal movement means moving in either the left or right direction.\n* Vertical movement means moving in either the up or down direction.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "blocks": [{"type": "if", "start": 31, "end": 33, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 39, "end": 41, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}], "target_lines": [32, 33, 40, 41], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        log_function('LOOP #1: Entered while loop at line 22-24\\n')\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      log_function('LOOP #2: Entered for loop at line 27-34\\n')\n      for j in range(n):\n        log_function('LOOP #3: Entered for loop at line 28-34\\n')\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          log_function('BRANCH #1: Covered if branch at line 31-33\\n')\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      log_function('LOOP #4: Entered for loop at line 35-42\\n')\n      for i in range(m):\n        log_function('LOOP #5: Entered for loop at line 36-42\\n')\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          log_function('BRANCH #2: Covered if branch at line 39-41\\n')\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      log_function('LOOP #6: Entered for loop at line 44-57\\n')\n      for j in range(n):\n        log_function('LOOP #7: Entered for loop at line 45-57\\n')\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Trailing Zeros in a Cornered Path.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered while loop at line 22-24\n", "LOOP #1: Entered while loop at line 22-24\n", "LOOP #1: Entered while loop at line 22-24\n", "LOOP #5: Entered for loop at line 36-42\n", "BRANCH #2: Covered if branch at line 39-41\n"], ["LOOP #5: Entered for loop at line 36-42\n", "LOOP #1: Entered while loop at line 22-24\n", "LOOP #1: Entered while loop at line 22-24\n", "LOOP #1: Entered while loop at line 22-24\n", "BRANCH #2: Covered if branch at line 39-41\n"], ["LOOP #7: Entered for loop at line 45-57\n", "LOOP #7: Entered for loop at line 45-57\n", "LOOP #1: Entered while loop at line 22-24\n", "LOOP #7: Entered for loop at line 45-57\n", "LOOP #6: Entered for loop at line 44-57\n"], ["LOOP #1: Entered while loop at line 22-24\n", "LOOP #7: Entered for loop at line 45-57\n", "LOOP #1: Entered while loop at line 22-24\n", "LOOP #1: Entered while loop at line 22-24\n", "LOOP #1: Entered while loop at line 22-24\n"]], "sampled_condition_paths": [["Line 22: (num % factor == 0)", "Line 22: (num % factor == 0)", "Line 22: (num % factor == 0)", "Line 36: (i in range(m))", "Line 39: (i)"], ["Line 36: (i in range(m))", "Line 22: (num % factor == 0)", "Line 22: (num % factor == 0)", "Line 22: (num % factor == 0)", "Line 39: (i)"], ["Line 45: (j in range(n))", "Line 45: (j in range(n))", "Line 22: (num % factor == 0)", "Line 45: (j in range(n))", "Line 44: (i in range(m))"], ["Line 22: (num % factor == 0)", "Line 45: (j in range(n))", "Line 22: (num % factor == 0)", "Line 22: (num % factor == 0)", "Line 22: (num % factor == 0)"]]}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "difficulty": 2, "func_name": "countUnguarded", "description": "You are given two integers `m` and `n` representing a 0-indexed `m x n` grid.\nYou are also given two 2D integer arrays `guards` and `walls` where `guards[i]\n= [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the\n`ith` guard and `jth` wall respectively.\n\nA guard can see every cell in the four cardinal directions (north, east,\nsouth, or west) starting from their position unless obstructed by a wall or\nanother guard. A cell is guarded if there is at least one guard that can see\nit.\n\nReturn the number of unoccupied cells that are not guarded.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 45, "end": 46, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 56, "end": 57, "difficulty": 1, "eg_cov_prob": 0.8867924528301887}], "target_lines": [30, 32, 36, 38, 44, 46, 50, 52, 57], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      log_function('LOOP #1: Entered for loop at line 20-22\\n')\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      log_function('LOOP #2: Entered for loop at line 23-25\\n')\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      log_function('LOOP #3: Entered for loop at line 26-39\\n')\n      lastCell = 0\n      for j in range(n):\n        log_function('LOOP #4: Entered for loop at line 28-32\\n')\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          log_function('BRANCH #1: Covered if branch at line 29-30\\n')\n          lastCell = grid[i][j]\n        else:\n          log_function('BRANCH #2: Covered else branch at line 31-32\\n')\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        log_function('LOOP #5: Entered for loop at line 34-39\\n')\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          log_function('BRANCH #3: Covered if branch at line 35-36\\n')\n          lastCell = grid[i][j]\n        else:\n          log_function('BRANCH #4: Covered else branch at line 37-38\\n')\n          right[i][j] = lastCell\n\n    for j in range(n):\n      log_function('LOOP #6: Entered for loop at line 40-53\\n')\n      lastCell = 0\n      for i in range(m):\n        log_function('LOOP #7: Entered for loop at line 42-46\\n')\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          log_function('BRANCH #5: Covered if branch at line 43-44\\n')\n          lastCell = grid[i][j]\n        else:\n          log_function('BRANCH #6: Covered else branch at line 45-46\\n')\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        log_function('LOOP #8: Entered for loop at line 48-53\\n')\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          log_function('BRANCH #7: Covered if branch at line 49-50\\n')\n          lastCell = grid[i][j]\n        else:\n          log_function('BRANCH #8: Covered else branch at line 51-52\\n')\n          down[i][j] = lastCell\n\n    for i in range(m):\n      log_function('LOOP #9: Entered for loop at line 54-58\\n')\n      for j in range(n):\n        log_function('LOOP #10: Entered for loop at line 55-58\\n')\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          log_function('BRANCH #9: Covered if branch at line 56-57\\n')\n          ans += 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Unguarded Cells in the Grid.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #4: Covered else branch at line 37-38\n", "LOOP #5: Entered for loop at line 34-39\n", "BRANCH #4: Covered else branch at line 37-38\n", "LOOP #5: Entered for loop at line 34-39\n", "BRANCH #3: Covered if branch at line 35-36\n"], ["LOOP #5: Entered for loop at line 34-39\n", "BRANCH #3: Covered if branch at line 35-36\n", "LOOP #3: Entered for loop at line 26-39\n", "LOOP #4: Entered for loop at line 28-32\n", "BRANCH #2: Covered else branch at line 31-32\n"], ["BRANCH #5: Covered if branch at line 43-44\n", "LOOP #8: Entered for loop at line 48-53\n", "BRANCH #7: Covered if branch at line 49-50\n", "LOOP #8: Entered for loop at line 48-53\n", "BRANCH #7: Covered if branch at line 49-50\n"], ["LOOP #4: Entered for loop at line 28-32\n", "BRANCH #2: Covered else branch at line 31-32\n", "LOOP #4: Entered for loop at line 28-32\n", "BRANCH #2: Covered else branch at line 31-32\n", "LOOP #4: Entered for loop at line 28-32\n"]], "sampled_condition_paths": [["Line 35: NOT (grid[i][j] == 'G' or grid[i][j] == 'W')", "Line 37: ", "Line 34: (j in range(n - 1, -1, -1))", "Line 35: NOT (grid[i][j] == 'G' or grid[i][j] == 'W')", "Line 37: ", "Line 34: (j in range(n - 1, -1, -1))", "Line 35: (grid[i][j] == 'G' or grid[i][j] == 'W')"], ["Line 34: (j in range(n - 1, -1, -1))", "Line 35: (grid[i][j] == 'G' or grid[i][j] == 'W')", "Line 26: (i in range(m))", "Line 28: (j in range(n))", "Line 29: NOT (grid[i][j] == 'G' or grid[i][j] == 'W')", "Line 31: "], ["Line 43: (grid[i][j] == 'G' or grid[i][j] == 'W')", "Line 48: (i in range(m - 1, -1, -1))", "Line 49: (grid[i][j] == 'G' or grid[i][j] == 'W')", "Line 48: (i in range(m - 1, -1, -1))", "Line 49: (grid[i][j] == 'G' or grid[i][j] == 'W')"], ["Line 28: (j in range(n))", "Line 29: NOT (grid[i][j] == 'G' or grid[i][j] == 'W')", "Line 31: ", "Line 28: (j in range(n))", "Line 29: NOT (grid[i][j] == 'G' or grid[i][j] == 'W')", "Line 31: ", "Line 28: (j in range(n))"]]}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "difficulty": 3, "func_name": "maximumMinutes", "description": "You are given a 0-indexed 2D integer array `grid` of size `m x n` which\nrepresents a field. Each cell has one of three values:\n\n* `0` represents grass,\n* `1` represents fire,\n* `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the\nsafehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may\nmove to an adjacent grass cell. After your move, every fire cell will spread\nto all adjacent cells that are not walls.\n\nReturn the maximum number of minutes that you can stay in your initial\nposition before moving while still safely reaching the safehouse. If this is\nimpossible, return `-1`. If you can always reach the safehouse regardless of\nthe minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have\nreached it, it will be counted as safely reaching the safehouse.\n\nA cell is adjacent to another cell if the former is directly north, east,\nsouth, or west of the latter (i.e., their sides are touching).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "blocks": [{"type": "if", "start": 24, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 48, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 68, "end": 69, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 70, "end": 71, "difficulty": 1, "eg_cov_prob": 0.6792452830188679}, {"type": "if", "start": 72, "end": 75, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 76, "end": 77, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}, {"type": "if", "start": 78, "end": 79, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 73, "end": 74, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [25, 26, 28, 39, 40, 49, 51, 53, 69, 71, 73, 74, 75, 77, 79], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      log_function('LOOP #1: Entered while loop at line 22-29\\n')\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        log_function('BRANCH #1: Covered if branch at line 24-26\\n')\n        ans = m\n        l = m + 1\n      else:\n        log_function('BRANCH #2: Covered else branch at line 27-28\\n')\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      log_function('LOOP #2: Entered for loop at line 36-40\\n')\n      for j in range(len(grid[0])):\n        log_function('LOOP #3: Entered for loop at line 37-40\\n')\n        if grid[i][j] == 1:\n          log_function('BRANCH #3: Covered if branch at line 38-40\\n')\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      log_function('LOOP #4: Entered while loop at line 41-56\\n')\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        log_function('LOOP #5: Entered for loop at line 43-56\\n')\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          log_function('LOOP #6: Entered for loop at line 45-56\\n')\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            log_function('BRANCH #4: Covered if branch at line 48-49\\n')\n            continue\n          if grid[x][y] == 2:\n            log_function('BRANCH #5: Covered if branch at line 50-51\\n')\n            continue\n          if fireMinute[x][y] != -1:\n            log_function('BRANCH #6: Covered if branch at line 52-53\\n')\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      log_function('LOOP #7: Entered while loop at line 61-82\\n')\n      minute += 1\n      for _ in range(len(q)):\n        log_function('LOOP #8: Entered for loop at line 63-82\\n')\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          log_function('LOOP #9: Entered for loop at line 65-82\\n')\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            log_function('BRANCH #7: Covered if branch at line 68-69\\n')\n            continue\n          if grid[x][y] == 2:\n            log_function('BRANCH #8: Covered if branch at line 70-71\\n')\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            log_function('BRANCH #9: Covered if branch at line 72-75\\n')\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              log_function('BRANCH #10: Covered if branch at line 73-74\\n')\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            log_function('BRANCH #11: Covered if branch at line 76-77\\n')\n            continue\n          if (x, y) in seen:\n            log_function('BRANCH #12: Covered if branch at line 78-79\\n')\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n\ndef log_function(info_str):\n    with open(\"test_logs/Escape the Spreading Fire.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #6: Covered if branch at line 52-53\n", "LOOP #6: Entered for loop at line 45-56\n", "BRANCH #4: Covered if branch at line 48-49\n", "LOOP #6: Entered for loop at line 45-56\n", "BRANCH #4: Covered if branch at line 48-49\n"], ["LOOP #6: Entered for loop at line 45-56\n", "BRANCH #5: Covered if branch at line 50-51\n", "LOOP #6: Entered for loop at line 45-56\n", "BRANCH #5: Covered if branch at line 50-51\n", "LOOP #1: Entered while loop at line 22-29\n"], ["LOOP #7: Entered while loop at line 61-82\n", "LOOP #8: Entered for loop at line 63-82\n", "LOOP #9: Entered for loop at line 65-82\n", "BRANCH #7: Covered if branch at line 68-69\n", "LOOP #9: Entered for loop at line 65-82\n"], ["BRANCH #3: Covered if branch at line 38-40\n", "LOOP #3: Entered for loop at line 37-40\n", "LOOP #3: Entered for loop at line 37-40\n", "LOOP #2: Entered for loop at line 36-40\n", "LOOP #3: Entered for loop at line 37-40\n"], ["LOOP #9: Entered for loop at line 65-82\n", "BRANCH #11: Covered if branch at line 76-77\n", "LOOP #7: Entered while loop at line 61-82\n", "LOOP #8: Entered for loop at line 63-82\n", "LOOP #9: Entered for loop at line 65-82\n"], ["LOOP #9: Entered for loop at line 65-82\n", "BRANCH #9: Covered if branch at line 72-75\n", "BRANCH #1: Covered if branch at line 24-26\n", "LOOP #1: Entered while loop at line 22-29\n", "LOOP #7: Entered while loop at line 61-82\n"]], "sampled_condition_paths": [["Line 52: (fireMinute[x][y] != -1)", "Line 45: (dx, dy in dirs)", "Line 48: (x < 0 or x == len(grid) or y < 0 or y == len(grid[0]))", "Line 45: (dx, dy in dirs)", "Line 48: (x < 0 or x == len(grid) or y < 0 or y == len(grid[0]))"], ["Line 45: (dx, dy in dirs)", "Line 50: (grid[x][y] == 2)", "Line 45: (dx, dy in dirs)", "Line 50: (grid[x][y] == 2)", "Line 22: (l <= r)"], ["Line 61: (q)", "Line 63: (_ in range(len(q)))", "Line 65: (dx, dy in dirs)", "Line 68: (x < 0 or x == len(grid) or y < 0 or y == len(grid[0]))", "Line 65: (dx, dy in dirs)"], ["Line 38: (grid[i][j] == 1)", "Line 37: (j in range(len(grid[0])))", "Line 37: (j in range(len(grid[0])))", "Line 36: (i in range(len(grid)))", "Line 37: (j in range(len(grid[0])))"], ["Line 65: (dx, dy in dirs)", "Line 76: (fireMinute[x][y] != -1 and fireMinute[x][y] <= minute)", "Line 61: (q)", "Line 63: (_ in range(len(q)))", "Line 65: (dx, dy in dirs)"], ["Line 65: (dx, dy in dirs)", "Line 72: (x == len(grid) - 1 and y == len(grid[0]) - 1)", "Line 24: (self._canStayFor(grid, fireGrid, m, dirs))", "Line 22: (l <= r)", "Line 61: (q)"]]}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "difficulty": 3, "func_name": "minimumObstacles", "description": "You are given a 0-indexed 2D integer array `grid` of size `m x n`. Each cell\nhas one of two values:\n\n* `0` represents an empty cell,\n* `1` represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\n\nReturn the minimum number of obstacles to remove so you can move from the\nupper left corner `(0, 0)` to the lower right corner `(m - 1, n - 1)`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 28, 31, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      log_function('LOOP #1: Entered while loop at line 20-33\\n')\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        log_function('BRANCH #1: Covered if branch at line 22-23\\n')\n        return d\n      for dx, dy in dirs:\n        log_function('LOOP #2: Entered for loop at line 24-33\\n')\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          log_function('BRANCH #2: Covered if branch at line 27-28\\n')\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          log_function('BRANCH #3: Covered if branch at line 30-32\\n')\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Obstacle Removal to Reach Corner.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered while loop at line 20-33\n", "LOOP #2: Entered for loop at line 24-33\n", "LOOP #2: Entered for loop at line 24-33\n", "BRANCH #2: Covered if branch at line 27-28\n", "LOOP #2: Entered for loop at line 24-33\n"], ["BRANCH #3: Covered if branch at line 30-32\n", "LOOP #2: Entered for loop at line 24-33\n", "LOOP #2: Entered for loop at line 24-33\n", "LOOP #1: Entered while loop at line 20-33\n", "LOOP #2: Entered for loop at line 24-33\n"], ["LOOP #2: Entered for loop at line 24-33\n", "LOOP #2: Entered for loop at line 24-33\n", "BRANCH #3: Covered if branch at line 30-32\n", "LOOP #1: Entered while loop at line 20-33\n", "LOOP #2: Entered for loop at line 24-33\n"], ["LOOP #2: Entered for loop at line 24-33\n", "LOOP #1: Entered while loop at line 20-33\n", "LOOP #2: Entered for loop at line 24-33\n", "BRANCH #2: Covered if branch at line 27-28\n", "LOOP #2: Entered for loop at line 24-33\n"]], "sampled_condition_paths": [["Line 20: (minHeap)", "Line 24: (dx, dy in dirs)", "Line 24: (dx, dy in dirs)", "Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)"], ["Line 30: (newDist < dist[x][y])", "Line 24: (dx, dy in dirs)", "Line 24: (dx, dy in dirs)", "Line 20: (minHeap)", "Line 24: (dx, dy in dirs)"], ["Line 24: (dx, dy in dirs)", "Line 24: (dx, dy in dirs)", "Line 30: (newDist < dist[x][y])", "Line 20: (minHeap)", "Line 24: (dx, dy in dirs)"], ["Line 24: (dx, dy in dirs)", "Line 20: (minHeap)", "Line 24: (dx, dy in dirs)", "Line 27: (x < 0 or x == m or y < 0 or y == n)", "Line 24: (dx, dy in dirs)"]]}
{"task_num": 2299, "task_title": "Strong Password Checker II", "difficulty": 1, "func_name": "strongPasswordCheckerII", "description": "A password is said to be strong if it satisfies all the following criteria:\n\n* It has at least `8` characters.\n* It contains at least one lowercase letter.\n* It contains at least one uppercase letter.\n* It contains at least one digit.\n* It contains at least one special character. The special characters are the characters in the following string: `\"!@#$%^&*()-+\"`.\n* It does not contain `2` of the same character in adjacent positions (i.e., `\"aab\"` violates this condition, but `\"aba\"` does not).\n\nGiven a string `password`, return `true` if it is a strong password.\nOtherwise, return `false`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 15, "end": 16, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 16, 18, 20, 22], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return False\n    if not any(c.islower() for c in password):\n      log_function('BRANCH #2: Covered if branch at line 15-16\\n')\n      return False\n    if not any(c.isupper() for c in password):\n      log_function('BRANCH #3: Covered if branch at line 17-18\\n')\n      return False\n    if not any(c.isdigit() for c in password):\n      log_function('BRANCH #4: Covered if branch at line 19-20\\n')\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      log_function('BRANCH #5: Covered if branch at line 21-22\\n')\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n\ndef log_function(info_str):\n    with open(\"test_logs/Strong Password Checker II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [[], ["BRANCH #4: Covered if branch at line 19-20\n"], ["BRANCH #1: Covered if branch at line 13-14\n"]], "sampled_condition_paths": [[], ["Line 19: (not any(c.isdigit() for c in password))"], ["Line 13: (len(password) < 8)"]]}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "difficulty": 3, "func_name": "matchReplacement", "description": "You are given two strings `s` and `sub`. You are also given a 2D character\narray `mappings` where `mappings[i] = [oldi, newi]` indicates that you may\nperform the following operation any number of times:\n\n* Replace a character `oldi` of `sub` with `newi`.\n\nEach character in `sub` cannot be replaced more than once.\n\nReturn `true` if it is possible to make `sub` a substring of `s` by replacing\nzero or more characters according to `mappings`. Otherwise, return `false`.\n\nA substring is a contiguous non-empty sequence of characters within a string.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "blocks": [{"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [20, 26, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      log_function('LOOP #1: Entered for loop at line 15-17\\n')\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      log_function('LOOP #2: Entered for loop at line 18-21\\n')\n      if self._canTransform(s, i, sub, isMapped):\n        log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n      return False\n\n    for i in range(len(sub)):\n      log_function('LOOP #3: Entered for loop at line 28-33\\n')\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        log_function('BRANCH #3: Covered if branch at line 31-32\\n')\n        return False\n\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Match Substring After Replacement.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 31-32\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #3: Entered for loop at line 28-33\n", "BRANCH #3: Covered if branch at line 31-32\n", "LOOP #2: Entered for loop at line 18-21\n"], ["LOOP #1: Entered for loop at line 15-17\n", "LOOP #1: Entered for loop at line 15-17\n", "LOOP #1: Entered for loop at line 15-17\n", "LOOP #1: Entered for loop at line 15-17\n", "LOOP #2: Entered for loop at line 18-21\n"], ["LOOP #2: Entered for loop at line 18-21\n", "LOOP #3: Entered for loop at line 28-33\n", "BRANCH #3: Covered if branch at line 31-32\n", "LOOP #2: Entered for loop at line 18-21\n", "BRANCH #2: Covered if branch at line 25-26\n"], ["BRANCH #3: Covered if branch at line 31-32\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #3: Entered for loop at line 28-33\n", "LOOP #3: Entered for loop at line 28-33\n", "LOOP #3: Entered for loop at line 28-33\n"], ["LOOP #2: Entered for loop at line 18-21\n", "LOOP #3: Entered for loop at line 28-33\n", "BRANCH #3: Covered if branch at line 31-32\n", "LOOP #2: Entered for loop at line 18-21\n", "LOOP #3: Entered for loop at line 28-33\n"]], "sampled_condition_paths": [["Line 31: (a != b and not isMapped[ord(a)][ord(b)])", "Line 18: (i in range(len(s)))", "Line 28: (i in range(len(sub)))", "Line 31: (a != b and not isMapped[ord(a)][ord(b)])", "Line 18: (i in range(len(s)))"], ["Line 15: (old, new in mappings)", "Line 15: (old, new in mappings)", "Line 15: (old, new in mappings)", "Line 15: (old, new in mappings)", "Line 18: (i in range(len(s)))"], ["Line 18: (i in range(len(s)))", "Line 28: (i in range(len(sub)))", "Line 31: (a != b and not isMapped[ord(a)][ord(b)])", "Line 18: (i in range(len(s)))", "Line 25: (start + len(sub) > len(s))"], ["Line 31: (a != b and not isMapped[ord(a)][ord(b)])", "Line 18: (i in range(len(s)))", "Line 28: (i in range(len(sub)))", "Line 28: (i in range(len(sub)))", "Line 28: (i in range(len(sub)))"], ["Line 18: (i in range(len(s)))", "Line 28: (i in range(len(sub)))", "Line 31: (a != b and not isMapped[ord(a)][ord(b)])", "Line 18: (i in range(len(s)))", "Line 28: (i in range(len(sub)))"]]}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "difficulty": 3, "func_name": "minimumScore", "description": "There is an undirected connected tree with `n` nodes labeled from `0` to `n -\n1` and `n - 1` edges.\n\nYou are given a 0-indexed integer array `nums` of length `n` where `nums[i]`\nrepresents the value of the `ith` node. You are also given a 2D integer array\n`edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is\nan edge between nodes `ai` and `bi` in the tree.\n\nRemove two distinct edges of the tree to form three connected components. For\na pair of removed edges, the following steps are defined:\n\n1. Get the XOR of all the values of the nodes for each of the three components respectively.\n2. The difference between the largest XOR value and the smallest XOR value is the score of the pair.\n\n* For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = 6`, `1 ^ 9 = 8`, and `3 ^ 3 ^ 3 = 3`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn the minimum score of any possible pair of edge removals on the given\ntree.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "blocks": [{"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 42, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 44, "end": 45, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 46, "end": 47, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 48, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [26, 38, 42, 45, 47, 49], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 19-22\\n')\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        log_function('LOOP #2: Entered for loop at line 24-29\\n')\n        if v == parent:\n          log_function('BRANCH #1: Covered if branch at line 25-26\\n')\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      log_function('LOOP #3: Entered for loop at line 35-51\\n')\n      a, b = edges[i]\n      if b in children[a]:\n        log_function('BRANCH #2: Covered if branch at line 37-38\\n')\n        a, b = b, a\n      for j in range(i):\n        log_function('LOOP #4: Entered for loop at line 39-51\\n')\n        c, d = edges[j]\n        if d in children[c]:\n          log_function('BRANCH #3: Covered if branch at line 41-42\\n')\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          log_function('BRANCH #4: Covered if branch at line 44-45\\n')\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          log_function('BRANCH #5: Covered elif branch at line 46-47\\n')\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          log_function('BRANCH #6: Covered else branch at line 48-49\\n')\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Score After Removals on a Tree.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 41-42\n", "BRANCH #6: Covered else branch at line 48-49\n", "LOOP #4: Entered for loop at line 39-51\n", "BRANCH #3: Covered if branch at line 41-42\n", "BRANCH #5: Covered elif branch at line 46-47\n"], ["LOOP #1: Entered for loop at line 19-22\n", "LOOP #1: Entered for loop at line 19-22\n", "LOOP #2: Entered for loop at line 24-29\n", "LOOP #2: Entered for loop at line 24-29\n", "BRANCH #1: Covered if branch at line 25-26\n"], ["BRANCH #6: Covered else branch at line 48-49\n", "LOOP #3: Entered for loop at line 35-51\n", "BRANCH #2: Covered if branch at line 37-38\n", "LOOP #4: Entered for loop at line 39-51\n", "BRANCH #3: Covered if branch at line 41-42\n"], ["LOOP #2: Entered for loop at line 24-29\n", "BRANCH #1: Covered if branch at line 25-26\n", "LOOP #2: Entered for loop at line 24-29\n", "LOOP #2: Entered for loop at line 24-29\n", "BRANCH #1: Covered if branch at line 25-26\n"]], "sampled_condition_paths": [["Line 41: (d in children[c])", "Line 44: NOT (c in children[a] and a != c)", "Line 46: NOT (a in children[c] and a != c)", "Line 48: ", "Line 39: (j in range(i))", "Line 41: (d in children[c])", "Line 44: NOT (c in children[a] and a != c)", "Line 46: (a in children[c] and a != c)"], ["Line 19: (u, v in edges)", "Line 19: (u, v in edges)", "Line 24: (v in tree[u])", "Line 24: (v in tree[u])", "Line 25: (v == parent)"], ["Line 44: NOT (c in children[a] and a != c)", "Line 46: NOT (a in children[c] and a != c)", "Line 48: ", "Line 35: (i in range(len(edges)))", "Line 37: (b in children[a])", "Line 39: (j in range(i))", "Line 41: (d in children[c])"], ["Line 24: (v in tree[u])", "Line 25: (v == parent)", "Line 24: (v in tree[u])", "Line 24: (v in tree[u])", "Line 25: (v == parent)"]]}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "difficulty": 2, "func_name": "latestTimeCatchTheBus", "description": "You are given a 0-indexed integer array `buses` of length `n`, where\n`buses[i]` represents the departure time of the `ith` bus. You are also given\na 0-indexed integer array `passengers` of length `m`, where `passengers[j]`\nrepresents the arrival time of the `jth` passenger. All bus departure times\nare unique. All passenger arrival times are unique.\n\nYou are given an integer `capacity`, which represents the maximum number of\npassengers that can get on each bus.\n\nWhen a passenger arrives, they will wait in line for the next available bus.\nYou can get on a bus that departs at `x` minutes if you arrive at `y` minutes\nwhere `y <= x`, and the bus is not full. Passengers with the earliest arrival\ntimes get on the bus first.\n\nMore formally when a bus arrives, either:\n\n* If `capacity` or fewer passengers are waiting for a bus, they will all get on the bus, or\n* The `capacity` passengers with the earliest arrival times will get on the bus.\n\nReturn the latest time you may arrive at the bus station to catch a bus. You\ncannot arrive at the same time as another passenger.\n\nNote: The arrays `buses` and `passengers` are not necessarily sorted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 26, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      log_function('BRANCH #1: Covered if branch at line 16-17\\n')\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      log_function('LOOP #1: Entered while loop at line 22-33\\n')\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        log_function('LOOP #2: Entered while loop at line 24-29\\n')\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        log_function('BRANCH #3: Covered if branch at line 30-31\\n')\n        ans = buses[i]\n      i += 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/The Latest Time to Catch a Bus.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 30-31\n", "LOOP #1: Entered while loop at line 22-33\n", "LOOP #2: Entered while loop at line 24-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #2: Entered while loop at line 24-29\n"], ["LOOP #1: Entered while loop at line 22-33\n", "LOOP #2: Entered while loop at line 24-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #2: Entered while loop at line 24-29\n", "BRANCH #2: Covered if branch at line 25-26\n"], ["BRANCH #2: Covered if branch at line 25-26\n", "LOOP #1: Entered while loop at line 22-33\n", "LOOP #2: Entered while loop at line 24-29\n", "BRANCH #2: Covered if branch at line 25-26\n", "LOOP #2: Entered while loop at line 24-29\n"], ["LOOP #2: Entered while loop at line 24-29\n", "BRANCH #3: Covered if branch at line 30-31\n", "LOOP #1: Entered while loop at line 22-33\n", "LOOP #2: Entered while loop at line 24-29\n", "BRANCH #2: Covered if branch at line 25-26\n"]], "sampled_condition_paths": [["Line 30: (arrived < capacity and j > 0 and passengers[j - 1] != buses[i])", "Line 22: (i < len(buses))", "Line 24: (arrived < capacity and j < len(passengers) and passengers[j] <= buses[i])", "Line 25: (j > 0 and passengers[j] != passengers[j - 1] + 1)", "Line 24: (arrived < capacity and j < len(passengers) and passengers[j] <= buses[i])"], ["Line 22: (i < len(buses))", "Line 24: (arrived < capacity and j < len(passengers) and passengers[j] <= buses[i])", "Line 25: (j > 0 and passengers[j] != passengers[j - 1] + 1)", "Line 24: (arrived < capacity and j < len(passengers) and passengers[j] <= buses[i])", "Line 25: (j > 0 and passengers[j] != passengers[j - 1] + 1)"], ["Line 25: (j > 0 and passengers[j] != passengers[j - 1] + 1)", "Line 22: (i < len(buses))", "Line 24: (arrived < capacity and j < len(passengers) and passengers[j] <= buses[i])", "Line 25: (j > 0 and passengers[j] != passengers[j - 1] + 1)", "Line 24: (arrived < capacity and j < len(passengers) and passengers[j] <= buses[i])"], ["Line 24: (arrived < capacity and j < len(passengers) and passengers[j] <= buses[i])", "Line 30: (arrived < capacity and j > 0 and passengers[j - 1] != buses[i])", "Line 22: (i < len(buses))", "Line 24: (arrived < capacity and j < len(passengers) and passengers[j] <= buses[i])", "Line 25: (j > 0 and passengers[j] != passengers[j - 1] + 1)"]]}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "difficulty": 2, "func_name": "canChange", "description": "You are given two strings `start` and `target`, both of length `n`. Each\nstring consists only of the characters `'L'`, `'R'`, and `'_'` where:\n\n* The characters `'L'` and `'R'` represent pieces, where a piece `'L'` can move to the left only if there is a blank space directly to its left, and a piece `'R'` can move to the right only if there is a blank space directly to its right.\n* The character `'_'` represents a blank space that can be occupied by any of the `'L'` or `'R'` pieces.\n\nReturn `true` if it is possible to obtain the string `target` by moving the\npieces of the string `start` any number of times. Otherwise, return `false`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.11320754716981132}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.03773584905660377}], "target_lines": [23, 25, 27, 29], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      log_function('LOOP #1: Entered while loop at line 17-32\\n')\n      while i < n and start[i] == '_':\n        log_function('LOOP #2: Entered while loop at line 18-19\\n')\n        i += 1\n      while j < n and target[j] == '_':\n        log_function('LOOP #3: Entered while loop at line 20-21\\n')\n        j += 1\n      if i == n or j == n:\n        log_function('BRANCH #1: Covered if branch at line 22-23\\n')\n        return i == n and j == n\n      if start[i] != target[j]:\n        log_function('BRANCH #2: Covered if branch at line 24-25\\n')\n        return False\n      if start[i] == 'R' and i > j:\n        log_function('BRANCH #3: Covered if branch at line 26-27\\n')\n        return False\n      if start[i] == 'L' and i < j:\n        log_function('BRANCH #4: Covered if branch at line 28-29\\n')\n        return False\n      i += 1\n      j += 1\n\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Move Pieces to Obtain a String.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered while loop at line 17-32\n", "LOOP #2: Entered while loop at line 18-19\n", "BRANCH #3: Covered if branch at line 26-27\n"], ["LOOP #1: Entered while loop at line 17-32\n", "LOOP #3: Entered while loop at line 20-21\n", "LOOP #3: Entered while loop at line 20-21\n", "BRANCH #2: Covered if branch at line 24-25\n"], ["LOOP #2: Entered while loop at line 18-19\n", "LOOP #1: Entered while loop at line 17-32\n", "LOOP #2: Entered while loop at line 18-19\n", "LOOP #2: Entered while loop at line 18-19\n", "LOOP #3: Entered while loop at line 20-21\n"], ["LOOP #3: Entered while loop at line 20-21\n", "LOOP #3: Entered while loop at line 20-21\n", "LOOP #3: Entered while loop at line 20-21\n", "LOOP #3: Entered while loop at line 20-21\n", "LOOP #3: Entered while loop at line 20-21\n"]], "sampled_condition_paths": [["Line 17: (i <= n and j <= n)", "Line 18: (i < n and start[i] == '_')", "Line 26: (start[i] == 'R' and i > j)"], ["Line 17: (i <= n and j <= n)", "Line 20: (j < n and target[j] == '_')", "Line 20: (j < n and target[j] == '_')", "Line 24: (start[i] != target[j])"], ["Line 18: (i < n and start[i] == '_')", "Line 17: (i <= n and j <= n)", "Line 18: (i < n and start[i] == '_')", "Line 18: (i < n and start[i] == '_')", "Line 20: (j < n and target[j] == '_')"], ["Line 20: (j < n and target[j] == '_')", "Line 20: (j < n and target[j] == '_')", "Line 20: (j < n and target[j] == '_')", "Line 20: (j < n and target[j] == '_')", "Line 20: (j < n and target[j] == '_')"]]}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "difficulty": 3, "func_name": "buildMatrix", "description": "You are given a positive integer `k`. You are also given:\n\n* a 2D integer array `rowConditions` of size `n` where `rowConditions[i] = [abovei, belowi]`, and\n* a 2D integer array `colConditions` of size `m` where `colConditions[i] = [lefti, righti]`.\n\nThe two arrays contain integers from `1` to `k`.\n\nYou have to build a `k x k` matrix that contains each of the numbers from `1`\nto `k` exactly once. The remaining cells should have the value `0`.\n\nThe matrix should also satisfy the following conditions:\n\n* The number `abovei` should appear in a row that is strictly above the row at which the number `belowi` appears for all `i` from `0` to `n - 1`.\n* The number `lefti` should appear in a column that is strictly left of the column at which the number `righti` appears for all `i` from `0` to `m - 1`.\n\nReturn any matrix that satisfies the conditions. If no answer exists, return\nan empty matrix.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}, {"type": "if", "start": 18, "end": 19, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 52, "end": 53, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "else", "start": 54, "end": 55, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 2, "eg_cov_prob": 0.11320754716981132}], "target_lines": [15, 19, 50, 53, 55], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      log_function('BRANCH #1: Covered if branch at line 14-15\\n')\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      log_function('BRANCH #2: Covered if branch at line 18-19\\n')\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      log_function('LOOP #1: Entered for loop at line 24-26\\n')\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      log_function('LOOP #2: Entered for loop at line 27-30\\n')\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      log_function('LOOP #3: Entered for loop at line 38-41\\n')\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      log_function('LOOP #4: Entered while loop at line 44-51\\n')\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        log_function('LOOP #5: Entered for loop at line 47-51\\n')\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          log_function('BRANCH #3: Covered if branch at line 49-50\\n')\n          q.append(v)\n\n    if len(order) == n:\n      log_function('BRANCH #4: Covered if branch at line 52-53\\n')\n      return order\n    else:\n      log_function('BRANCH #5: Covered else branch at line 54-55\\n')\n      return []\n\ndef log_function(info_str):\n    with open(\"test_logs/Build a Matrix With Conditions.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 49-50\n", "LOOP #4: Entered while loop at line 44-51\n", "LOOP #5: Entered for loop at line 47-51\n", "BRANCH #3: Covered if branch at line 49-50\n", "LOOP #4: Entered while loop at line 44-51\n"], ["LOOP #4: Entered while loop at line 44-51\n", "LOOP #5: Entered for loop at line 47-51\n", "BRANCH #3: Covered if branch at line 49-50\n", "LOOP #4: Entered while loop at line 44-51\n", "LOOP #5: Entered for loop at line 47-51\n"], ["LOOP #3: Entered for loop at line 38-41\n", "LOOP #3: Entered for loop at line 38-41\n", "LOOP #3: Entered for loop at line 38-41\n", "BRANCH #5: Covered else branch at line 54-55\n", "BRANCH #1: Covered if branch at line 14-15\n"]], "sampled_condition_paths": [["Line 49: (inDegrees[v] == 0)", "Line 44: (q)", "Line 47: (v in graph[u])", "Line 49: (inDegrees[v] == 0)", "Line 44: (q)"], ["Line 44: (q)", "Line 47: (v in graph[u])", "Line 49: (inDegrees[v] == 0)", "Line 44: (q)", "Line 47: (v in graph[u])"], ["Line 38: (u, v in conditions)", "Line 38: (u, v in conditions)", "Line 38: (u, v in conditions)", "Line 52: NOT (len(order) == n)", "Line 54: ", "Line 14: (not rowOrder)"]]}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "difficulty": 1, "func_name": "countTime", "description": "You are given a string of length `5` called `time`, representing the current\ntime on a digital clock in the format `\"hh:mm\"`. The earliest possible time is\n`\"00:00\"` and the latest possible time is `\"23:59\"`.\n\nIn the string `time`, the digits represented by the `?` symbol are unknown,\nand must be replaced with a digit from `0` to `9`.\n\nReturn an integer `answer`, the number of valid clock times that can be\ncreated by replacing every `?` with a digit from `0` to `9`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 1, "eg_cov_prob": 0.5471698113207547}, {"type": "if", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.33962264150943394}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.2830188679245283}, {"type": "if", "start": 21, "end": 25, "difficulty": 2, "eg_cov_prob": 0.18867924528301888}, {"type": "if", "start": 26, "end": 30, "difficulty": 2, "eg_cov_prob": 0.16981132075471697}, {"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "else", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.16981132075471697}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "else", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.09433962264150944}], "target_lines": [15, 17, 20, 22, 23, 25, 27, 28, 30], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      log_function('BRANCH #1: Covered if branch at line 14-15\\n')\n      ans *= 6\n    if time[4] == '?':\n      log_function('BRANCH #2: Covered if branch at line 16-17\\n')\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      log_function('BRANCH #3: Covered if branch at line 19-20\\n')\n      return ans * 24\n    if time[0] == '?':\n      log_function('BRANCH #4: Covered if branch at line 21-25\\n')\n      if time[1] < '4':\n        log_function('BRANCH #5: Covered if branch at line 22-23\\n')\n        return ans * 3\n      else:\n        log_function('BRANCH #6: Covered else branch at line 24-25\\n')\n        return ans * 2\n    if time[1] == '?':\n      log_function('BRANCH #7: Covered if branch at line 26-30\\n')\n      if time[0] == '2':\n        log_function('BRANCH #8: Covered if branch at line 27-28\\n')\n        return ans * 4\n      else:\n        log_function('BRANCH #9: Covered else branch at line 29-30\\n')\n        return ans * 10\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Valid Clock Times.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 14-15\n", "BRANCH #2: Covered if branch at line 16-17\n", "BRANCH #3: Covered if branch at line 19-20\n"], ["BRANCH #4: Covered if branch at line 21-25\n", "BRANCH #6: Covered else branch at line 24-25\n"], ["BRANCH #2: Covered if branch at line 16-17\n", "BRANCH #7: Covered if branch at line 26-30\n", "BRANCH #9: Covered else branch at line 29-30\n"]], "sampled_condition_paths": [["Line 14: (time[3] == '?')", "Line 16: (time[4] == '?')", "Line 19: (time[0] == '?' and time[1] == '?')"], ["Line 21: (time[0] == '?')", "Line 22: NOT (time[1] < '4')", "Line 24: "], ["Line 16: (time[4] == '?')", "Line 26: (time[1] == '?')", "Line 27: NOT (time[0] == '2')", "Line 29: "]]}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "difficulty": 2, "func_name": "mostPopularCreator", "description": "You are given two string arrays `creators` and `ids`, and an integer array\n`views`, all of length `n`. The `ith` video on a platform was created by\n`creator[i]`, has an id of `ids[i]`, and has `views[i]` views.\n\nThe popularity of a creator is the sum of the number of views on all of the\ncreator's videos. Find the creator with the highest popularity and the id of\ntheir most viewed video.\n\n* If multiple creators have the highest popularity, find all of them.\n* If multiple videos have the highest view count for a creator, find the lexicographically smallest id.\n\nReturn a 2D array of strings `answer` where `answer[i] = [creatori, idi]`\nmeans that `creatori` has the highest popularity and `idi` is the id of their\nmost popular video. The answer can be returned in any order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "blocks": [{"type": "if", "start": 25, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [26, 27, 28, 33, 34, 38], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      log_function('LOOP #1: Entered for loop at line 24-35\\n')\n      if name not in nameToCreator:\n        log_function('BRANCH #1: Covered if branch at line 25-28\\n')\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        log_function('BRANCH #2: Covered if branch at line 32-34\\n')\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      log_function('LOOP #2: Entered for loop at line 36-39\\n')\n      if creator.popularity == maxPopularity:\n        log_function('BRANCH #3: Covered if branch at line 37-38\\n')\n        ans.append([name, creator.videoId])\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Most Popular Video Creator.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 24-35\n", "LOOP #1: Entered for loop at line 24-35\n", "BRANCH #1: Covered if branch at line 25-28\n", "LOOP #2: Entered for loop at line 36-39\n", "BRANCH #3: Covered if branch at line 37-38\n"], ["LOOP #2: Entered for loop at line 36-39\n", "BRANCH #3: Covered if branch at line 37-38\n", "LOOP #2: Entered for loop at line 36-39\n", "BRANCH #3: Covered if branch at line 37-38\n", "LOOP #2: Entered for loop at line 36-39\n"], ["LOOP #1: Entered for loop at line 24-35\n", "BRANCH #2: Covered if branch at line 32-34\n", "LOOP #1: Entered for loop at line 24-35\n", "LOOP #2: Entered for loop at line 36-39\n", "BRANCH #3: Covered if branch at line 37-38\n"]], "sampled_condition_paths": [["Line 24: (name, id, view in zip(creators, ids, views))", "Line 24: (name, id, view in zip(creators, ids, views))", "Line 25: (name not in nameToCreator)", "Line 36: (name, creator in nameToCreator.items())", "Line 37: (creator.popularity == maxPopularity)"], ["Line 36: (name, creator in nameToCreator.items())", "Line 37: (creator.popularity == maxPopularity)", "Line 36: (name, creator in nameToCreator.items())", "Line 37: (creator.popularity == maxPopularity)", "Line 36: (name, creator in nameToCreator.items())"], ["Line 24: (name, id, view in zip(creators, ids, views))", "Line 32: (creator.maxView < view or creator.maxView == view and creator.videoId > id)", "Line 24: (name, id, view in zip(creators, ids, views))", "Line 36: (name, creator in nameToCreator.items())", "Line 37: (creator.popularity == maxPopularity)"]]}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "difficulty": 2, "func_name": "totalCost", "description": "You are given a 0-indexed integer array `costs` where `costs[i]` is the cost\nof hiring the `ith` worker.\n\nYou are also given two integers `k` and `candidates`. We want to hire exactly\n`k` workers according to the following rules:\n\n* You will run `k` sessions and hire exactly one worker in each session.\n* In each hiring session, choose the worker with the lowest cost from either the first `candidates` workers or the last `candidates` workers. Break the tie by the smallest index. \n* For example, if `costs = [3,2,7,7,1,2]` and `candidates = 2`, then in the first hiring session, we will choose the `4th` worker because they have the lowest cost `[3,2,7,7,1,2]`.\n* In the second hiring session, we will choose `1st` worker because they have the same lowest cost as `4th` worker but they have the smallest index `[3,2,7,7,2]`. Please note that the indexing may be changed in the process.\n* If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n* A worker can only be chosen once.\n\nReturn the total cost to hire exactly `k` workers.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 29, 31, 33], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      log_function('LOOP #1: Entered for loop at line 19-34\\n')\n      while len(minHeapL) < candidates and i <= j:\n        log_function('LOOP #2: Entered while loop at line 20-22\\n')\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        log_function('LOOP #3: Entered while loop at line 23-25\\n')\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        log_function('BRANCH #2: Covered elif branch at line 28-29\\n')\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        log_function('BRANCH #3: Covered elif branch at line 30-31\\n')\n        ans += heapq.heappop(minHeapL)\n      else:\n        log_function('BRANCH #4: Covered else branch at line 32-33\\n')\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Total Cost to Hire K Workers.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered while loop at line 23-25\n", "LOOP #3: Entered while loop at line 23-25\n", "LOOP #3: Entered while loop at line 23-25\n", "LOOP #3: Entered while loop at line 23-25\n", "BRANCH #3: Covered elif branch at line 30-31\n"], ["LOOP #2: Entered while loop at line 20-22\n", "LOOP #2: Entered while loop at line 20-22\n", "LOOP #2: Entered while loop at line 20-22\n", "LOOP #3: Entered while loop at line 23-25\n", "BRANCH #3: Covered elif branch at line 30-31\n"], ["LOOP #2: Entered while loop at line 20-22\n", "LOOP #3: Entered while loop at line 23-25\n", "BRANCH #3: Covered elif branch at line 30-31\n", "LOOP #1: Entered for loop at line 19-34\n", "BRANCH #4: Covered else branch at line 32-33\n"], ["LOOP #3: Entered while loop at line 23-25\n", "LOOP #3: Entered while loop at line 23-25\n", "BRANCH #3: Covered elif branch at line 30-31\n", "LOOP #1: Entered for loop at line 19-34\n", "LOOP #2: Entered while loop at line 20-22\n"]], "sampled_condition_paths": [["Line 23: (len(minHeapR) < candidates and i <= j)", "Line 23: (len(minHeapR) < candidates and i <= j)", "Line 23: (len(minHeapR) < candidates and i <= j)", "Line 23: (len(minHeapR) < candidates and i <= j)", "Line 26: NOT (not minHeapL)", "Line 28: NOT (not minHeapR)", "Line 30: (minHeapL[0] <= minHeapR[0])"], ["Line 20: (len(minHeapL) < candidates and i <= j)", "Line 20: (len(minHeapL) < candidates and i <= j)", "Line 20: (len(minHeapL) < candidates and i <= j)", "Line 23: (len(minHeapR) < candidates and i <= j)", "Line 26: NOT (not minHeapL)", "Line 28: NOT (not minHeapR)", "Line 30: (minHeapL[0] <= minHeapR[0])"], ["Line 20: (len(minHeapL) < candidates and i <= j)", "Line 23: (len(minHeapR) < candidates and i <= j)", "Line 26: NOT (not minHeapL)", "Line 28: NOT (not minHeapR)", "Line 30: (minHeapL[0] <= minHeapR[0])", "Line 19: (_ in range(k))", "Line 26: NOT (not minHeapL)", "Line 28: NOT (not minHeapR)", "Line 30: NOT (minHeapL[0] <= minHeapR[0])", "Line 32: "], ["Line 23: (len(minHeapR) < candidates and i <= j)", "Line 23: (len(minHeapR) < candidates and i <= j)", "Line 26: NOT (not minHeapL)", "Line 28: NOT (not minHeapR)", "Line 30: (minHeapL[0] <= minHeapR[0])", "Line 19: (_ in range(k))", "Line 20: (len(minHeapL) < candidates and i <= j)"]]}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "difficulty": 2, "func_name": "mostProfitablePath", "description": "There is an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted\nat node `0`. You are given a 2D integer array `edges` of length `n - 1` where\n`edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and\n`bi` in the tree.\n\nAt every node `i`, there is a gate. You are also given an array of even\nintegers `amount`, where `amount[i]` represents:\n\n* the price needed to open the gate at node `i`, if `amount[i]` is negative, or,\n* the cash reward obtained on opening the gate at node `i`, otherwise.\n\nThe game goes on as follows:\n\n* Initially, Alice is at node `0` and Bob is at node `bob`.\n* At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node `0`.\n* For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that: \n* If the gate is already open, no price will be required, nor will there be any cash reward.\n* If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each.\n* If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are independent of each other.\n\nReturn the maximum net income Alice can have if she travels towards the\noptimal leaf node.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "blocks": [{"type": "if", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.37735849056603776}], "target_lines": [27, 35, 37, 45, 50], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 18-21\\n')\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        log_function('LOOP #2: Entered for loop at line 25-28\\n')\n        if aliceDist[v] == -1:\n          log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      log_function('LOOP #3: Entered while loop at line 33-40\\n')\n      if bobDist < aliceDist[u]:\n        log_function('BRANCH #2: Covered if branch at line 34-35\\n')\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        log_function('BRANCH #3: Covered elif branch at line 36-37\\n')\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      log_function('BRANCH #4: Covered if branch at line 44-45\\n')\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      log_function('LOOP #4: Entered for loop at line 48-51\\n')\n      if v != prev:\n        log_function('BRANCH #5: Covered if branch at line 49-50\\n')\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n\ndef log_function(info_str):\n    with open(\"test_logs/Most Profitable Path in a Tree.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 18-21\n", "LOOP #1: Entered for loop at line 18-21\n", "LOOP #1: Entered for loop at line 18-21\n", "LOOP #2: Entered for loop at line 25-28\n", "BRANCH #1: Covered if branch at line 26-27\n"], ["LOOP #2: Entered for loop at line 25-28\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 25-28\n", "LOOP #3: Entered while loop at line 33-40\n", "BRANCH #2: Covered if branch at line 34-35\n"], ["LOOP #2: Entered for loop at line 25-28\n", "LOOP #3: Entered while loop at line 33-40\n", "BRANCH #2: Covered if branch at line 34-35\n", "LOOP #4: Entered for loop at line 48-51\n", "BRANCH #5: Covered if branch at line 49-50\n"], ["LOOP #3: Entered while loop at line 33-40\n", "BRANCH #2: Covered if branch at line 34-35\n", "LOOP #3: Entered while loop at line 33-40\n", "BRANCH #3: Covered elif branch at line 36-37\n", "LOOP #4: Entered for loop at line 48-51\n"]], "sampled_condition_paths": [["Line 18: (u, v in edges)", "Line 18: (u, v in edges)", "Line 18: (u, v in edges)", "Line 25: (v in tree[u])", "Line 26: (aliceDist[v] == -1)"], ["Line 25: (v in tree[u])", "Line 26: (aliceDist[v] == -1)", "Line 25: (v in tree[u])", "Line 33: (u != 0)", "Line 34: (bobDist < aliceDist[u])"], ["Line 25: (v in tree[u])", "Line 33: (u != 0)", "Line 34: (bobDist < aliceDist[u])", "Line 48: (v in tree[u])", "Line 49: (v != prev)"], ["Line 33: (u != 0)", "Line 34: (bobDist < aliceDist[u])", "Line 33: (u != 0)", "Line 34: NOT (bobDist < aliceDist[u])", "Line 36: (bobDist == aliceDist[u])", "Line 48: (v in tree[u])"]]}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "difficulty": 3, "func_name": "minimumTotalCost", "description": "You are given two 0-indexed integer arrays `nums1` and `nums2`, of equal\nlength `n`.\n\nIn one operation, you can swap the values of any two indices of `nums1`. The\ncost of this operation is the sum of the indices.\n\nFind the minimum total cost of performing the given operation any number of\ntimes such that `nums1[i] != nums2[i]` for all `0 <= i <= n - 1` after\nperforming all the operations.\n\nReturn the minimum total cost such that `nums1` and `nums2` satisfy the above\ncondition. In case it is not possible, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "blocks": [{"type": "if", "start": 41, "end": 42, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 28, "difficulty": 1, "eg_cov_prob": 0.5471698113207547}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 26, "difficulty": 1, "eg_cov_prob": 0.5471698113207547}], "target_lines": [22, 23, 24, 25, 26, 27, 28, 32, 34, 37, 42, 44], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      log_function('LOOP #1: Entered for loop at line 20-29\\n')\n      if num1 == num2:\n        log_function('BRANCH #1: Covered if branch at line 21-28\\n')\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          log_function('BRANCH #2: Covered if branch at line 24-26\\n')\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      log_function('LOOP #2: Entered for loop at line 30-40\\n')\n      if maxFreq * 2 <= shouldBeSwapped:\n        log_function('BRANCH #3: Covered if branch at line 31-32\\n')\n        break\n      if num1 == num2:\n        log_function('BRANCH #4: Covered if branch at line 33-34\\n')\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        log_function('BRANCH #5: Covered if branch at line 36-37\\n')\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      log_function('BRANCH #6: Covered if branch at line 41-42\\n')\n      return -1\n    else:\n      log_function('BRANCH #7: Covered else branch at line 43-44\\n')\n      return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Total Cost to Make Arrays Unequal.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 21-28\n", "BRANCH #2: Covered if branch at line 24-26\n", "LOOP #1: Entered for loop at line 20-29\n", "BRANCH #1: Covered if branch at line 21-28\n", "LOOP #1: Entered for loop at line 20-29\n"], ["BRANCH #5: Covered if branch at line 36-37\n", "LOOP #2: Entered for loop at line 30-40\n", "BRANCH #4: Covered if branch at line 33-34\n", "LOOP #2: Entered for loop at line 30-40\n", "BRANCH #4: Covered if branch at line 33-34\n"], ["BRANCH #2: Covered if branch at line 24-26\n", "LOOP #1: Entered for loop at line 20-29\n", "BRANCH #1: Covered if branch at line 21-28\n", "LOOP #1: Entered for loop at line 20-29\n", "BRANCH #1: Covered if branch at line 21-28\n"], ["LOOP #1: Entered for loop at line 20-29\n", "BRANCH #1: Covered if branch at line 21-28\n", "BRANCH #2: Covered if branch at line 24-26\n", "LOOP #1: Entered for loop at line 20-29\n", "LOOP #1: Entered for loop at line 20-29\n"], ["BRANCH #1: Covered if branch at line 21-28\n", "LOOP #1: Entered for loop at line 20-29\n", "BRANCH #1: Covered if branch at line 21-28\n", "LOOP #1: Entered for loop at line 20-29\n", "BRANCH #1: Covered if branch at line 21-28\n"]], "sampled_condition_paths": [["Line 21: (num1 == num2)", "Line 24: (conflictedNumCount[conflictedNum] > maxFreq)", "Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 21: (num1 == num2)", "Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))"], ["Line 36: (num1 == maxFreqNum or num2 == maxFreqNum)", "Line 30: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 33: (num1 == num2)", "Line 30: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 33: (num1 == num2)"], ["Line 24: (conflictedNumCount[conflictedNum] > maxFreq)", "Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 21: (num1 == num2)", "Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 21: (num1 == num2)"], ["Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 21: (num1 == num2)", "Line 24: (conflictedNumCount[conflictedNum] > maxFreq)", "Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))"], ["Line 21: (num1 == num2)", "Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 21: (num1 == num2)", "Line 20: (i, (num1, num2) in enumerate(zip(nums1, nums2)))", "Line 21: (num1 == num2)"]]}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "difficulty": 3, "func_name": "maxPoints", "description": "You are given an `m x n` integer matrix `grid` and an array `queries` of size\n`k`.\n\nFind an array `answer` of size `k` such that for each integer `queries[i]` you\nstart in the top left cell of the matrix and repeat the following process:\n\n* If `queries[i]` is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all `4` directions: up, down, left, and right.\n* Otherwise, you do not get any points, and you end this process.\n\nAfter the process, `answer[i]` is the maximum number of points you can get.\nNote that for each query you are allowed to visit the same cell multiple\ntimes.\n\nReturn the resulting array `answer`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "blocks": [{"type": "if", "start": 34, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 42, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [35, 36, 42, 44], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      log_function('LOOP #1: Entered for loop at line 31-48\\n')\n      while minHeap:\n        log_function('LOOP #2: Entered while loop at line 32-46\\n')\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          log_function('BRANCH #1: Covered if branch at line 34-36\\n')\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          log_function('LOOP #3: Entered for loop at line 38-46\\n')\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            log_function('BRANCH #2: Covered if branch at line 41-42\\n')\n            continue\n          if (x, y) in seen:\n            log_function('BRANCH #3: Covered if branch at line 43-44\\n')\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Number of Points From Grid Queries.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 38-46\n", "LOOP #3: Entered for loop at line 38-46\n", "BRANCH #2: Covered if branch at line 41-42\n", "LOOP #3: Entered for loop at line 38-46\n", "BRANCH #2: Covered if branch at line 41-42\n"], ["LOOP #2: Entered while loop at line 32-46\n", "LOOP #3: Entered for loop at line 38-46\n", "BRANCH #2: Covered if branch at line 41-42\n", "LOOP #3: Entered for loop at line 38-46\n", "LOOP #3: Entered for loop at line 38-46\n"], ["LOOP #1: Entered for loop at line 31-48\n", "LOOP #2: Entered while loop at line 32-46\n", "BRANCH #1: Covered if branch at line 34-36\n"]], "sampled_condition_paths": [["Line 38: (dx, dy in dirs)", "Line 38: (dx, dy in dirs)", "Line 41: (x < 0 or x == m or y < 0 or y == n)", "Line 38: (dx, dy in dirs)", "Line 41: (x < 0 or x == m or y < 0 or y == n)"], ["Line 32: (minHeap)", "Line 38: (dx, dy in dirs)", "Line 41: (x < 0 or x == m or y < 0 or y == n)", "Line 38: (dx, dy in dirs)", "Line 38: (dx, dy in dirs)"], ["Line 31: (queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query))", "Line 32: (minHeap)", "Line 34: (val >= query)"]]}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "difficulty": 3, "func_name": "isPossible", "description": "There is an undirected graph consisting of `n` nodes numbered from `1` to `n`.\nYou are given the integer `n` and a 2D array `edges` where `edges[i] = [ai,\nbi]` indicates that there is an edge between nodes `ai` and `bi`. The graph\ncan be disconnected.\n\nYou can add at most two additional edges (possibly none) to this graph so that\nthere are no repeated edges and no self-loops.\n\nReturn `true` if it is possible to make the degree of each node in the graph\neven, otherwise return `false`.\n\nThe degree of a node is the number of edges connected to it.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 22, "end": 24, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 25, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [21, 23, 24, 26, 27], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 15-18\\n')\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n      return True\n    if len(oddNodes) == 2:\n      log_function('BRANCH #2: Covered if branch at line 22-24\\n')\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      log_function('BRANCH #3: Covered if branch at line 25-27\\n')\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n\ndef log_function(info_str):\n    with open(\"test_logs/Add Edges to Make Degrees of All Nodes Even.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n"], ["LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "BRANCH #3: Covered if branch at line 25-27\n"], ["LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "BRANCH #3: Covered if branch at line 25-27\n"]], "sampled_condition_paths": [["Line 15: (u, v in edges)", "Line 15: (u, v in edges)", "Line 15: (u, v in edges)", "Line 15: (u, v in edges)", "Line 15: (u, v in edges)"], ["Line 15: (u, v in edges)", "Line 15: (u, v in edges)", "Line 15: (u, v in edges)", "Line 25: (len(oddNodes) == 4)"], ["Line 15: (u, v in edges)", "Line 15: (u, v in edges)", "Line 25: (len(oddNodes) == 4)"]]}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "difficulty": 2, "func_name": "closestPrimes", "description": "Given two positive integers `left` and `right`, find the two integers `num1`\nand `num2` such that:\n\n* `left <= num1 < num2 <= right `.\n* `num1` and `num2` are both prime numbers.\n* `num2 - num1` is the minimum amongst all other pairs satisfying the above conditions.\n\nReturn the positive integer array `ans = [num1, num2]`. If there are multiple\npairs satisfying these conditions, return the one with the minimum `num1`\nvalue or `[-1, -1]` if such numbers do not exist.\n\nA number greater than `1` is called prime if it is only divisible by `1` and\nitself.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 16, "end": 17, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 40, "end": 42, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 20, 29, 30, 31, 41, 42], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      log_function('LOOP #1: Entered for loop at line 15-18\\n')\n      if isPrime[i]:\n        log_function('BRANCH #1: Covered if branch at line 16-17\\n')\n        primes.append(i)\n\n    if len(primes) < 2:\n      log_function('BRANCH #2: Covered if branch at line 19-20\\n')\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      log_function('LOOP #2: Entered for loop at line 26-32\\n')\n      diff = b - a\n      if diff < minDiff:\n        log_function('BRANCH #3: Covered if branch at line 28-31\\n')\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      log_function('LOOP #3: Entered for loop at line 39-42\\n')\n      if isPrime[i]:\n        log_function('BRANCH #4: Covered if branch at line 40-42\\n')\n        for j in range(i * i, n, i):\n          log_function('LOOP #4: Entered for loop at line 41-42\\n')\n          isPrime[j] = False\n    return isPrime\n\ndef log_function(info_str):\n    with open(\"test_logs/Closest Prime Numbers in Range.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #4: Covered if branch at line 40-42\n", "LOOP #4: Entered for loop at line 41-42\n", "LOOP #4: Entered for loop at line 41-42\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n"], ["LOOP #4: Entered for loop at line 41-42\n", "LOOP #4: Entered for loop at line 41-42\n", "LOOP #4: Entered for loop at line 41-42\n", "LOOP #4: Entered for loop at line 41-42\n", "LOOP #4: Entered for loop at line 41-42\n"], ["LOOP #4: Entered for loop at line 41-42\n", "LOOP #4: Entered for loop at line 41-42\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "BRANCH #1: Covered if branch at line 16-17\n"], ["LOOP #3: Entered for loop at line 39-42\n", "LOOP #1: Entered for loop at line 15-18\n", "LOOP #1: Entered for loop at line 15-18\n", "BRANCH #1: Covered if branch at line 16-17\n", "LOOP #1: Entered for loop at line 15-18\n"]], "sampled_condition_paths": [["Line 40: (isPrime[i])", "Line 41: (j in range(i * i, n, i))", "Line 41: (j in range(i * i, n, i))", "Line 15: (i in range(left, right+1))", "Line 15: (i in range(left, right+1))"], ["Line 41: (j in range(i * i, n, i))", "Line 41: (j in range(i * i, n, i))", "Line 41: (j in range(i * i, n, i))", "Line 41: (j in range(i * i, n, i))", "Line 41: (j in range(i * i, n, i))"], ["Line 41: (j in range(i * i, n, i))", "Line 41: (j in range(i * i, n, i))", "Line 15: (i in range(left, right+1))", "Line 15: (i in range(left, right+1))", "Line 16: (isPrime[i])"], ["Line 39: (i in range(2, int(n**0.5) + 1))", "Line 15: (i in range(left, right+1))", "Line 15: (i in range(left, right+1))", "Line 16: (isPrime[i])", "Line 15: (i in range(left, right+1))"]]}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "difficulty": 3, "func_name": "findCrossingTime", "description": "There are `k` workers who want to move `n` boxes from an old warehouse to a\nnew one. You are given the two integers `n` and `k`, and a 2D integer array\n`time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti,\nputNewi]`.\n\nThe warehouses are separated by a river and connected by a bridge. The old\nwarehouse is on the right bank of the river, and the new warehouse is on the\nleft bank of the river. Initially, all `k` workers are waiting on the left\nside of the bridge. To move the boxes, the `ith` worker (0-indexed) can :\n\n* Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.\n* Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.\n* Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.\n* Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.\n\nA worker `i` is less efficient than a worker `j` if either condition is met:\n\n* `leftToRighti + rightToLefti > leftToRightj + rightToLeftj`\n* `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j`\n\nThe following rules regulate the movement of the workers through the bridge :\n\n* If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.\n* If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\n* If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\n\nReturn the instance of time at which the last worker reaches the left bank of\nthe river after all n boxes have been put in the new warehouse.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "blocks": [{"type": "if", "start": 28, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 37, "end": 46, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}, {"type": "if", "start": 38, "end": 39, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}, {"type": "if", "start": 42, "end": 43, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}, {"type": "else", "start": 44, "end": 45, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [29, 30, 31, 33, 34, 35, 36, 38, 39, 41, 42, 43, 45, 46], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      log_function('LOOP #1: Entered while loop at line 21-47\\n')\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        log_function('LOOP #2: Entered while loop at line 22-24\\n')\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        log_function('LOOP #3: Entered while loop at line 25-27\\n')\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        log_function('BRANCH #1: Covered if branch at line 28-31\\n')\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        log_function('BRANCH #2: Covered elif branch at line 32-36\\n')\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        log_function('BRANCH #3: Covered else branch at line 37-46\\n')\n        if leftWorkers and n > 0:\n          log_function('BRANCH #4: Covered if branch at line 38-39\\n')\n          ans1=leftWorkers[0][0]\n        else:\n          log_function('BRANCH #5: Covered else branch at line 40-41\\n')\n          ans1=math.inf\n        if rightWorkers:\n          log_function('BRANCH #6: Covered if branch at line 42-43\\n')\n          ans2=rightWorkers[0][0]\n        else:\n          log_function('BRANCH #7: Covered else branch at line 44-45\\n')\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans\ndef log_function(info_str):\n    with open(\"test_logs/Time to Cross a Bridge.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered else branch at line 37-46\n", "BRANCH #5: Covered else branch at line 40-41\n", "BRANCH #6: Covered if branch at line 42-43\n", "LOOP #1: Entered while loop at line 21-47\n", "LOOP #3: Entered while loop at line 25-27\n"], ["BRANCH #3: Covered else branch at line 37-46\n", "BRANCH #4: Covered if branch at line 38-39\n", "BRANCH #7: Covered else branch at line 44-45\n", "LOOP #1: Entered while loop at line 21-47\n", "LOOP #2: Entered while loop at line 22-24\n"]], "sampled_condition_paths": [["Line 28: NOT (rightBridgeQueue)", "Line 32: NOT (leftBridgeQueue and n > 0)", "Line 37: ", "Line 38: NOT (leftWorkers and n > 0)", "Line 40: ", "Line 42: (rightWorkers)", "Line 21: (n > 0 or rightBridgeQueue or rightWorkers)", "Line 25: (rightWorkers and rightWorkers[0][0] <= ans)"], ["Line 28: NOT (rightBridgeQueue)", "Line 32: NOT (leftBridgeQueue and n > 0)", "Line 37: ", "Line 38: (leftWorkers and n > 0)", "Line 42: NOT (rightWorkers)", "Line 44: ", "Line 21: (n > 0 or rightBridgeQueue or rightWorkers)", "Line 22: (leftWorkers and leftWorkers[0][0] <= ans)"]]}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "difficulty": 3, "func_name": "minimumTime", "description": "You are given a `m x n` matrix `grid` consisting of non-negative integers\nwhere `grid[row][col]` represents the minimum time required to be able to\nvisit the cell `(row, col)`, which means you can visit the cell `(row, col)`\nonly when the time you visit it is greater than or equal to `grid[row][col]`.\n\nYou are standing in the top-left cell of the matrix in the `0th` second, and\nyou must move to any adjacent cell in the four directions: up, down, left, and\nright. Each move you make takes 1 second.\n\nReturn the minimum time required in which you can visit the bottom-right cell\nof the matrix. If you cannot visit the bottom-right cell, then return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 35, "end": 36, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 25, 30, 32, 34, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      log_function('LOOP #1: Entered while loop at line 22-40\\n')\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        log_function('BRANCH #2: Covered if branch at line 24-25\\n')\n        return time\n      for dx, dy in dirs:\n        log_function('LOOP #2: Entered for loop at line 26-40\\n')\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          log_function('BRANCH #3: Covered if branch at line 29-30\\n')\n          continue\n        if (x, y) in seen:\n          log_function('BRANCH #4: Covered if branch at line 31-32\\n')\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          log_function('BRANCH #5: Covered if branch at line 33-34\\n')\n          extraWait = 1\n        else:\n          log_function('BRANCH #6: Covered else branch at line 35-36\\n')\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Time to Visit a Cell In a Grid.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 29-30\n", "LOOP #2: Entered for loop at line 26-40\n", "BRANCH #4: Covered if branch at line 31-32\n", "LOOP #1: Entered while loop at line 22-40\n", "LOOP #2: Entered for loop at line 26-40\n"], ["BRANCH #1: Covered if branch at line 13-14\n"], ["BRANCH #6: Covered else branch at line 35-36\n", "LOOP #2: Entered for loop at line 26-40\n", "BRANCH #4: Covered if branch at line 31-32\n", "LOOP #2: Entered for loop at line 26-40\n", "BRANCH #4: Covered if branch at line 31-32\n"]], "sampled_condition_paths": [["Line 29: (x < 0 or x == m or y < 0 or y == n)", "Line 26: (dx, dy in dirs)", "Line 31: ((x, y) in seen)", "Line 22: (minHeap)", "Line 26: (dx, dy in dirs)"], ["Line 13: (grid[0][1] > 1 and grid[1][0] > 1)"], ["Line 33: NOT ((grid[x][y] - time) % 2 == 0)", "Line 35: ", "Line 26: (dx, dy in dirs)", "Line 31: ((x, y) in seen)", "Line 26: (dx, dy in dirs)", "Line 31: ((x, y) in seen)"]]}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "difficulty": 2, "func_name": "primeSubOperation", "description": "You are given a 0-indexed integer array `nums` of length `n`.\n\nYou can perform the following operation as many times as you want:\n\n* Pick an index `i` that you haven\u2019t picked before, and pick a prime `p` strictly less than `nums[i]`, then subtract `p` from `nums[i]`.\n\nReturn true if you can make `nums` a strictly increasing array using the above\noperation and false otherwise.\n\nA strictly increasing array is an array whose each element is strictly greater\nthan its preceding element.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 33, 34], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      log_function('LOOP #1: Entered for loop at line 17-24\\n')\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n        num -= primes[i - 1]\n      if num <= prevNum:\n        log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      log_function('LOOP #2: Entered for loop at line 31-34\\n')\n      if isPrime[i]:\n        log_function('BRANCH #3: Covered if branch at line 32-34\\n')\n        for j in range(i * i, n, i):\n          log_function('LOOP #3: Entered for loop at line 33-34\\n')\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n\ndef log_function(info_str):\n    with open(\"test_logs/Prime Subtraction Operation.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 33-34\n", "LOOP #3: Entered for loop at line 33-34\n", "LOOP #3: Entered for loop at line 33-34\n", "LOOP #3: Entered for loop at line 33-34\n", "LOOP #3: Entered for loop at line 33-34\n"]], "sampled_condition_paths": [["Line 33: (j in range(i * i, n, i))", "Line 33: (j in range(i * i, n, i))", "Line 33: (j in range(i * i, n, i))", "Line 33: (j in range(i * i, n, i))", "Line 33: (j in range(i * i, n, i))"]]}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "difficulty": 3, "func_name": "collectTheCoins", "description": "There exists an undirected and unrooted tree with `n` nodes indexed from `0`\nto `n - 1`. You are given an integer `n` and a 2D integer array edges of\nlength `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge\nbetween nodes `ai` and `bi` in the tree. You are also given an array `coins`\nof size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the\npresence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can\nperform the following operations any number of times:\n\n* Collect all the coins that are at a distance of at most `2` from the current vertex, or\n* Move to any adjacent vertex in the tree.\n\nFind the minimum number of edges you need to go through to collect all the\ncoins and go back to the initial vertex.\n\nNote that if you pass an edge several times, you need to count it into the\nanswer several times.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 33, 34, 35, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 17-20\\n')\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      log_function('LOOP #2: Entered for loop at line 21-28\\n')\n      while len(tree[u]) == 1 and coins[u] == 0:\n        log_function('LOOP #3: Entered while loop at line 22-25\\n')\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      log_function('LOOP #4: Entered for loop at line 29-37\\n')\n      for _ in range(len(leavesToBeRemoved)):\n        log_function('LOOP #5: Entered for loop at line 30-37\\n')\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          log_function('BRANCH #2: Covered if branch at line 32-36\\n')\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            log_function('BRANCH #3: Covered if branch at line 35-36\\n')\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n\ndef log_function(info_str):\n    with open(\"test_logs/Collect Coins in a Tree.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 21-28\n", "LOOP #2: Entered for loop at line 21-28\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #4: Entered for loop at line 29-37\n", "LOOP #5: Entered for loop at line 30-37\n"], ["LOOP #4: Entered for loop at line 29-37\n", "LOOP #5: Entered for loop at line 30-37\n", "BRANCH #2: Covered if branch at line 32-36\n", "LOOP #5: Entered for loop at line 30-37\n", "BRANCH #2: Covered if branch at line 32-36\n"], ["LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n", "LOOP #2: Entered for loop at line 21-28\n"], ["LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n", "LOOP #1: Entered for loop at line 17-20\n", "LOOP #2: Entered for loop at line 21-28\n", "LOOP #2: Entered for loop at line 21-28\n"]], "sampled_condition_paths": [["Line 21: (u in range(n))", "Line 21: (u in range(n))", "Line 26: (len(tree[u]) == 1)", "Line 29: (_ in range(2))", "Line 30: (_ in range(len(leavesToBeRemoved)))"], ["Line 29: (_ in range(2))", "Line 30: (_ in range(len(leavesToBeRemoved)))", "Line 32: (tree[u])", "Line 30: (_ in range(len(leavesToBeRemoved)))", "Line 32: (tree[u])"], ["Line 17: (u, v in edges)", "Line 17: (u, v in edges)", "Line 17: (u, v in edges)", "Line 17: (u, v in edges)", "Line 21: (u in range(n))"], ["Line 17: (u, v in edges)", "Line 17: (u, v in edges)", "Line 17: (u, v in edges)", "Line 21: (u in range(n))", "Line 21: (u in range(n))"]]}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "difficulty": 2, "func_name": "getSubarrayBeauty", "description": "Given an integer array `nums` containing `n` integers, find the beauty of each\nsubarray of size `k`.\n\nThe beauty of a subarray is the `xth` smallest integer in the subarray if it\nis negative, or `0` if there are fewer than `x` negative integers.\n\nReturn an integer array containing `n - k + 1` integers, which denote the\nbeauty of the subarrays in order from the first index in the array.\n\n* A subarray is a contiguous non-empty sequence of elements within an array.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "blocks": [{"type": "if", "start": 17, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.5094339622641509}], "target_lines": [18, 20, 22, 31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      log_function('LOOP #1: Entered for loop at line 16-23\\n')\n      if num < 0:\n        log_function('BRANCH #1: Covered if branch at line 17-18\\n')\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        log_function('BRANCH #2: Covered if branch at line 19-20\\n')\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        log_function('BRANCH #3: Covered if branch at line 21-22\\n')\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      log_function('LOOP #2: Entered for loop at line 28-31\\n')\n      prefix += count[i]\n      if prefix >= x:\n        log_function('BRANCH #4: Covered if branch at line 30-31\\n')\n        return i - 50\n    return 0\n\ndef log_function(info_str):\n    with open(\"test_logs/Sliding Subarray Beauty.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n"], ["LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "LOOP #2: Entered for loop at line 28-31\n", "BRANCH #4: Covered if branch at line 30-31\n"]], "sampled_condition_paths": [["Line 28: (i in range(50))", "Line 28: (i in range(50))", "Line 28: (i in range(50))", "Line 28: (i in range(50))", "Line 28: (i in range(50))"], ["Line 28: (i in range(50))", "Line 28: (i in range(50))", "Line 28: (i in range(50))", "Line 28: (i in range(50))", "Line 30: (prefix >= x)"]]}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "difficulty": 2, "func_name": "minimumCost", "description": "You are given an array `start` where `start = [startX, startY]` represents\nyour initial position `(startX, startY)` in a 2D space. You are also given the\narray `target` where `target = [targetX, targetY]` represents your target\nposition `(targetX, targetY)`.\n\nThe cost of going from a position `(x1, y1)` to any other position in the\nspace `(x2, y2)` is `|x2 - x1| + |y2 - y1|`.\n\nThere are also some special roads. You are given a 2D array `specialRoads`\nwhere `specialRoads[i] = [x1i, y1i, x2i, y2i, costi]` indicates that the `ith`\nspecial road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal\nto `costi`. You can use each special road any number of times.\n\nReturn the minimum cost required to go from `(startX, startY)` to `(targetX,\ntargetY)`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 1, "eg_cov_prob": 0.9056603773584906}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 37, "difficulty": 1, "eg_cov_prob": 0.9056603773584906}], "target_lines": [28, 32, 36, 37], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      log_function('LOOP #1: Entered for loop at line 20-24\\n')\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      log_function('LOOP #2: Entered while loop at line 25-38\\n')\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        log_function('BRANCH #1: Covered if branch at line 27-28\\n')\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        log_function('LOOP #3: Entered for loop at line 30-38\\n')\n        if v == u:\n          log_function('BRANCH #2: Covered if branch at line 31-32\\n')\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          log_function('BRANCH #3: Covered if branch at line 35-37\\n')\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      log_function('LOOP #4: Entered for loop at line 40-43\\n')\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Cost of a Path With Special Roads.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 30-38\n", "BRANCH #2: Covered if branch at line 31-32\n", "LOOP #3: Entered for loop at line 30-38\n", "LOOP #3: Entered for loop at line 30-38\n", "LOOP #2: Entered while loop at line 25-38\n"], ["LOOP #2: Entered while loop at line 25-38\n", "LOOP #3: Entered for loop at line 30-38\n", "BRANCH #2: Covered if branch at line 31-32\n", "LOOP #3: Entered for loop at line 30-38\n", "BRANCH #3: Covered if branch at line 35-37\n"], ["BRANCH #2: Covered if branch at line 31-32\n", "LOOP #3: Entered for loop at line 30-38\n", "BRANCH #3: Covered if branch at line 35-37\n", "LOOP #2: Entered while loop at line 25-38\n", "LOOP #3: Entered for loop at line 30-38\n"], ["LOOP #3: Entered for loop at line 30-38\n", "BRANCH #2: Covered if branch at line 31-32\n", "LOOP #3: Entered for loop at line 30-38\n", "LOOP #2: Entered while loop at line 25-38\n", "LOOP #3: Entered for loop at line 30-38\n"]], "sampled_condition_paths": [["Line 30: (v in range(n))", "Line 31: (v == u)", "Line 30: (v in range(n))", "Line 30: (v in range(n))", "Line 25: (minHeap)"], ["Line 25: (minHeap)", "Line 30: (v in range(n))", "Line 31: (v == u)", "Line 30: (v in range(n))", "Line 35: (newDist < dist[v])"], ["Line 31: (v == u)", "Line 30: (v in range(n))", "Line 35: (newDist < dist[v])", "Line 25: (minHeap)", "Line 30: (v in range(n))"], ["Line 30: (v in range(n))", "Line 31: (v == u)", "Line 30: (v in range(n))", "Line 25: (minHeap)", "Line 30: (v in range(n))"]]}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "difficulty": 3, "func_name": "smallestBeautifulString", "description": "A string is beautiful if:\n\n* It consists of the first `k` letters of the English lowercase alphabet.\n* It does not contain any substring of length `2` or more which is a palindrome.\n\nYou are given a beautiful string `s` of length `n` and a positive integer `k`.\n\nReturn the lexicographically smallest string of length `n`, which is larger\nthan `s` and is beautiful. If there is no such string, return an empty string.\n\nA string `a` is lexicographically larger than a string `b` (of the same\nlength) if in the first position where `a` and `b` differ, `a` has a character\nstrictly larger than the corresponding character in `b`.\n\n* For example, `\"abcd\"` is lexicographically larger than `\"abcc\"` because the first position they differ is at the fourth character, and `d` is greater than `c`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [20], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      log_function('LOOP #1: Entered for loop at line 15-21\\n')\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        log_function('LOOP #2: Entered while loop at line 17-18\\n')\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      log_function('LOOP #3: Entered for loop at line 28-31\\n')\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        log_function('LOOP #4: Entered while loop at line 30-31\\n')\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n\ndef log_function(info_str):\n    with open(\"test_logs/Lexicographically Smallest Beautiful String.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 15-21\n", "LOOP #1: Entered for loop at line 15-21\n", "BRANCH #1: Covered if branch at line 19-20\n", "LOOP #3: Entered for loop at line 28-31\n"], ["LOOP #1: Entered for loop at line 15-21\n", "LOOP #2: Entered while loop at line 17-18\n", "LOOP #1: Entered for loop at line 15-21\n"]], "sampled_condition_paths": [["Line 15: (i in reversed(range(len(chars))))", "Line 15: (i in reversed(range(len(chars))))", "Line 19: (chars[i] < chr(ord('a') + k))", "Line 28: (j in range(i, len(chars)))"], ["Line 15: (i in reversed(range(len(chars))))", "Line 17: (self._containsPalindrome(chars, i))", "Line 15: (i in reversed(range(len(chars))))"]]}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "difficulty": 2, "func_name": "colorTheArray", "description": "There is a 0-indexed array `nums` of length `n`. Initially, all elements are\nuncolored (has a value of `0`).\n\nYou are given a 2D integer array `queries` where `queries[i] = [indexi,\ncolori]`.\n\nFor each query, you color the index `indexi` with the color `colori` in the\narray `nums`.\n\nReturn an array `answer` of the same length as `queries` where `answer[i]` is\nthe number of adjacent elements with the same color after the `ith` query.\n\nMore formally, `answer[i]` is the number of indices `j`, such that `0 <= j < n\n- 1` and `nums[j] == nums[j + 1]` and `nums[j] != 0` after the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "blocks": [{"type": "if", "start": 18, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.11320754716981132}, {"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.2830188679245283}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.1320754716981132}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.20754716981132076}], "target_lines": [19, 20, 21, 22, 24, 25, 26, 27], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      log_function('LOOP #1: Entered for loop at line 17-30\\n')\n      if i + 1 < n:\n        log_function('BRANCH #1: Covered if branch at line 18-22\\n')\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          log_function('BRANCH #2: Covered if branch at line 19-20\\n')\n          sameColors -= 1\n        if arr[i + 1] == color:\n          log_function('BRANCH #3: Covered if branch at line 21-22\\n')\n          sameColors += 1\n      if i > 0:\n        log_function('BRANCH #4: Covered if branch at line 23-27\\n')\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          log_function('BRANCH #5: Covered if branch at line 24-25\\n')\n          sameColors -= 1\n        if arr[i - 1] == color:\n          log_function('BRANCH #6: Covered if branch at line 26-27\\n')\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Adjacent Elements With the Same Color.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 18-22\n", "LOOP #1: Entered for loop at line 17-30\n", "BRANCH #1: Covered if branch at line 18-22\n", "BRANCH #4: Covered if branch at line 23-27\n", "BRANCH #6: Covered if branch at line 26-27\n"], ["LOOP #1: Entered for loop at line 17-30\n"], ["BRANCH #4: Covered if branch at line 23-27\n", "BRANCH #5: Covered if branch at line 24-25\n", "LOOP #1: Entered for loop at line 17-30\n", "BRANCH #1: Covered if branch at line 18-22\n", "BRANCH #3: Covered if branch at line 21-22\n"]], "sampled_condition_paths": [["Line 18: (i + 1 < n)", "Line 17: (i, color in queries)", "Line 18: (i + 1 < n)", "Line 23: (i > 0)", "Line 26: (arr[i - 1] == color)"], ["Line 17: (i, color in queries)"], ["Line 23: (i > 0)", "Line 24: (arr[i - 1] > 0 and arr[i - 1] == arr[i])", "Line 17: (i, color in queries)", "Line 18: (i + 1 < n)", "Line 21: (arr[i + 1] == color)"]]}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "difficulty": 2, "func_name": "maxMoves", "description": "You are given a 0-indexed `m x n` matrix `grid` consisting of positive\nintegers.\n\nYou can start at any cell in the first column of the matrix, and traverse the\ngrid in the following way:\n\n* From a cell `(row, col)`, you can move to any of the cells: `(row - 1, col + 1)`, `(row, col + 1)` and `(row + 1, col + 1)` such that the value of the cell you move to, should be strictly bigger than the value of the current cell.\n\nReturn the maximum number of moves that you can perform.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      log_function('LOOP #1: Entered for loop at line 17-25\\n')\n      for i in range(m):\n        log_function('LOOP #2: Entered for loop at line 18-25\\n')\n        if grid[i][j + 1] > grid[i][j]:\n          log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          log_function('BRANCH #2: Covered if branch at line 21-22\\n')\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          log_function('BRANCH #3: Covered if branch at line 23-24\\n')\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Number of Moves in a Grid.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 21-22\n", "BRANCH #3: Covered if branch at line 23-24\n", "LOOP #2: Entered for loop at line 18-25\n", "BRANCH #1: Covered if branch at line 19-20\n", "BRANCH #2: Covered if branch at line 21-22\n"], ["LOOP #2: Entered for loop at line 18-25\n", "BRANCH #1: Covered if branch at line 19-20\n", "BRANCH #3: Covered if branch at line 23-24\n", "LOOP #2: Entered for loop at line 18-25\n", "LOOP #2: Entered for loop at line 18-25\n"], ["LOOP #2: Entered for loop at line 18-25\n", "BRANCH #1: Covered if branch at line 19-20\n", "LOOP #2: Entered for loop at line 18-25\n", "BRANCH #2: Covered if branch at line 21-22\n", "BRANCH #3: Covered if branch at line 23-24\n"], ["BRANCH #1: Covered if branch at line 19-20\n", "BRANCH #2: Covered if branch at line 21-22\n", "LOOP #1: Entered for loop at line 17-25\n", "LOOP #2: Entered for loop at line 18-25\n", "LOOP #2: Entered for loop at line 18-25\n"]], "sampled_condition_paths": [["Line 21: (i > 0 and grid[i - 1][j + 1] > grid[i][j])", "Line 23: (i + 1 < m and grid[i + 1][j + 1] > grid[i][j])", "Line 18: (i in range(m))", "Line 19: (grid[i][j + 1] > grid[i][j])", "Line 21: (i > 0 and grid[i - 1][j + 1] > grid[i][j])"], ["Line 18: (i in range(m))", "Line 19: (grid[i][j + 1] > grid[i][j])", "Line 23: (i + 1 < m and grid[i + 1][j + 1] > grid[i][j])", "Line 18: (i in range(m))", "Line 18: (i in range(m))"], ["Line 18: (i in range(m))", "Line 19: (grid[i][j + 1] > grid[i][j])", "Line 18: (i in range(m))", "Line 21: (i > 0 and grid[i - 1][j + 1] > grid[i][j])", "Line 23: (i + 1 < m and grid[i + 1][j + 1] > grid[i][j])"], ["Line 19: (grid[i][j + 1] > grid[i][j])", "Line 21: (i > 0 and grid[i - 1][j + 1] > grid[i][j])", "Line 17: (j in range(n - 2, -1, -1))", "Line 18: (i in range(m))", "Line 18: (i in range(m))"]]}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "difficulty": 2, "func_name": "countCompleteComponents", "description": "You are given an integer `n`. There is an undirected graph with `n` vertices,\nnumbered from `0` to `n - 1`. You are given a 2D integer array `edges` where\n`edges[i] = [ai, bi]` denotes that there exists an undirected edge connecting\nvertices `ai` and `bi`.\n\nReturn the number of complete connected components of the graph.\n\nA connected component is a subgraph of a graph in which there exists a path\nbetween any two vertices, and no vertex of the subgraph shares an edge with a\nvertex outside of the subgraph.\n\nA connected component is said to be complete if there exists an edge between\nevery pair of its vertices.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 24, "end": 27, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}, {"type": "if", "start": 28, "end": 31, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "else", "start": 32, "end": 36, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}, {"type": "if", "start": 58, "end": 60, "difficulty": 2, "eg_cov_prob": 0.20754716981132076}], "target_lines": [23, 25, 26, 27, 29, 30, 31, 33, 34, 35, 36, 40, 59, 60], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 22-23\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 24-27\\n')\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 28-31\\n')\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      log_function('BRANCH #4: Covered else branch at line 32-36\\n')\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #5: Covered if branch at line 39-40\\n')\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 53-55\\n')\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      log_function('LOOP #2: Entered for loop at line 56-61\\n')\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        log_function('BRANCH #6: Covered if branch at line 58-60\\n')\n        ans += 1\n        parents.add(parent)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Count the Number of Complete Components.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #5: Covered if branch at line 39-40\n", "BRANCH #6: Covered if branch at line 58-60\n", "LOOP #2: Entered for loop at line 56-61\n", "LOOP #2: Entered for loop at line 56-61\n", "BRANCH #5: Covered if branch at line 39-40\n"], ["BRANCH #3: Covered elif branch at line 28-31\n", "LOOP #2: Entered for loop at line 56-61\n", "BRANCH #5: Covered if branch at line 39-40\n", "BRANCH #6: Covered if branch at line 58-60\n", "LOOP #2: Entered for loop at line 56-61\n"], ["BRANCH #5: Covered if branch at line 39-40\n", "BRANCH #3: Covered elif branch at line 28-31\n", "LOOP #1: Entered for loop at line 53-55\n", "BRANCH #5: Covered if branch at line 39-40\n", "BRANCH #1: Covered if branch at line 22-23\n"], ["BRANCH #5: Covered if branch at line 39-40\n", "BRANCH #6: Covered if branch at line 58-60\n", "LOOP #2: Entered for loop at line 56-61\n", "LOOP #2: Entered for loop at line 56-61\n", "BRANCH #6: Covered if branch at line 58-60\n"]], "sampled_condition_paths": [["Line 39: (self.id[u] != u)", "Line 58: (parent not in parents and uf.isComplete(parent))", "Line 56: (i in range(n))", "Line 56: (i in range(n))", "Line 39: (self.id[u] != u)"], ["Line 24: NOT (self.rank[i] < self.rank[j])", "Line 28: (self.rank[i] > self.rank[j])", "Line 56: (i in range(n))", "Line 39: (self.id[u] != u)", "Line 58: (parent not in parents and uf.isComplete(parent))", "Line 56: (i in range(n))"], ["Line 39: (self.id[u] != u)", "Line 24: NOT (self.rank[i] < self.rank[j])", "Line 28: (self.rank[i] > self.rank[j])", "Line 53: (u, v in edges)", "Line 39: (self.id[u] != u)", "Line 22: (i == j)"], ["Line 39: (self.id[u] != u)", "Line 58: (parent not in parents and uf.isComplete(parent))", "Line 56: (i in range(n))", "Line 56: (i in range(n))", "Line 58: (parent not in parents and uf.isComplete(parent))"]]}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "difficulty": 3, "func_name": "modifiedGraphEdges", "description": "You are given an undirected weighted connected graph containing `n` nodes\nlabeled from `0` to `n - 1`, and an integer array `edges` where `edges[i] =\n[ai, bi, wi]` indicates that there is an edge between nodes `ai` and `bi` with\nweight `wi`.\n\nSome edges have a weight of `-1` (`wi = -1`), while others have a positive\nweight (`wi > 0`).\n\nYour task is to modify all edges with a weight of `-1` by assigning them\npositive integer values in the range `[1, 2 * 109]` so that the shortest\ndistance between the nodes `source` and `destination` becomes equal to an\ninteger `target`. If there are multiple modifications that make the shortest\ndistance between `source` and `destination` equal to `target`, any of them\nwill be considered correct.\n\nReturn an array containing all edges (even unmodified ones) in any order if it\nis possible to make the shortest distance from `source` to `destination` equal\nto `target`, or an empty array if it's impossible.\n\nNote: You are not allowed to modify the weights of edges with initial positive\nweights.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}, {"type": "if", "start": 26, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 39, "end": 44, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 56, "end": 57, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 59, "end": 61, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 2, "eg_cov_prob": 0.03773584905660377}], "target_lines": [19, 25, 27, 28, 29, 30, 34, 40, 41, 42, 43, 44, 57, 60, 61], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      log_function('LOOP #1: Entered for loop at line 17-22\\n')\n      if w == -1:\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      log_function('BRANCH #2: Covered if branch at line 24-25\\n')\n      return []\n    if distToDestination == target:\n      log_function('BRANCH #3: Covered if branch at line 26-30\\n')\n      for edge in edges:\n        log_function('LOOP #2: Entered for loop at line 27-29\\n')\n        if edge[2] == -1:\n          log_function('BRANCH #4: Covered if branch at line 28-29\\n')\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      log_function('LOOP #3: Entered for loop at line 32-45\\n')\n      if w != -1:\n        log_function('BRANCH #5: Covered if branch at line 33-34\\n')\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        log_function('BRANCH #6: Covered if branch at line 39-44\\n')\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          log_function('LOOP #4: Entered for loop at line 41-43\\n')\n          if edges[j][2] == -1:\n            log_function('BRANCH #7: Covered if branch at line 42-43\\n')\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      log_function('LOOP #5: Entered while loop at line 54-62\\n')\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        log_function('BRANCH #8: Covered if branch at line 56-57\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #6: Entered for loop at line 58-62\\n')\n        if d + w < dist[v]:\n          log_function('BRANCH #9: Covered if branch at line 59-61\\n')\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n\ndef log_function(info_str):\n    with open(\"test_logs/Modify Graph Edge Weights.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #9: Covered if branch at line 59-61\n", "LOOP #5: Entered while loop at line 54-62\n", "LOOP #6: Entered for loop at line 58-62\n", "LOOP #5: Entered while loop at line 54-62\n", "LOOP #6: Entered for loop at line 58-62\n"], ["BRANCH #1: Covered if branch at line 18-19\n", "LOOP #5: Entered while loop at line 54-62\n", "LOOP #3: Entered for loop at line 32-45\n", "LOOP #5: Entered while loop at line 54-62\n", "LOOP #3: Entered for loop at line 32-45\n"], ["BRANCH #9: Covered if branch at line 59-61\n", "LOOP #6: Entered for loop at line 58-62\n", "BRANCH #9: Covered if branch at line 59-61\n", "LOOP #5: Entered while loop at line 54-62\n", "LOOP #6: Entered for loop at line 58-62\n"], ["LOOP #6: Entered for loop at line 58-62\n", "BRANCH #9: Covered if branch at line 59-61\n", "LOOP #5: Entered while loop at line 54-62\n", "LOOP #6: Entered for loop at line 58-62\n", "BRANCH #2: Covered if branch at line 24-25\n"], ["LOOP #1: Entered for loop at line 17-22\n", "LOOP #1: Entered for loop at line 17-22\n", "LOOP #1: Entered for loop at line 17-22\n", "BRANCH #1: Covered if branch at line 18-19\n", "LOOP #5: Entered while loop at line 54-62\n"], ["LOOP #5: Entered while loop at line 54-62\n", "LOOP #6: Entered for loop at line 58-62\n", "BRANCH #9: Covered if branch at line 59-61\n", "LOOP #5: Entered while loop at line 54-62\n", "LOOP #6: Entered for loop at line 58-62\n"]], "sampled_condition_paths": [["Line 59: (d + w < dist[v])", "Line 54: (minHeap)", "Line 58: (v, w in graph[u])", "Line 54: (minHeap)", "Line 58: (v, w in graph[u])"], ["Line 18: (w == -1)", "Line 54: (minHeap)", "Line 32: (i, (u, v, w) in enumerate(edges))", "Line 54: (minHeap)", "Line 32: (i, (u, v, w) in enumerate(edges))"], ["Line 59: (d + w < dist[v])", "Line 58: (v, w in graph[u])", "Line 59: (d + w < dist[v])", "Line 54: (minHeap)", "Line 58: (v, w in graph[u])"], ["Line 58: (v, w in graph[u])", "Line 59: (d + w < dist[v])", "Line 54: (minHeap)", "Line 58: (v, w in graph[u])", "Line 24: (distToDestination < target)"], ["Line 17: (u, v, w in edges)", "Line 17: (u, v, w in edges)", "Line 17: (u, v, w in edges)", "Line 18: (w == -1)", "Line 54: (minHeap)"], ["Line 54: (minHeap)", "Line 58: (v, w in graph[u])", "Line 59: (d + w < dist[v])", "Line 54: (minHeap)", "Line 58: (v, w in graph[u])"]]}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "difficulty": 2, "func_name": "maxStrength", "description": "You are given a 0-indexed integer array `nums` representing the score of\nstudents in an exam. The teacher would like to form one non-empty group of\nstudents with maximal strength, where the strength of a group of students of\nindices `i0`, `i1`, `i2`, ... , `ik` is defined as `nums[i0] * nums[i1] *\nnums[i2] * ... * nums[ik\u200b]`.\n\nReturn the maximum strength of a group the teacher can create.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.33962264150943394}, {"type": "if", "start": 35, "end": 36, "difficulty": 1, "eg_cov_prob": 0.4339622641509434}, {"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.16981132075471697}, {"type": "if", "start": 39, "end": 40, "difficulty": 2, "eg_cov_prob": 0.03773584905660377}, {"type": "if", "start": 21, "end": 23, "difficulty": 1, "eg_cov_prob": 0.9056603773584906}, {"type": "if", "start": 24, "end": 27, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}, {"type": "else", "start": 28, "end": 29, "difficulty": 1, "eg_cov_prob": 0.4339622641509434}], "target_lines": [22, 23, 25, 26, 27, 29, 32, 34, 36, 38, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      log_function('LOOP #1: Entered for loop at line 20-30\\n')\n      if num > 0:\n        log_function('BRANCH #1: Covered if branch at line 21-23\\n')\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        log_function('BRANCH #2: Covered elif branch at line 24-27\\n')\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        log_function('BRANCH #3: Covered else branch at line 28-29\\n')\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      log_function('BRANCH #4: Covered if branch at line 31-32\\n')\n      return 0\n    if negCount % 2 == 0:\n      log_function('BRANCH #5: Covered if branch at line 33-34\\n')\n      return negProd * posProd\n    if negCount >= 3:\n      log_function('BRANCH #6: Covered if branch at line 35-36\\n')\n      return negProd // maxNeg * posProd\n    if hasPos:\n      log_function('BRANCH #7: Covered if branch at line 37-38\\n')\n      return posProd\n    if hasZero:\n      log_function('BRANCH #8: Covered if branch at line 39-40\\n')\n      return 0\n    return maxNeg\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Strength of a Group.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered elif branch at line 24-27\n", "LOOP #1: Entered for loop at line 20-30\n", "BRANCH #2: Covered elif branch at line 24-27\n", "LOOP #1: Entered for loop at line 20-30\n", "BRANCH #2: Covered elif branch at line 24-27\n"], ["BRANCH #2: Covered elif branch at line 24-27\n", "LOOP #1: Entered for loop at line 20-30\n", "BRANCH #2: Covered elif branch at line 24-27\n", "LOOP #1: Entered for loop at line 20-30\n", "BRANCH #1: Covered if branch at line 21-23\n"], ["LOOP #1: Entered for loop at line 20-30\n", "BRANCH #2: Covered elif branch at line 24-27\n", "LOOP #1: Entered for loop at line 20-30\n", "BRANCH #2: Covered elif branch at line 24-27\n", "BRANCH #6: Covered if branch at line 35-36\n"], ["LOOP #1: Entered for loop at line 20-30\n", "BRANCH #1: Covered if branch at line 21-23\n", "LOOP #1: Entered for loop at line 20-30\n", "BRANCH #2: Covered elif branch at line 24-27\n", "BRANCH #6: Covered if branch at line 35-36\n"]], "sampled_condition_paths": [["Line 21: NOT (num > 0)", "Line 24: (num < 0)", "Line 20: (num in nums)", "Line 21: NOT (num > 0)", "Line 24: (num < 0)", "Line 20: (num in nums)", "Line 21: NOT (num > 0)", "Line 24: (num < 0)"], ["Line 21: NOT (num > 0)", "Line 24: (num < 0)", "Line 20: (num in nums)", "Line 21: NOT (num > 0)", "Line 24: (num < 0)", "Line 20: (num in nums)", "Line 21: (num > 0)"], ["Line 20: (num in nums)", "Line 21: NOT (num > 0)", "Line 24: (num < 0)", "Line 20: (num in nums)", "Line 21: NOT (num > 0)", "Line 24: (num < 0)", "Line 35: (negCount >= 3)"], ["Line 20: (num in nums)", "Line 21: (num > 0)", "Line 20: (num in nums)", "Line 21: NOT (num > 0)", "Line 24: (num < 0)", "Line 35: (negCount >= 3)"]]}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "difficulty": 3, "func_name": "canTraverseAllPairs", "description": "You are given a 0-indexed integer array `nums`, and you are allowed to\ntraverse between its indices. You can traverse between index `i` and index\n`j`, `i != j`, if and only if `gcd(nums[i], nums[j]) > 1`, where `gcd` is the\ngreatest common divisor.\n\nYour task is to determine if for every pair of indices `i` and `j` in nums,\nwhere `i < j`, there exists a sequence of traversals that can take us from `i`\nto `j`.\n\nReturn `true` if it is possible to traverse between all such pairs of indices,\nor `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 24, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 57, "end": 59, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 23, 25, 26, 33, 48, 50, 58, 59], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n      return\n    if self.sz[i] < self.sz[j]:\n      log_function('BRANCH #2: Covered if branch at line 21-23\\n')\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      log_function('BRANCH #3: Covered else branch at line 24-26\\n')\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #4: Covered if branch at line 32-33\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      log_function('LOOP #1: Entered for loop at line 45-51\\n')\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        log_function('LOOP #2: Entered for loop at line 46-51\\n')\n        if prime_factor in primeToFirstIndex:\n          log_function('BRANCH #5: Covered if branch at line 47-48\\n')\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          log_function('BRANCH #6: Covered else branch at line 49-50\\n')\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      log_function('LOOP #3: Entered for loop at line 56-59\\n')\n      if minPrimeFactors[i] == i:\n        log_function('BRANCH #7: Covered if branch at line 57-59\\n')\n        for j in range(i * i, n, i):\n          log_function('LOOP #4: Entered for loop at line 58-59\\n')\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      log_function('LOOP #5: Entered while loop at line 64-68\\n')\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        log_function('LOOP #6: Entered while loop at line 67-68\\n')\n        num //= divisor\n    return primeFactors\n\ndef log_function(info_str):\n    with open(\"test_logs/Greatest Common Divisor Traversal.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #6: Entered while loop at line 67-68\n", "LOOP #2: Entered for loop at line 46-51\n", "BRANCH #5: Covered if branch at line 47-48\n", "BRANCH #3: Covered else branch at line 24-26\n", "LOOP #2: Entered for loop at line 46-51\n"], ["LOOP #5: Entered while loop at line 64-68\n", "LOOP #6: Entered while loop at line 67-68\n", "LOOP #2: Entered for loop at line 46-51\n", "BRANCH #6: Covered else branch at line 49-50\n", "LOOP #1: Entered for loop at line 45-51\n"], ["LOOP #2: Entered for loop at line 46-51\n", "BRANCH #5: Covered if branch at line 47-48\n", "BRANCH #4: Covered if branch at line 32-33\n", "BRANCH #2: Covered if branch at line 21-23\n", "LOOP #1: Entered for loop at line 45-51\n"], ["LOOP #2: Entered for loop at line 46-51\n", "BRANCH #5: Covered if branch at line 47-48\n", "BRANCH #3: Covered else branch at line 24-26\n", "LOOP #1: Entered for loop at line 45-51\n", "LOOP #5: Entered while loop at line 64-68\n"], ["BRANCH #5: Covered if branch at line 47-48\n", "BRANCH #3: Covered else branch at line 24-26\n", "LOOP #2: Entered for loop at line 46-51\n", "BRANCH #5: Covered if branch at line 47-48\n", "BRANCH #4: Covered if branch at line 32-33\n"], ["BRANCH #3: Covered else branch at line 24-26\n", "LOOP #2: Entered for loop at line 46-51\n", "BRANCH #5: Covered if branch at line 47-48\n", "BRANCH #4: Covered if branch at line 32-33\n", "BRANCH #2: Covered if branch at line 21-23\n"]], "sampled_condition_paths": [["Line 67: (num % divisor == 0)", "Line 46: (prime_factor in self._getPrimeFactors(num, maxPrimeFactor))", "Line 47: (prime_factor in primeToFirstIndex)", "Line 21: NOT (self.sz[i] < self.sz[j])", "Line 24: ", "Line 46: (prime_factor in self._getPrimeFactors(num, maxPrimeFactor))"], ["Line 64: (num > 1)", "Line 67: (num % divisor == 0)", "Line 46: (prime_factor in self._getPrimeFactors(num, maxPrimeFactor))", "Line 47: NOT (prime_factor in primeToFirstIndex)", "Line 49: ", "Line 45: (i, num in enumerate(nums))"], ["Line 46: (prime_factor in self._getPrimeFactors(num, maxPrimeFactor))", "Line 47: (prime_factor in primeToFirstIndex)", "Line 32: (self.id[u] != u)", "Line 21: (self.sz[i] < self.sz[j])", "Line 45: (i, num in enumerate(nums))"], ["Line 46: (prime_factor in self._getPrimeFactors(num, maxPrimeFactor))", "Line 47: (prime_factor in primeToFirstIndex)", "Line 21: NOT (self.sz[i] < self.sz[j])", "Line 24: ", "Line 45: (i, num in enumerate(nums))", "Line 64: (num > 1)"], ["Line 47: (prime_factor in primeToFirstIndex)", "Line 21: NOT (self.sz[i] < self.sz[j])", "Line 24: ", "Line 46: (prime_factor in self._getPrimeFactors(num, maxPrimeFactor))", "Line 47: (prime_factor in primeToFirstIndex)", "Line 32: (self.id[u] != u)"], ["Line 21: NOT (self.sz[i] < self.sz[j])", "Line 24: ", "Line 46: (prime_factor in self._getPrimeFactors(num, maxPrimeFactor))", "Line 47: (prime_factor in primeToFirstIndex)", "Line 32: (self.id[u] != u)", "Line 21: (self.sz[i] < self.sz[j])"]]}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "difficulty": 3, "func_name": "maximumSumQueries", "description": "You are given two 0-indexed integer arrays `nums1` and `nums2`, each of length\n`n`, and a 1-indexed 2D array `queries` where `queries[i] = [xi, yi]`.\n\nFor the `ith` query, find the maximum value of `nums1[j] + nums2[j]` among all\nindices `j` `(0 <= j < n)`, where `nums1[j] >= xi` and `nums2[j] >= yi`, or -1\nif there is no `j` satisfying the constraints.\n\nReturn an array `answer` where `answer[i]` is the answer to the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "blocks": [{"type": "if", "start": 50, "end": 51, "difficulty": 1, "eg_cov_prob": 0.9433962264150944}, {"type": "else", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 63, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 64, "end": 65, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 46, "end": 47, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [47, 51, 53, 63, 65], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      log_function('LOOP #1: Entered for loop at line 41-54\\n')\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        log_function('LOOP #2: Entered while loop at line 42-48\\n')\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          log_function('LOOP #3: Entered while loop at line 44-45\\n')\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          log_function('BRANCH #1: Covered if branch at line 46-47\\n')\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        log_function('BRANCH #2: Covered if branch at line 50-51\\n')\n        ans[queryIndex] = -1\n      else:\n        log_function('BRANCH #3: Covered else branch at line 52-53\\n')\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      log_function('LOOP #4: Entered while loop at line 60-65\\n')\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        log_function('BRANCH #4: Covered if branch at line 62-63\\n')\n        r = m\n      else:\n        log_function('BRANCH #5: Covered else branch at line 64-65\\n')\n        l = m + 1\n    return l\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Sum Queries.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 46-47\n", "LOOP #2: Entered while loop at line 42-48\n", "LOOP #3: Entered while loop at line 44-45\n", "BRANCH #1: Covered if branch at line 46-47\n", "LOOP #4: Entered while loop at line 60-65\n"], ["LOOP #2: Entered while loop at line 42-48\n", "LOOP #4: Entered while loop at line 60-65\n", "BRANCH #4: Covered if branch at line 62-63\n", "BRANCH #3: Covered else branch at line 52-53\n", "LOOP #1: Entered for loop at line 41-54\n"], ["LOOP #3: Entered while loop at line 44-45\n", "BRANCH #1: Covered if branch at line 46-47\n", "LOOP #4: Entered while loop at line 60-65\n", "BRANCH #4: Covered if branch at line 62-63\n", "BRANCH #3: Covered else branch at line 52-53\n"], ["BRANCH #3: Covered else branch at line 52-53\n", "LOOP #1: Entered for loop at line 41-54\n", "LOOP #2: Entered while loop at line 42-48\n", "LOOP #4: Entered while loop at line 60-65\n", "BRANCH #4: Covered if branch at line 62-63\n"], ["LOOP #1: Entered for loop at line 41-54\n", "BRANCH #2: Covered if branch at line 50-51\n"]], "sampled_condition_paths": [["Line 46: (not stack or y > stack[-1][0])", "Line 42: (pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX)", "Line 44: (stack and x + y >= stack[-1][1])", "Line 46: (not stack or y > stack[-1][0])", "Line 60: (l < r)"], ["Line 42: (pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX)", "Line 60: (l < r)", "Line 62: (A[m][0] >= target)", "Line 50: NOT (j == len(stack))", "Line 52: ", "Line 41: (queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX))"], ["Line 44: (stack and x + y >= stack[-1][1])", "Line 46: (not stack or y > stack[-1][0])", "Line 60: (l < r)", "Line 62: (A[m][0] >= target)", "Line 50: NOT (j == len(stack))", "Line 52: "], ["Line 50: NOT (j == len(stack))", "Line 52: ", "Line 41: (queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX))", "Line 42: (pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX)", "Line 60: (l < r)", "Line 62: (A[m][0] >= target)"], ["Line 41: (queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX))", "Line 50: (j == len(stack))"]]}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "difficulty": 2, "func_name": "countServers", "description": "You are given an integer `n` denoting the total number of servers and a 2D\n0-indexed integer array `logs`, where `logs[i] = [server_id, time]` denotes\nthat the server with id `server_id` received a request at time `time`.\n\nYou are also given an integer `x` and a 0-indexed integer array `queries`.\n\nReturn a 0-indexed integer array `arr` of length `queries.length` where\n`arr[i]` represents the number of servers that did not receive any requests\nduring the time interval `[queries[i] - x, queries[i]]`.\n\nNote that the time intervals are inclusive.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "blocks": [{"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 40, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [36, 41], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      log_function('LOOP #1: Entered for loop at line 32-44\\n')\n      while j < len(logs) and logs[j][1] <= query:\n        log_function('LOOP #2: Entered while loop at line 33-37\\n')\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          log_function('BRANCH #1: Covered if branch at line 35-36\\n')\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        log_function('LOOP #3: Entered while loop at line 38-42\\n')\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          log_function('BRANCH #2: Covered if branch at line 40-41\\n')\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Zero Request Servers.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 35-36\n", "LOOP #2: Entered while loop at line 33-37\n", "BRANCH #1: Covered if branch at line 35-36\n", "LOOP #2: Entered while loop at line 33-37\n", "BRANCH #1: Covered if branch at line 35-36\n"], ["LOOP #1: Entered for loop at line 32-44\n", "LOOP #2: Entered while loop at line 33-37\n", "LOOP #3: Entered while loop at line 38-42\n", "LOOP #3: Entered while loop at line 38-42\n", "BRANCH #2: Covered if branch at line 40-41\n"], ["LOOP #2: Entered while loop at line 33-37\n", "LOOP #2: Entered while loop at line 33-37\n", "BRANCH #1: Covered if branch at line 35-36\n", "LOOP #3: Entered while loop at line 38-42\n", "LOOP #1: Entered for loop at line 32-44\n"], ["LOOP #2: Entered while loop at line 33-37\n", "BRANCH #1: Covered if branch at line 35-36\n", "LOOP #2: Entered while loop at line 33-37\n", "LOOP #2: Entered while loop at line 33-37\n", "BRANCH #1: Covered if branch at line 35-36\n"]], "sampled_condition_paths": [["Line 35: (count[logs[j][0]] == 1)", "Line 33: (j < len(logs) and logs[j][1] <= query)", "Line 35: (count[logs[j][0]] == 1)", "Line 33: (j < len(logs) and logs[j][1] <= query)", "Line 35: (count[logs[j][0]] == 1)"], ["Line 32: (queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query))", "Line 33: (j < len(logs) and logs[j][1] <= query)", "Line 38: (i < len(logs) and logs[i][1] < query - x)", "Line 38: (i < len(logs) and logs[i][1] < query - x)", "Line 40: (count[logs[i][0]] == 0)"], ["Line 33: (j < len(logs) and logs[j][1] <= query)", "Line 33: (j < len(logs) and logs[j][1] <= query)", "Line 35: (count[logs[j][0]] == 1)", "Line 38: (i < len(logs) and logs[i][1] < query - x)", "Line 32: (queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query))"], ["Line 33: (j < len(logs) and logs[j][1] <= query)", "Line 35: (count[logs[j][0]] == 1)", "Line 33: (j < len(logs) and logs[j][1] <= query)", "Line 33: (j < len(logs) and logs[j][1] <= query)", "Line 35: (count[logs[j][0]] == 1)"]]}
{"task_num": 2751, "task_title": "Robot Collisions", "difficulty": 3, "func_name": "survivedRobotsHealths", "description": "There are `n` 1-indexed robots, each having a position on a line, health, and\nmovement direction.\n\nYou are given 0-indexed integer arrays `positions`, `healths`, and a string\n`directions` (`directions[i]` is either 'L' for left or 'R' for right). All\nintegers in `positions` are unique.\n\nAll robots start moving on the line simultaneously at the same speed in their\ngiven directions. If two robots ever share the same position while moving,\nthey will collide.\n\nIf two robots collide, the robot with lower health is removed from the line,\nand the health of the other robot decreases by one. The surviving robot\ncontinues in the same direction it was going. If both robots have the same\nhealth, they are both removed from the line.\n\nYour task is to determine the health of the robots that survive the\ncollisions, in the same order that the robots were given, i.e. final heath of\nrobot 1 (if survived), final health of robot 2 (if survived), and so on. If\nthere are no survivors, return an empty array.\n\nReturn an array containing the health of the remaining robots (in the order\nthey were given in the input), after no further collisions can occur.\n\nNote: The positions may be unsorted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "blocks": [{"type": "if", "start": 26, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 36, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 28, 31, 32, 34, 35, 37, 38, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      log_function('LOOP #1: Entered for loop at line 25-41\\n')\n      if robot.direction == 'R':\n        log_function('BRANCH #1: Covered if branch at line 26-28\\n')\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        log_function('LOOP #2: Entered while loop at line 29-38\\n')\n        if stack[-1].health == robot.health:\n          log_function('BRANCH #2: Covered if branch at line 30-32\\n')\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          log_function('BRANCH #3: Covered elif branch at line 33-35\\n')\n          stack.pop()\n          robot.health -= 1\n        else:\n          log_function('BRANCH #4: Covered else branch at line 36-38\\n')\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        log_function('BRANCH #5: Covered if branch at line 39-40\\n')\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n\ndef log_function(info_str):\n    with open(\"test_logs/Robot Collisions.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered while loop at line 29-38\n", "BRANCH #2: Covered if branch at line 30-32\n", "LOOP #1: Entered for loop at line 25-41\n", "LOOP #2: Entered while loop at line 29-38\n", "BRANCH #4: Covered else branch at line 36-38\n"], ["LOOP #1: Entered for loop at line 25-41\n", "BRANCH #1: Covered if branch at line 26-28\n", "LOOP #1: Entered for loop at line 25-41\n", "LOOP #2: Entered while loop at line 29-38\n", "BRANCH #2: Covered if branch at line 30-32\n"], ["LOOP #1: Entered for loop at line 25-41\n", "BRANCH #1: Covered if branch at line 26-28\n", "LOOP #1: Entered for loop at line 25-41\n", "BRANCH #1: Covered if branch at line 26-28\n", "LOOP #1: Entered for loop at line 25-41\n"], ["BRANCH #2: Covered if branch at line 30-32\n", "LOOP #1: Entered for loop at line 25-41\n", "BRANCH #1: Covered if branch at line 26-28\n", "LOOP #1: Entered for loop at line 25-41\n", "LOOP #2: Entered while loop at line 29-38\n"], ["LOOP #1: Entered for loop at line 25-41\n", "LOOP #2: Entered while loop at line 29-38\n", "BRANCH #2: Covered if branch at line 30-32\n", "LOOP #1: Entered for loop at line 25-41\n", "LOOP #2: Entered while loop at line 29-38\n"]], "sampled_condition_paths": [["Line 29: (stack and stack[-1].direction == 'R' and robot.health > 0)", "Line 30: (stack[-1].health == robot.health)", "Line 25: (robot in robots)", "Line 29: (stack and stack[-1].direction == 'R' and robot.health > 0)", "Line 30: NOT (stack[-1].health == robot.health)", "Line 33: NOT (stack[-1].health < robot.health)", "Line 36: "], ["Line 25: (robot in robots)", "Line 26: (robot.direction == 'R')", "Line 25: (robot in robots)", "Line 29: (stack and stack[-1].direction == 'R' and robot.health > 0)", "Line 30: (stack[-1].health == robot.health)"], ["Line 25: (robot in robots)", "Line 26: (robot.direction == 'R')", "Line 25: (robot in robots)", "Line 26: (robot.direction == 'R')", "Line 25: (robot in robots)"], ["Line 30: (stack[-1].health == robot.health)", "Line 25: (robot in robots)", "Line 26: (robot.direction == 'R')", "Line 25: (robot in robots)", "Line 29: (stack and stack[-1].direction == 'R' and robot.health > 0)"], ["Line 25: (robot in robots)", "Line 29: (stack and stack[-1].direction == 'R' and robot.health > 0)", "Line 30: (stack[-1].health == robot.health)", "Line 25: (robot in robots)", "Line 29: (stack and stack[-1].direction == 'R' and robot.health > 0)"]]}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "difficulty": 2, "func_name": "maximumSafenessFactor", "description": "You are given a 0-indexed 2D matrix `grid` of size `n x n`, where `(r, c)`\nrepresents:\n\n* A cell containing a thief if `grid[r][c] = 1`\n* An empty cell if `grid[r][c] = 0`\n\nYou are initially positioned at cell `(0, 0)`. In one move, you can move to\nany adjacent cell in the grid, including cells containing thieves.\n\nThe safeness factor of a path on the grid is defined as the minimum manhattan\ndistance from any cell in the path to any thief in the grid.\n\nReturn the maximum safeness factor of all paths leading to cell `(n - 1, n -\n1)`.\n\nAn adjacent cell of cell `(r, c)`, is one of the cells `(r, c + 1)`, `(r, c -\n1)`, `(r + 1, c)` and `(r - 1, c)` if it exists.\n\nThe Manhattan distance between two cells `(a, b)` and `(x, y)` is equal to `|a\n- x| + |b - y|`, where `|val|` denotes the absolute value of val.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 54, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 64, "end": 65, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 66, "end": 67, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 27, 29, 34, 36, 53, 54, 65, 67], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        log_function('LOOP #1: Entered while loop at line 24-39\\n')\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          log_function('BRANCH #2: Covered if branch at line 26-27\\n')\n          continue\n        if i == n - 1 and j == n - 1:\n          log_function('BRANCH #3: Covered if branch at line 28-29\\n')\n          return True\n        for dx, dy in self.dirs:\n          log_function('LOOP #2: Entered for loop at line 30-39\\n')\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            log_function('BRANCH #4: Covered if branch at line 33-34\\n')\n            continue\n          if (x, y) in seen:\n            log_function('BRANCH #5: Covered if branch at line 35-36\\n')\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      log_function('LOOP #3: Entered for loop at line 50-55\\n')\n      for j in range(n):\n        log_function('LOOP #4: Entered for loop at line 51-55\\n')\n        if grid[i][j] == 1:\n          log_function('BRANCH #6: Covered if branch at line 52-54\\n')\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      log_function('LOOP #5: Entered while loop at line 57-71\\n')\n      for _ in range(len(q)):\n        log_function('LOOP #6: Entered for loop at line 58-69\\n')\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          log_function('LOOP #7: Entered for loop at line 61-69\\n')\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            log_function('BRANCH #7: Covered if branch at line 64-65\\n')\n            continue\n          if (x, y) in seen:\n            log_function('BRANCH #8: Covered if branch at line 66-67\\n')\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n\ndef log_function(info_str):\n    with open(\"test_logs/Find the Safest Path in a Grid.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #7: Entered for loop at line 61-69\n", "BRANCH #7: Covered if branch at line 64-65\n", "LOOP #7: Entered for loop at line 61-69\n", "BRANCH #8: Covered if branch at line 66-67\n", "BRANCH #1: Covered if branch at line 18-19\n"], ["BRANCH #4: Covered if branch at line 33-34\n", "LOOP #2: Entered for loop at line 30-39\n", "LOOP #2: Entered for loop at line 30-39\n", "BRANCH #5: Covered if branch at line 35-36\n", "LOOP #2: Entered for loop at line 30-39\n"], ["LOOP #4: Entered for loop at line 51-55\n", "LOOP #3: Entered for loop at line 50-55\n", "LOOP #4: Entered for loop at line 51-55\n", "LOOP #4: Entered for loop at line 51-55\n", "LOOP #4: Entered for loop at line 51-55\n"], ["BRANCH #8: Covered if branch at line 66-67\n", "LOOP #7: Entered for loop at line 61-69\n", "BRANCH #7: Covered if branch at line 64-65\n", "LOOP #7: Entered for loop at line 61-69\n", "BRANCH #7: Covered if branch at line 64-65\n"], ["BRANCH #8: Covered if branch at line 66-67\n", "LOOP #7: Entered for loop at line 61-69\n", "BRANCH #7: Covered if branch at line 64-65\n", "LOOP #7: Entered for loop at line 61-69\n", "BRANCH #8: Covered if branch at line 66-67\n"], ["LOOP #7: Entered for loop at line 61-69\n", "BRANCH #8: Covered if branch at line 66-67\n", "LOOP #6: Entered for loop at line 58-69\n", "LOOP #7: Entered for loop at line 61-69\n", "BRANCH #8: Covered if branch at line 66-67\n"]], "sampled_condition_paths": [["Line 61: (dx, dy in self.dirs)", "Line 64: (x < 0 or x == n or y < 0 or y == n)", "Line 61: (dx, dy in self.dirs)", "Line 66: ((x, y) in seen)", "Line 18: (distToThief[0][0] < safeness)"], ["Line 33: (x < 0 or x == n or y < 0 or y == n)", "Line 30: (dx, dy in self.dirs)", "Line 30: (dx, dy in self.dirs)", "Line 35: ((x, y) in seen)", "Line 30: (dx, dy in self.dirs)"], ["Line 51: (j in range(n))", "Line 50: (i in range(n))", "Line 51: (j in range(n))", "Line 51: (j in range(n))", "Line 51: (j in range(n))"], ["Line 66: ((x, y) in seen)", "Line 61: (dx, dy in self.dirs)", "Line 64: (x < 0 or x == n or y < 0 or y == n)", "Line 61: (dx, dy in self.dirs)", "Line 64: (x < 0 or x == n or y < 0 or y == n)"], ["Line 66: ((x, y) in seen)", "Line 61: (dx, dy in self.dirs)", "Line 64: (x < 0 or x == n or y < 0 or y == n)", "Line 61: (dx, dy in self.dirs)", "Line 66: ((x, y) in seen)"], ["Line 61: (dx, dy in self.dirs)", "Line 66: ((x, y) in seen)", "Line 58: (_ in range(len(q)))", "Line 61: (dx, dy in self.dirs)", "Line 66: ((x, y) in seen)"]]}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "difficulty": 3, "func_name": "maximumScore", "description": "You are given an array `nums` of `n` positive integers and an integer `k`.\n\nInitially, you start with a score of `1`. You have to maximize your score by\napplying the following operation at most `k` times:\n\n* Choose any non-empty subarray `nums[l, ..., r]` that you haven't chosen previously.\n* Choose an element `x` of `nums[l, ..., r]` with the highest prime score. If multiple such elements exist, choose the one with the smallest index.\n* Multiply your score by `x`.\n\nHere, `nums[l, ..., r]` denotes the subarray of `nums` starting at index `l`\nand ending at the index `r`, both ends being inclusive.\n\nThe prime score of an integer `x` is equal to the number of distinct prime\nfactors of `x`. For example, the prime score of `300` is `3` since `300 = 2 *\n2 * 3 * 5 * 5`.\n\nReturn the maximum possible score after applying at most `k` operations.\n\nSince the answer may be large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "blocks": [{"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 55, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [38, 40, 56, 57], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      log_function('LOOP #1: Entered for loop at line 22-26\\n')\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        log_function('LOOP #2: Entered while loop at line 23-24\\n')\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      log_function('LOOP #3: Entered for loop at line 29-33\\n')\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        log_function('LOOP #4: Entered while loop at line 30-31\\n')\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        log_function('BRANCH #1: Covered if branch at line 37-38\\n')\n        return 1\n      if n & 1:\n        log_function('BRANCH #2: Covered if branch at line 39-40\\n')\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      log_function('LOOP #5: Entered for loop at line 43-49\\n')\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      log_function('LOOP #6: Entered for loop at line 54-57\\n')\n      if minPrimeFactors[i] == i:\n        log_function('BRANCH #3: Covered if branch at line 55-57\\n')\n        for j in range(i * i, n, i):\n          log_function('LOOP #7: Entered for loop at line 56-57\\n')\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      log_function('LOOP #8: Entered while loop at line 62-66\\n')\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        log_function('LOOP #9: Entered while loop at line 65-66\\n')\n        num //= divisor\n    return len(primeFactors)\n\ndef log_function(info_str):\n    with open(\"test_logs/Apply Operations to Maximize Score.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #8: Entered while loop at line 62-66\n", "LOOP #9: Entered while loop at line 65-66\n", "LOOP #8: Entered while loop at line 62-66\n", "LOOP #9: Entered while loop at line 65-66\n", "LOOP #9: Entered while loop at line 65-66\n"], ["LOOP #8: Entered while loop at line 62-66\n", "LOOP #9: Entered while loop at line 65-66\n", "LOOP #8: Entered while loop at line 62-66\n", "LOOP #9: Entered while loop at line 65-66\n", "LOOP #8: Entered while loop at line 62-66\n"], ["BRANCH #1: Covered if branch at line 37-38\n", "LOOP #5: Entered for loop at line 43-49\n", "BRANCH #2: Covered if branch at line 39-40\n", "BRANCH #1: Covered if branch at line 37-38\n", "LOOP #5: Entered for loop at line 43-49\n"], ["LOOP #1: Entered for loop at line 22-26\n", "LOOP #1: Entered for loop at line 22-26\n", "LOOP #2: Entered while loop at line 23-24\n", "LOOP #1: Entered for loop at line 22-26\n", "LOOP #2: Entered while loop at line 23-24\n"]], "sampled_condition_paths": [["Line 62: (num > 1)", "Line 65: (num % divisor == 0)", "Line 62: (num > 1)", "Line 65: (num % divisor == 0)", "Line 65: (num % divisor == 0)"], ["Line 62: (num > 1)", "Line 65: (num % divisor == 0)", "Line 62: (num > 1)", "Line 65: (num % divisor == 0)", "Line 62: (num > 1)"], ["Line 37: (n == 0)", "Line 43: (num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])))", "Line 39: (n & 1)", "Line 37: (n == 0)", "Line 43: (num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])))"], ["Line 22: (i in reversed(range(n)))", "Line 22: (i in reversed(range(n)))", "Line 23: (stack and primeScores[stack[-1]] <= primeScores[i])", "Line 22: (i in reversed(range(n)))", "Line 23: (stack and primeScores[stack[-1]] <= primeScores[i])"]]}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "difficulty": 3, "func_name": "getMaxFunctionValue", "description": "You are given an integer array `receiver` of length `n` and an integer `k`.\n`n` players are playing a ball-passing game.\n\nYou choose the starting player, `i`. The game proceeds as follows: player `i`\npasses the ball to player `receiver[i]`, who then passes it to\n`receiver[receiver[i]]`, and so on, for `k` passes in total. The game's score\nis the sum of the indices of the players who touched the ball, including\nrepetitions, i.e. `i + receiver[i] + receiver[receiver[i]] + ... +\nreceiver(k)[i]`.\n\nReturn the maximum possible score.\n\nNotes:\n\n* `receiver` may contain duplicates.\n* `receiver[i]` may be equal to `i`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "blocks": [{"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [34, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      log_function('LOOP #1: Entered for loop at line 19-22\\n')\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      log_function('LOOP #2: Entered for loop at line 23-28\\n')\n      for i in range(n):\n        log_function('LOOP #3: Entered for loop at line 24-28\\n')\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      log_function('LOOP #4: Entered for loop at line 29-37\\n')\n      currSum = i\n      currPos = i\n      for j in range(m):\n        log_function('LOOP #5: Entered for loop at line 32-35\\n')\n        if (k >> j) & 1 == 1:\n          log_function('BRANCH #1: Covered if branch at line 33-35\\n')\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximize Value of Function in a Ball Passing Game.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 24-28\n", "LOOP #3: Entered for loop at line 24-28\n", "LOOP #4: Entered for loop at line 29-37\n", "LOOP #5: Entered for loop at line 32-35\n", "LOOP #5: Entered for loop at line 32-35\n"], ["LOOP #4: Entered for loop at line 29-37\n", "LOOP #5: Entered for loop at line 32-35\n", "LOOP #5: Entered for loop at line 32-35\n", "LOOP #5: Entered for loop at line 32-35\n", "BRANCH #1: Covered if branch at line 33-35\n"], ["BRANCH #1: Covered if branch at line 33-35\n", "LOOP #4: Entered for loop at line 29-37\n", "LOOP #5: Entered for loop at line 32-35\n", "BRANCH #1: Covered if branch at line 33-35\n", "LOOP #5: Entered for loop at line 32-35\n"], ["LOOP #5: Entered for loop at line 32-35\n", "BRANCH #1: Covered if branch at line 33-35\n", "LOOP #4: Entered for loop at line 29-37\n", "LOOP #5: Entered for loop at line 32-35\n", "BRANCH #1: Covered if branch at line 33-35\n"]], "sampled_condition_paths": [["Line 24: (i in range(n))", "Line 24: (i in range(n))", "Line 29: (i in range(n))", "Line 32: (j in range(m))", "Line 32: (j in range(m))"], ["Line 29: (i in range(n))", "Line 32: (j in range(m))", "Line 32: (j in range(m))", "Line 32: (j in range(m))", "Line 33: ((k >> j) & 1 == 1)"], ["Line 33: ((k >> j) & 1 == 1)", "Line 29: (i in range(n))", "Line 32: (j in range(m))", "Line 33: ((k >> j) & 1 == 1)", "Line 32: (j in range(m))"], ["Line 32: (j in range(m))", "Line 33: ((k >> j) & 1 == 1)", "Line 29: (i in range(n))", "Line 32: (j in range(m))", "Line 33: ((k >> j) & 1 == 1)"]]}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "difficulty": 2, "func_name": "minimumOperations", "description": "You are given a 0-indexed string `num` representing a non-negative integer.\n\nIn one operation, you can pick any digit of `num` and delete it. Note that if\nyou delete all the digits of `num`, `num` becomes `0`.\n\nReturn the minimum number of operations required to make `num` special.\n\nAn integer `x` is considered special if it is divisible by `25`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.03773584905660377}, {"type": "else", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 18, "end": 19, "difficulty": 2, "eg_cov_prob": 0.2830188679245283}, {"type": "if", "start": 20, "end": 21, "difficulty": 2, "eg_cov_prob": 0.24528301886792453}, {"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.20754716981132076}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.16981132075471697}], "target_lines": [19, 21, 23, 25, 30, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      log_function('LOOP #1: Entered for loop at line 17-28\\n')\n      if seenZero and num[i] == '0':\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        log_function('BRANCH #2: Covered if branch at line 20-21\\n')\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        log_function('BRANCH #3: Covered if branch at line 22-23\\n')\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        log_function('BRANCH #4: Covered if branch at line 24-25\\n')\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      log_function('BRANCH #5: Covered if branch at line 29-30\\n')\n      return n - 1\n    else:\n      log_function('BRANCH #6: Covered else branch at line 31-32\\n')\n      return n\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Operations to Make a Special Number.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 17-28\n", "LOOP #1: Entered for loop at line 17-28\n", "BRANCH #5: Covered if branch at line 29-30\n"], ["LOOP #1: Entered for loop at line 17-28\n", "LOOP #1: Entered for loop at line 17-28\n", "LOOP #1: Entered for loop at line 17-28\n", "LOOP #1: Entered for loop at line 17-28\n", "BRANCH #2: Covered if branch at line 20-21\n"], ["LOOP #1: Entered for loop at line 17-28\n", "LOOP #1: Entered for loop at line 17-28\n", "LOOP #1: Entered for loop at line 17-28\n", "LOOP #1: Entered for loop at line 17-28\n", "BRANCH #1: Covered if branch at line 18-19\n"]], "sampled_condition_paths": [["Line 17: (i in range(n - 1, -1, -1))", "Line 17: (i in range(n - 1, -1, -1))", "Line 29: (seenZero)"], ["Line 17: (i in range(n - 1, -1, -1))", "Line 17: (i in range(n - 1, -1, -1))", "Line 17: (i in range(n - 1, -1, -1))", "Line 17: (i in range(n - 1, -1, -1))", "Line 20: (seenZero and num[i] == '5')"], ["Line 17: (i in range(n - 1, -1, -1))", "Line 17: (i in range(n - 1, -1, -1))", "Line 17: (i in range(n - 1, -1, -1))", "Line 17: (i in range(n - 1, -1, -1))", "Line 18: (seenZero and num[i] == '0')"]]}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "difficulty": 3, "func_name": "minOperationsQueries", "description": "There is an undirected tree with `n` nodes labeled from `0` to `n - 1`. You\nare given the integer `n` and a 2D integer array `edges` of length `n - 1`,\nwhere `edges[i] = [ui, vi, wi]` indicates that there is an edge between nodes\n`ui` and `vi` with weight `wi` in the tree.\n\nYou are also given a 2D integer array `queries` of length `m`, where\n`queries[i] = [ai, bi]`. For each query, find the minimum number of operations\nrequired to make the weight of every edge on the path from `ai` to `bi` equal.\nIn one operation, you can choose any edge of the tree and change its weight to\nany value.\n\nNote that:\n\n* Queries are independent of each other, meaning that the tree returns to its initial state on each new query.\n* The path from `ai` to `bi` is a sequence of distinct nodes starting with node `ai` and ending with node `bi` such that every two adjacent nodes in the sequence share an edge in the tree.\n\nReturn an array `answer` of length `m` where `answer[i]` is the answer to the\n`ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 44, "end": 45, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 49, "end": 50, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 52, "end": 54, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}], "target_lines": [27, 31, 45, 48, 50, 53, 54], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      log_function('LOOP #1: Entered for loop at line 21-24\\n')\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        log_function('BRANCH #1: Covered if branch at line 26-27\\n')\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        log_function('LOOP #2: Entered for loop at line 29-35\\n')\n        if v == prev:\n          log_function('BRANCH #2: Covered if branch at line 30-31\\n')\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      log_function('LOOP #3: Entered for loop at line 39-42\\n')\n      for i in range(n):\n        log_function('LOOP #4: Entered for loop at line 40-42\\n')\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        log_function('BRANCH #3: Covered if branch at line 44-45\\n')\n        return getLCA(v, u)\n      for j in range(m):\n        log_function('LOOP #5: Entered for loop at line 46-48\\n')\n        if depth[v] - depth[u] >> j & 1:\n          log_function('BRANCH #4: Covered if branch at line 47-48\\n')\n          v = jump[v][j]\n      if u == v:\n        log_function('BRANCH #5: Covered if branch at line 49-50\\n')\n        return u\n      for j in range(m - 1, -1, -1):\n        log_function('LOOP #6: Entered for loop at line 51-54\\n')\n        if jump[u][j] != jump[v][j]:\n          log_function('BRANCH #6: Covered if branch at line 52-54\\n')\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      log_function('LOOP #7: Entered for loop at line 57-62\\n')\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Edge Weight Equilibrium Queries in a Tree.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #5: Entered for loop at line 46-48\n", "LOOP #5: Entered for loop at line 46-48\n", "LOOP #6: Entered for loop at line 51-54\n", "LOOP #6: Entered for loop at line 51-54\n", "LOOP #6: Entered for loop at line 51-54\n"], ["LOOP #4: Entered for loop at line 40-42\n", "LOOP #4: Entered for loop at line 40-42\n", "LOOP #4: Entered for loop at line 40-42\n", "LOOP #4: Entered for loop at line 40-42\n", "LOOP #4: Entered for loop at line 40-42\n"], ["BRANCH #1: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 29-35\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 29-35\n", "BRANCH #1: Covered if branch at line 26-27\n"], ["LOOP #2: Entered for loop at line 29-35\n", "BRANCH #1: Covered if branch at line 26-27\n", "LOOP #2: Entered for loop at line 29-35\n", "BRANCH #2: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 29-35\n"]], "sampled_condition_paths": [["Line 46: (j in range(m))", "Line 46: (j in range(m))", "Line 51: (j in range(m - 1, -1, -1))", "Line 51: (j in range(m - 1, -1, -1))", "Line 51: (j in range(m - 1, -1, -1))"], ["Line 40: (i in range(n))", "Line 40: (i in range(n))", "Line 40: (i in range(n))", "Line 40: (i in range(n))", "Line 40: (i in range(n))"], ["Line 26: (prev != -1)", "Line 29: (v, w in graph[u])", "Line 30: (v == prev)", "Line 29: (v, w in graph[u])", "Line 26: (prev != -1)"], ["Line 29: (v, w in graph[u])", "Line 26: (prev != -1)", "Line 29: (v, w in graph[u])", "Line 30: (v == prev)", "Line 29: (v, w in graph[u])"]]}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "difficulty": 2, "func_name": "minimumMoves", "description": "You are given a 0-indexed 2D integer matrix `grid` of size `3 * 3`,\nrepresenting the number of stones in each cell. The grid contains exactly `9`\nstones, and there can be multiple stones in a single cell.\n\nIn one move, you can move a single stone from its current cell to any other\ncell if the two cells share a side.\n\nReturn the minimum number of moves required to place one stone in each cell.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 21, 22, 23, 24, 25, 26, 27, 28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      log_function('BRANCH #1: Covered if branch at line 13-14\\n')\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      log_function('LOOP #1: Entered for loop at line 18-29\\n')\n      for j in range(3):\n        log_function('LOOP #2: Entered for loop at line 19-29\\n')\n        if grid[i][j] == 0:\n          log_function('BRANCH #2: Covered if branch at line 20-28\\n')\n          for x in range(3):\n            log_function('LOOP #3: Entered for loop at line 21-29\\n')\n            for y in range(3):\n              log_function('LOOP #4: Entered for loop at line 22-29\\n')\n              if grid[x][y] > 1:\n                log_function('BRANCH #3: Covered if branch at line 23-28\\n')\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Moves to Spread Stones Over Grid.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 21-29\n", "LOOP #4: Entered for loop at line 22-29\n", "LOOP #4: Entered for loop at line 22-29\n", "LOOP #4: Entered for loop at line 22-29\n", "LOOP #3: Entered for loop at line 21-29\n"], ["LOOP #4: Entered for loop at line 22-29\n", "LOOP #4: Entered for loop at line 22-29\n", "BRANCH #3: Covered if branch at line 23-28\n", "BRANCH #1: Covered if branch at line 13-14\n", "LOOP #4: Entered for loop at line 22-29\n"], ["BRANCH #3: Covered if branch at line 23-28\n", "BRANCH #1: Covered if branch at line 13-14\n", "LOOP #4: Entered for loop at line 22-29\n", "LOOP #1: Entered for loop at line 18-29\n", "LOOP #2: Entered for loop at line 19-29\n"]], "sampled_condition_paths": [["Line 21: (x in range(3))", "Line 22: (y in range(3))", "Line 22: (y in range(3))", "Line 22: (y in range(3))", "Line 21: (x in range(3))"], ["Line 22: (y in range(3))", "Line 22: (y in range(3))", "Line 23: (grid[x][y] > 1)", "Line 13: (sum(row.count(0) for row in grid) == 0)", "Line 22: (y in range(3))"], ["Line 23: (grid[x][y] > 1)", "Line 13: (sum(row.count(0) for row in grid) == 0)", "Line 22: (y in range(3))", "Line 18: (i in range(3))", "Line 19: (j in range(3))"]]}
{"task_num": 2851, "task_title": "String Transformation", "difficulty": 3, "func_name": "numberOfWays", "description": "You are given two strings `s` and `t` of equal length `n`. You can perform the\nfollowing operation on the string `s`:\n\n* Remove a suffix of `s` of length `l` where `0 < l < n` and append it at the start of `s`.  \nFor example, let `s = 'abcd'` then in one operation you can remove the suffix\n`'cd'` and append it in front of `s` making `s = 'cdab'`.\n\nYou are also given an integer `k`. Return the number of ways in which `s` can\nbe transformed into `t` in exactly `k` operations.\n\nSince the answer can be large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [25, 27, 38, 42, 43], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      log_function('LOOP #1: Entered for loop at line 23-27\\n')\n      if index == 0:\n        log_function('BRANCH #1: Covered if branch at line 24-25\\n')\n        res += dp[0]\n      else: \n        log_function('BRANCH #2: Covered else branch at line 26-27\\n')\n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      log_function('LOOP #2: Entered for loop at line 36-43\\n')\n      if i < r:\n        log_function('BRANCH #3: Covered if branch at line 37-38\\n')\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        log_function('LOOP #3: Entered while loop at line 39-40\\n')\n        z[i] += 1\n      if i + z[i] > r:\n        log_function('BRANCH #4: Covered if branch at line 41-43\\n')\n        l = i\n        r = i + z[i]\n    return z\n\ndef log_function(info_str):\n    with open(\"test_logs/String Transformation.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 37-38\n", "LOOP #2: Entered for loop at line 36-43\n", "BRANCH #3: Covered if branch at line 37-38\n", "LOOP #2: Entered for loop at line 36-43\n", "BRANCH #3: Covered if branch at line 37-38\n"], ["BRANCH #3: Covered if branch at line 37-38\n", "LOOP #2: Entered for loop at line 36-43\n", "LOOP #3: Entered while loop at line 39-40\n", "LOOP #3: Entered while loop at line 39-40\n", "BRANCH #4: Covered if branch at line 41-43\n"], ["LOOP #3: Entered while loop at line 39-40\n", "LOOP #3: Entered while loop at line 39-40\n", "LOOP #3: Entered while loop at line 39-40\n", "BRANCH #4: Covered if branch at line 41-43\n", "LOOP #2: Entered for loop at line 36-43\n"], ["LOOP #2: Entered for loop at line 36-43\n", "BRANCH #3: Covered if branch at line 37-38\n", "LOOP #2: Entered for loop at line 36-43\n", "BRANCH #3: Covered if branch at line 37-38\n", "LOOP #2: Entered for loop at line 36-43\n"]], "sampled_condition_paths": [["Line 37: (i < r)", "Line 36: (i in range(1, n))", "Line 37: (i < r)", "Line 36: (i in range(1, n))", "Line 37: (i < r)"], ["Line 37: (i < r)", "Line 36: (i in range(1, n))", "Line 39: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 39: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 41: (i + z[i] > r)"], ["Line 39: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 39: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 39: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 41: (i + z[i] > r)", "Line 36: (i in range(1, n))"], ["Line 36: (i in range(1, n))", "Line 37: (i < r)", "Line 36: (i in range(1, n))", "Line 37: (i < r)", "Line 36: (i in range(1, n))"]]}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "difficulty": 3, "func_name": "countVisitedNodes", "description": "There is a directed graph consisting of `n` nodes numbered from `0` to `n - 1`\nand `n` directed edges.\n\nYou are given a 0-indexed array `edges` where `edges[i]` indicates that there\nis an edge from node `i` to node `edges[i]`.\n\nConsider the following process on the graph:\n\n* You start from a node `x` and keep visiting other nodes through edges until you reach a node that you have already visited before on this same process.\n\nReturn an array `answer` where `answer[i]` is the number of different nodes\nthat you will visit if you perform the process starting from node `i`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [28, 34], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      log_function('LOOP #1: Entered for loop at line 19-21\\n')\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      log_function('LOOP #2: Entered while loop at line 24-31\\n')\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        log_function('BRANCH #1: Covered if branch at line 27-28\\n')\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      log_function('LOOP #3: Entered for loop at line 32-35\\n')\n      if not seen[i]:\n        log_function('BRANCH #2: Covered if branch at line 33-34\\n')\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      log_function('LOOP #4: Entered while loop at line 36-39\\n')\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      log_function('LOOP #5: Entered while loop at line 45-48\\n')\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      log_function('LOOP #6: Entered while loop at line 51-54\\n')\n      ans[u] = cycleLength\n      u = edges[u]\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Visited Nodes in a Directed Graph.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #6: Entered while loop at line 51-54\n", "LOOP #6: Entered while loop at line 51-54\n", "LOOP #6: Entered while loop at line 51-54\n", "LOOP #6: Entered while loop at line 51-54\n", "LOOP #3: Entered for loop at line 32-35\n"], ["LOOP #1: Entered for loop at line 19-21\n", "LOOP #1: Entered for loop at line 19-21\n", "LOOP #1: Entered for loop at line 19-21\n", "LOOP #2: Entered while loop at line 24-31\n", "LOOP #3: Entered for loop at line 32-35\n"], ["LOOP #5: Entered while loop at line 45-48\n", "LOOP #5: Entered while loop at line 45-48\n", "LOOP #5: Entered while loop at line 45-48\n", "LOOP #5: Entered while loop at line 45-48\n", "LOOP #6: Entered while loop at line 51-54\n"], ["LOOP #5: Entered while loop at line 45-48\n", "LOOP #5: Entered while loop at line 45-48\n", "LOOP #6: Entered while loop at line 51-54\n", "LOOP #6: Entered while loop at line 51-54\n", "LOOP #3: Entered for loop at line 32-35\n"]], "sampled_condition_paths": [["Line 51: (u != start)", "Line 51: (u != start)", "Line 51: (u != start)", "Line 51: (u != start)", "Line 32: (i in range(n))"], ["Line 19: (v in edges)", "Line 19: (v in edges)", "Line 19: (v in edges)", "Line 24: (q)", "Line 32: (i in range(n))"], ["Line 45: (not seen[u])", "Line 45: (not seen[u])", "Line 45: (not seen[u])", "Line 45: (not seen[u])", "Line 51: (u != start)"], ["Line 45: (not seen[u])", "Line 45: (not seen[u])", "Line 51: (u != start)", "Line 51: (u != start)", "Line 32: (i in range(n))"]]}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "difficulty": 2, "func_name": "getWordsInLongestSubsequence", "description": "You are given a string array `words`, and an array `groups`, both arrays\nhaving length `n`.\n\nThe hamming distance between two strings of equal length is the number of\npositions at which the corresponding characters are different.\n\nYou need to select the longest subsequence from an array of indices `[0, 1,\n..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ..., ik-1]`\nhaving length `k`, the following holds:\n\n* For adjacent indices in the subsequence, their corresponding groups are unequal, i.e., `groups[ij] != groups[ij+1]`, for each `j` where `0 < j + 1 < k`.\n* `words[ij]` and `words[ij+1]` are equal in length, and the hamming distance between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.\n\nReturn a string array containing the words corresponding to the indices (in\norder) in the selected subsequence. If there are multiple answers, return any\nof them.\n\nNote: strings in `words` may be unequal in length.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 26, "end": 28, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}], "target_lines": [21, 23, 25, 27, 28], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      log_function('LOOP #1: Entered for loop at line 18-29\\n')\n      for j in range(i):\n        log_function('LOOP #2: Entered for loop at line 19-29\\n')\n        if groups[i] == groups[j]:\n          log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n          continue\n        if len(words[i]) != len(words[j]):\n          log_function('BRANCH #2: Covered if branch at line 22-23\\n')\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          log_function('BRANCH #3: Covered if branch at line 24-25\\n')\n          continue\n        if dp[i] < dp[j] + 1:\n          log_function('BRANCH #4: Covered if branch at line 26-28\\n')\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      log_function('LOOP #3: Entered while loop at line 31-34\\n')\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n\ndef log_function(info_str):\n    with open(\"test_logs/Longest Unequal Adjacent Groups Subsequence II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #2: Entered for loop at line 19-29\n", "BRANCH #4: Covered if branch at line 26-28\n", "LOOP #2: Entered for loop at line 19-29\n", "BRANCH #4: Covered if branch at line 26-28\n", "LOOP #1: Entered for loop at line 18-29\n"], ["LOOP #1: Entered for loop at line 18-29\n", "LOOP #2: Entered for loop at line 19-29\n", "BRANCH #4: Covered if branch at line 26-28\n", "LOOP #2: Entered for loop at line 19-29\n", "BRANCH #1: Covered if branch at line 20-21\n"], ["BRANCH #4: Covered if branch at line 26-28\n", "LOOP #1: Entered for loop at line 18-29\n", "LOOP #2: Entered for loop at line 19-29\n", "BRANCH #4: Covered if branch at line 26-28\n", "LOOP #2: Entered for loop at line 19-29\n"], ["LOOP #2: Entered for loop at line 19-29\n", "BRANCH #4: Covered if branch at line 26-28\n", "LOOP #1: Entered for loop at line 18-29\n", "LOOP #2: Entered for loop at line 19-29\n", "BRANCH #4: Covered if branch at line 26-28\n"]], "sampled_condition_paths": [["Line 19: (j in range(i))", "Line 26: (dp[i] < dp[j] + 1)", "Line 19: (j in range(i))", "Line 26: (dp[i] < dp[j] + 1)", "Line 18: (i in range(1, n))"], ["Line 18: (i in range(1, n))", "Line 19: (j in range(i))", "Line 26: (dp[i] < dp[j] + 1)", "Line 19: (j in range(i))", "Line 20: (groups[i] == groups[j])"], ["Line 26: (dp[i] < dp[j] + 1)", "Line 18: (i in range(1, n))", "Line 19: (j in range(i))", "Line 26: (dp[i] < dp[j] + 1)", "Line 19: (j in range(i))"], ["Line 19: (j in range(i))", "Line 26: (dp[i] < dp[j] + 1)", "Line 18: (i in range(1, n))", "Line 19: (j in range(i))", "Line 26: (dp[i] < dp[j] + 1)"]]}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "difficulty": 2, "func_name": "shortestBeautifulSubstring", "description": "You are given a binary string `s` and a positive integer `k`.\n\nA substring of `s` is beautiful if the number of `1`'s in it is exactly `k`.\n\nLet `len` be the length of the shortest beautiful substring.\n\nReturn the lexicographically smallest beautiful substring of string `s` with\nlength equal to `len`. If `s` doesn't contain a beautiful substring, return an\nempty string.\n\nA string `a` is lexicographically larger than a string `b` (of the same\nlength) if in the first position where `a` and `b` differ, `a` has a character\nstrictly larger than the corresponding character in `b`.\n\n* For example, `\"abcd\"` is lexicographically larger than `\"abcc\"` because the first position they differ is at the fourth character, and `d` is greater than `c`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.5094339622641509}, {"type": "else", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.49056603773584906}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 24, "difficulty": 1, "eg_cov_prob": 0.49056603773584906}, {"type": "if", "start": 27, "end": 28, "difficulty": 1, "eg_cov_prob": 0.49056603773584906}, {"type": "if", "start": 25, "end": 26, "difficulty": 1, "eg_cov_prob": 0.4339622641509434}], "target_lines": [20, 23, 24, 26, 28, 32, 34], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      log_function('LOOP #1: Entered for loop at line 18-30\\n')\n      if c == '1':\n        log_function('BRANCH #1: Covered if branch at line 19-20\\n')\n        ones += 1\n      while ones == k:\n        log_function('LOOP #2: Entered while loop at line 21-30\\n')\n        if r - l + 1 < minLength:\n          log_function('BRANCH #2: Covered if branch at line 22-24\\n')\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          log_function('BRANCH #3: Covered elif branch at line 25-26\\n')\n          bestLeft = l\n        if s[l] == '1':\n          log_function('BRANCH #4: Covered if branch at line 27-28\\n')\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      log_function('BRANCH #5: Covered if branch at line 31-32\\n')\n      return \"\"\n    else:\n      log_function('BRANCH #6: Covered else branch at line 33-34\\n')\n      return s[bestLeft:bestLeft + minLength]\n\ndef log_function(info_str):\n    with open(\"test_logs/Shortest and Lexicographically Smallest Beautiful String.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 18-30\n", "LOOP #1: Entered for loop at line 18-30\n", "LOOP #1: Entered for loop at line 18-30\n", "BRANCH #5: Covered if branch at line 31-32\n"], ["BRANCH #2: Covered if branch at line 22-24\n", "BRANCH #4: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 18-30\n", "LOOP #1: Entered for loop at line 18-30\n", "LOOP #1: Entered for loop at line 18-30\n"], ["LOOP #2: Entered while loop at line 21-30\n", "BRANCH #3: Covered elif branch at line 25-26\n", "LOOP #2: Entered while loop at line 21-30\n", "BRANCH #2: Covered if branch at line 22-24\n", "BRANCH #4: Covered if branch at line 27-28\n"], ["BRANCH #3: Covered elif branch at line 25-26\n", "LOOP #2: Entered while loop at line 21-30\n", "BRANCH #2: Covered if branch at line 22-24\n", "BRANCH #4: Covered if branch at line 27-28\n", "BRANCH #6: Covered else branch at line 33-34\n"], ["BRANCH #1: Covered if branch at line 19-20\n", "LOOP #2: Entered while loop at line 21-30\n", "BRANCH #2: Covered if branch at line 22-24\n", "BRANCH #4: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 18-30\n"]], "sampled_condition_paths": [["Line 18: (r, c in enumerate(s))", "Line 18: (r, c in enumerate(s))", "Line 18: (r, c in enumerate(s))", "Line 31: (bestLeft == -1)"], ["Line 22: (r - l + 1 < minLength)", "Line 27: (s[l] == '1')", "Line 18: (r, c in enumerate(s))", "Line 18: (r, c in enumerate(s))", "Line 18: (r, c in enumerate(s))"], ["Line 21: (ones == k)", "Line 22: NOT (r - l + 1 < minLength)", "Line 25: (r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength])", "Line 21: (ones == k)", "Line 22: (r - l + 1 < minLength)", "Line 27: (s[l] == '1')"], ["Line 22: NOT (r - l + 1 < minLength)", "Line 25: (r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength])", "Line 21: (ones == k)", "Line 22: (r - l + 1 < minLength)", "Line 27: (s[l] == '1')", "Line 31: NOT (bestLeft == -1)", "Line 33: "], ["Line 19: (c == '1')", "Line 21: (ones == k)", "Line 22: (r - l + 1 < minLength)", "Line 27: (s[l] == '1')", "Line 18: (r, c in enumerate(s))"]]}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "difficulty": 3, "func_name": "minimumChanges", "description": "Given a string `s` and an integer `k`, partition `s` into `k` substrings such\nthat the letter changes needed to make each substring a semi-palindrome are\nminimized.\n\nReturn the minimum number of letter changes required.\n\nA semi-palindrome is a special type of string that can be divided into\npalindromes based on a repeating pattern. To check if a string is a semi-\npalindrome:\u200b\n\n1. Choose a positive divisor `d` of the string's length. `d` can range from `1` up to, but not including, the string's length. For a string of length `1`, it does not have a valid divisor as per this definition, since the only divisor is its length, which is not allowed.\n2. For a given divisor `d`, divide the string into groups where each group contains characters from the string that follow a repeating pattern of length `d`. Specifically, the first group consists of characters at positions `1`, `1 + d`, `1 + 2d`, and so on; the second group includes characters at positions `2`, `2 + d`, `2 + 2d`, etc.\n3. The string is considered a semi-palindrome if each of these groups forms a palindrome.\n\nConsider the string `\"abcabc\"`:\n\n* The length of `\"abcabc\"` is `6`. Valid divisors are `1`, `2`, and `3`.\n* For `d = 1`: The entire string `\"abcabc\"` forms one group. Not a palindrome.\n* For `d = 2`: \n* Group 1 (positions `1, 3, 5`): `\"acb\"`\n* Group 2 (positions `2, 4, 6`): `\"bac\"`\n* Neither group forms a palindrome.\n* For `d = 3`: \n* Group 1 (positions `1, 4`): `\"aa\"`\n* Group 2 (positions `2, 5`): `\"bb\"`\n* Group 3 (positions `3, 6`): `\"cc\"`\n* All groups form palindromes. Therefore, `\"abcabc\"` is a semi-palindrome.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "blocks": [{"type": "if", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [52], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      log_function('LOOP #1: Entered for loop at line 20-24\\n')\n      for j in range(1, k + 1):\n        log_function('LOOP #2: Entered for loop at line 21-24\\n')\n        for l in range(i + 1, n):\n          log_function('LOOP #3: Entered for loop at line 22-24\\n')\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      log_function('LOOP #4: Entered for loop at line 29-31\\n')\n      for i in range(d * 2, n + 1, d):\n        log_function('LOOP #5: Entered for loop at line 30-31\\n')\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      log_function('LOOP #6: Entered for loop at line 36-42\\n')\n      for j in range(i + 1, n):\n        log_function('LOOP #7: Entered for loop at line 37-42\\n')\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          log_function('LOOP #8: Entered for loop at line 40-41\\n')\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      log_function('LOOP #9: Entered for loop at line 47-54\\n')\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        log_function('LOOP #10: Entered while loop at line 50-54\\n')\n        if s[l] != s[r]:\n          log_function('BRANCH #1: Covered if branch at line 51-52\\n')\n          cost += 1\n        l += d\n        r -= d\n    return cost\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Changes to Make K Semi-palindromes.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #6: Entered for loop at line 36-42\n", "LOOP #7: Entered for loop at line 37-42\n", "LOOP #8: Entered for loop at line 40-41\n", "LOOP #9: Entered for loop at line 47-54\n", "LOOP #10: Entered while loop at line 50-54\n"], ["LOOP #2: Entered for loop at line 21-24\n", "LOOP #3: Entered for loop at line 22-24\n", "LOOP #3: Entered for loop at line 22-24\n", "LOOP #2: Entered for loop at line 21-24\n", "LOOP #3: Entered for loop at line 22-24\n"], ["LOOP #2: Entered for loop at line 21-24\n", "LOOP #3: Entered for loop at line 22-24\n", "LOOP #1: Entered for loop at line 20-24\n", "LOOP #2: Entered for loop at line 21-24\n", "LOOP #3: Entered for loop at line 22-24\n"], ["BRANCH #1: Covered if branch at line 51-52\n", "LOOP #7: Entered for loop at line 37-42\n", "LOOP #8: Entered for loop at line 40-41\n", "LOOP #9: Entered for loop at line 47-54\n", "LOOP #10: Entered while loop at line 50-54\n"], ["LOOP #10: Entered while loop at line 50-54\n", "BRANCH #1: Covered if branch at line 51-52\n", "LOOP #6: Entered for loop at line 36-42\n", "LOOP #7: Entered for loop at line 37-42\n", "LOOP #8: Entered for loop at line 40-41\n"], ["LOOP #10: Entered while loop at line 50-54\n", "BRANCH #1: Covered if branch at line 51-52\n", "LOOP #9: Entered for loop at line 47-54\n", "LOOP #10: Entered while loop at line 50-54\n", "LOOP #6: Entered for loop at line 36-42\n"]], "sampled_condition_paths": [["Line 36: (i in range(n))", "Line 37: (j in range(i + 1, n))", "Line 40: (d in factors[length])", "Line 47: (offset in range(d))", "Line 50: (l < r)"], ["Line 21: (j in range(1, k + 1))", "Line 22: (l in range(i + 1, n))", "Line 22: (l in range(i + 1, n))", "Line 21: (j in range(1, k + 1))", "Line 22: (l in range(i + 1, n))"], ["Line 21: (j in range(1, k + 1))", "Line 22: (l in range(i + 1, n))", "Line 20: (i in range(n - 1, -1, -1))", "Line 21: (j in range(1, k + 1))", "Line 22: (l in range(i + 1, n))"], ["Line 51: (s[l] != s[r])", "Line 37: (j in range(i + 1, n))", "Line 40: (d in factors[length])", "Line 47: (offset in range(d))", "Line 50: (l < r)"], ["Line 50: (l < r)", "Line 51: (s[l] != s[r])", "Line 36: (i in range(n))", "Line 37: (j in range(i + 1, n))", "Line 40: (d in factors[length])"], ["Line 50: (l < r)", "Line 51: (s[l] != s[r])", "Line 47: (offset in range(d))", "Line 50: (l < r)", "Line 36: (i in range(n))"]]}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "difficulty": 1, "func_name": "maximumStrongPairXor", "description": "You are given a 0-indexed integer array `nums`. A pair of integers `x` and `y`\nis called a strong pair if it satisfies the condition:\n\n* `|x - y| <= min(x, y)`\n\nYou need to select two integers from `nums` such that they form a strong pair\nand their bitwise `XOR` is the maximum among all strong pairs in the array.\n\nReturn the maximum `XOR` value out of all possible strong pairs in the array\n`nums`.\n\nNote that you can pick the same integer twice to form a pair.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 44, "end": 45, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [28, 40, 41, 43, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      log_function('LOOP #1: Entered for loop at line 25-32\\n')\n      bit = num >> i & 1\n      if not node.children[bit]:\n        log_function('BRANCH #1: Covered if branch at line 27-28\\n')\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      log_function('LOOP #2: Entered for loop at line 36-45\\n')\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        log_function('BRANCH #2: Covered if branch at line 39-41\\n')\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        log_function('BRANCH #3: Covered elif branch at line 42-43\\n')\n        node = node.children[bit]\n      else:\n        log_function('BRANCH #4: Covered else branch at line 44-45\\n')\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      log_function('LOOP #3: Entered for loop at line 55-57\\n')\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n\ndef log_function(info_str):\n    with open(\"test_logs/Maximum Strong Pair XOR I.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 55-57\n", "LOOP #1: Entered for loop at line 25-32\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 25-32\n", "BRANCH #1: Covered if branch at line 27-28\n"], ["LOOP #2: Entered for loop at line 36-45\n", "BRANCH #3: Covered elif branch at line 42-43\n", "LOOP #2: Entered for loop at line 36-45\n", "BRANCH #2: Covered if branch at line 39-41\n", "LOOP #2: Entered for loop at line 36-45\n"], ["BRANCH #3: Covered elif branch at line 42-43\n", "LOOP #2: Entered for loop at line 36-45\n", "BRANCH #3: Covered elif branch at line 42-43\n", "LOOP #2: Entered for loop at line 36-45\n", "BRANCH #3: Covered elif branch at line 42-43\n"], ["BRANCH #1: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 25-32\n", "BRANCH #1: Covered if branch at line 27-28\n", "LOOP #1: Entered for loop at line 25-32\n", "BRANCH #1: Covered if branch at line 27-28\n"], ["LOOP #2: Entered for loop at line 36-45\n", "BRANCH #3: Covered elif branch at line 42-43\n", "LOOP #2: Entered for loop at line 36-45\n", "BRANCH #3: Covered elif branch at line 42-43\n", "LOOP #2: Entered for loop at line 36-45\n"]], "sampled_condition_paths": [["Line 55: (num in nums)", "Line 25: (i in range(self.maxBit, -1, -1))", "Line 27: (not node.children[bit])", "Line 25: (i in range(self.maxBit, -1, -1))", "Line 27: (not node.children[bit])"], ["Line 36: (i in range(self.maxBit, -1, -1))", "Line 39: NOT (node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x)", "Line 42: (node.children[bit])", "Line 36: (i in range(self.maxBit, -1, -1))", "Line 39: (node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x)", "Line 36: (i in range(self.maxBit, -1, -1))"], ["Line 39: NOT (node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x)", "Line 42: (node.children[bit])", "Line 36: (i in range(self.maxBit, -1, -1))", "Line 39: NOT (node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x)", "Line 42: (node.children[bit])", "Line 36: (i in range(self.maxBit, -1, -1))", "Line 39: NOT (node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x)", "Line 42: (node.children[bit])"], ["Line 27: (not node.children[bit])", "Line 25: (i in range(self.maxBit, -1, -1))", "Line 27: (not node.children[bit])", "Line 25: (i in range(self.maxBit, -1, -1))", "Line 27: (not node.children[bit])"], ["Line 36: (i in range(self.maxBit, -1, -1))", "Line 39: NOT (node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x)", "Line 42: (node.children[bit])", "Line 36: (i in range(self.maxBit, -1, -1))", "Line 39: NOT (node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x)", "Line 42: (node.children[bit])", "Line 36: (i in range(self.maxBit, -1, -1))"]]}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "difficulty": 3, "func_name": "leftmostBuildingQueries", "description": "You are given a 0-indexed array `heights` of positive integers, where\n`heights[i]` represents the height of the `ith` building.\n\nIf a person is in building `i`, they can move to any other building `j` if and\nonly if `i < j` and `heights[i] < heights[j]`.\n\nYou are also given another array `queries` where `queries[i] = [ai, bi]`. On\nthe `ith` query, Alice is in building `ai` while Bob is in building `bi`.\n\nReturn an array `ans` where `ans[i]` is the index of the leftmost building\nwhere Alice and Bob can meet on the `ith` query. If Alice and Bob cannot move\nto a common building on query `i`, set `ans[i]` to `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "blocks": [{"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 32, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [31, 33, 34, 35, 36, 37, 38, 39, 40, 50, 52], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      log_function('LOOP #1: Entered for loop at line 29-41\\n')\n      if a == b or heights[a] < heights[b]:\n        log_function('BRANCH #1: Covered if branch at line 30-31\\n')\n        ans[queryIndex] = b\n      else:\n        log_function('BRANCH #2: Covered else branch at line 32-40\\n')\n        while heightsIndex > b:\n          log_function('LOOP #2: Entered while loop at line 33-37\\n')\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            log_function('LOOP #3: Entered while loop at line 34-35\\n')\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          log_function('BRANCH #3: Covered if branch at line 39-40\\n')\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      log_function('LOOP #4: Entered while loop at line 47-52\\n')\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        log_function('BRANCH #4: Covered if branch at line 49-50\\n')\n        l = m\n      else:\n        log_function('BRANCH #5: Covered else branch at line 51-52\\n')\n        r = m - 1\n    return l\n\ndef log_function(info_str):\n    with open(\"test_logs/Find Building Where Alice and Bob Can Meet.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 29-41\n", "BRANCH #2: Covered else branch at line 32-40\n", "LOOP #2: Entered while loop at line 33-37\n", "LOOP #4: Entered while loop at line 47-52\n", "BRANCH #4: Covered if branch at line 49-50\n"], ["BRANCH #3: Covered if branch at line 39-40\n", "LOOP #1: Entered for loop at line 29-41\n", "BRANCH #2: Covered else branch at line 32-40\n", "LOOP #2: Entered while loop at line 33-37\n", "LOOP #4: Entered while loop at line 47-52\n"], ["LOOP #1: Entered for loop at line 29-41\n", "BRANCH #2: Covered else branch at line 32-40\n", "LOOP #2: Entered while loop at line 33-37\n", "LOOP #2: Entered while loop at line 33-37\n", "LOOP #4: Entered while loop at line 47-52\n"], ["LOOP #4: Entered while loop at line 47-52\n", "BRANCH #4: Covered if branch at line 49-50\n", "LOOP #4: Entered while loop at line 47-52\n", "BRANCH #4: Covered if branch at line 49-50\n", "BRANCH #3: Covered if branch at line 39-40\n"]], "sampled_condition_paths": [["Line 29: (queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b))", "Line 30: NOT (a == b or heights[a] < heights[b])", "Line 32: ", "Line 33: (heightsIndex > b)", "Line 47: (l < r)", "Line 49: (heights[A[m]] > heights[target])"], ["Line 39: (j != -1)", "Line 29: (queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b))", "Line 30: NOT (a == b or heights[a] < heights[b])", "Line 32: ", "Line 33: (heightsIndex > b)", "Line 47: (l < r)"], ["Line 29: (queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b))", "Line 30: NOT (a == b or heights[a] < heights[b])", "Line 32: ", "Line 33: (heightsIndex > b)", "Line 33: (heightsIndex > b)", "Line 47: (l < r)"], ["Line 47: (l < r)", "Line 49: (heights[A[m]] > heights[target])", "Line 47: (l < r)", "Line 49: (heights[A[m]] > heights[target])", "Line 39: (j != -1)"]]}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "difficulty": 2, "func_name": "lexicographicallySmallestArray", "description": "You are given a 0-indexed array of positive integers `nums` and a positive\ninteger `limit`.\n\nIn one operation, you can choose any two indices `i` and `j` and swap\n`nums[i]` and `nums[j]` if `|nums[i] - nums[j]| <= limit`.\n\nReturn the lexicographically smallest array that can be obtained by performing\nthe operation any number of times.\n\nAn array `a` is lexicographically smaller than an array `b` if in the first\nposition where `a` and `b` differ, array `a` has an element that is less than\nthe corresponding element in `b`. For example, the array `[2,10,3]` is\nlexicographically smaller than the array `[10,2,3]` because they differ at\nindex `0` and `2 < 10`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 21], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      log_function('LOOP #1: Entered for loop at line 17-22\\n')\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        log_function('BRANCH #2: Covered else branch at line 20-21\\n')\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      log_function('LOOP #2: Entered for loop at line 23-28\\n')\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        log_function('LOOP #3: Entered for loop at line 26-28\\n')\n        ans[index] = num\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Make Lexicographically Smallest Array by Swapping Elements.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #1: Covered if branch at line 18-19\n", "LOOP #2: Entered for loop at line 23-28\n", "LOOP #3: Entered for loop at line 26-28\n", "LOOP #3: Entered for loop at line 26-28\n", "LOOP #3: Entered for loop at line 26-28\n"], ["LOOP #3: Entered for loop at line 26-28\n", "LOOP #3: Entered for loop at line 26-28\n", "LOOP #2: Entered for loop at line 23-28\n", "LOOP #3: Entered for loop at line 26-28\n", "LOOP #3: Entered for loop at line 26-28\n"], ["LOOP #2: Entered for loop at line 23-28\n", "LOOP #3: Entered for loop at line 26-28\n", "LOOP #3: Entered for loop at line 26-28\n", "LOOP #2: Entered for loop at line 23-28\n", "LOOP #3: Entered for loop at line 26-28\n"], ["LOOP #1: Entered for loop at line 17-22\n", "BRANCH #1: Covered if branch at line 18-19\n", "LOOP #1: Entered for loop at line 17-22\n", "BRANCH #2: Covered else branch at line 20-21\n", "LOOP #1: Entered for loop at line 17-22\n"], ["BRANCH #1: Covered if branch at line 18-19\n", "LOOP #1: Entered for loop at line 17-22\n", "BRANCH #2: Covered else branch at line 20-21\n", "LOOP #1: Entered for loop at line 17-22\n", "BRANCH #1: Covered if branch at line 18-19\n"], ["BRANCH #2: Covered else branch at line 20-21\n", "LOOP #2: Entered for loop at line 23-28\n", "LOOP #3: Entered for loop at line 26-28\n", "LOOP #3: Entered for loop at line 26-28\n", "LOOP #3: Entered for loop at line 26-28\n"]], "sampled_condition_paths": [["Line 18: (not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit)", "Line 23: (numAndIndexesGroup in numAndIndexesGroups)", "Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 26: (num, index in zip(sortedNums, sortedIndices))"], ["Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 23: (numAndIndexesGroup in numAndIndexesGroups)", "Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 26: (num, index in zip(sortedNums, sortedIndices))"], ["Line 23: (numAndIndexesGroup in numAndIndexesGroups)", "Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 23: (numAndIndexesGroup in numAndIndexesGroups)", "Line 26: (num, index in zip(sortedNums, sortedIndices))"], ["Line 17: (numAndIndex in numAndIndexes)", "Line 18: (not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit)", "Line 17: (numAndIndex in numAndIndexes)", "Line 18: NOT (not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit)", "Line 20: ", "Line 17: (numAndIndex in numAndIndexes)"], ["Line 18: (not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit)", "Line 17: (numAndIndex in numAndIndexes)", "Line 18: NOT (not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit)", "Line 20: ", "Line 17: (numAndIndex in numAndIndexes)", "Line 18: (not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit)"], ["Line 18: NOT (not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit)", "Line 20: ", "Line 23: (numAndIndexesGroup in numAndIndexesGroups)", "Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 26: (num, index in zip(sortedNums, sortedIndices))", "Line 26: (num, index in zip(sortedNums, sortedIndices))"]]}
{"task_num": 2953, "task_title": "Count Complete Substrings", "difficulty": 3, "func_name": "countCompleteSubstrings", "description": "You are given a string `word` and an integer `k`.\n\nA substring `s` of `word` is complete if:\n\n* Each character in `s` occurs exactly `k` times.\n* The difference between two adjacent characters is at most `2`. That is, for any two adjacent characters `c1` and `c2` in `s`, the absolute difference in their positions in the alphabet is at most `2`.\n\nReturn the number of complete substrings of `word`.\n\nA substring is a non-empty contiguous sequence of characters in a string.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "blocks": [{"type": "if", "start": 24, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [25, 26, 27, 29, 30, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      log_function('LOOP #1: Entered for loop at line 21-33\\n')\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        log_function('BRANCH #1: Covered if branch at line 24-27\\n')\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        log_function('BRANCH #2: Covered if branch at line 28-30\\n')\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        log_function('BRANCH #3: Covered if branch at line 31-32\\n')\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n\ndef log_function(info_str):\n    with open(\"test_logs/Count Complete Substrings.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 31-32\n", "LOOP #1: Entered for loop at line 21-33\n", "BRANCH #2: Covered if branch at line 28-30\n", "BRANCH #3: Covered if branch at line 31-32\n", "LOOP #1: Entered for loop at line 21-33\n"], ["BRANCH #2: Covered if branch at line 28-30\n", "BRANCH #3: Covered if branch at line 31-32\n", "LOOP #1: Entered for loop at line 21-33\n", "LOOP #1: Entered for loop at line 21-33\n", "LOOP #1: Entered for loop at line 21-33\n"], ["LOOP #1: Entered for loop at line 21-33\n", "BRANCH #2: Covered if branch at line 28-30\n", "BRANCH #3: Covered if branch at line 31-32\n", "LOOP #1: Entered for loop at line 21-33\n", "BRANCH #2: Covered if branch at line 28-30\n"], ["BRANCH #2: Covered if branch at line 28-30\n", "BRANCH #3: Covered if branch at line 31-32\n", "LOOP #1: Entered for loop at line 21-33\n", "BRANCH #2: Covered if branch at line 28-30\n", "BRANCH #3: Covered if branch at line 31-32\n"]], "sampled_condition_paths": [["Line 31: (countLetters == windowSize)", "Line 21: (i, c in enumerate(word))", "Line 28: (countLetters == windowSize + 1)", "Line 31: (countLetters == windowSize)", "Line 21: (i, c in enumerate(word))"], ["Line 28: (countLetters == windowSize + 1)", "Line 31: (countLetters == windowSize)", "Line 21: (i, c in enumerate(word))", "Line 21: (i, c in enumerate(word))", "Line 21: (i, c in enumerate(word))"], ["Line 21: (i, c in enumerate(word))", "Line 28: (countLetters == windowSize + 1)", "Line 31: (countLetters == windowSize)", "Line 21: (i, c in enumerate(word))", "Line 28: (countLetters == windowSize + 1)"], ["Line 28: (countLetters == windowSize + 1)", "Line 31: (countLetters == windowSize)", "Line 21: (i, c in enumerate(word))", "Line 28: (countLetters == windowSize + 1)", "Line 31: (countLetters == windowSize)"]]}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "difficulty": 3, "func_name": "numberOfSets", "description": "There is a company with `n` branches across the country, some of which are\nconnected by roads. Initially, all branches are reachable from each other by\ntraveling some roads.\n\nThe company has realized that they are spending an excessive amount of time\ntraveling between their branches. As a result, they have decided to close down\nsome of these branches (possibly none). However, they want to ensure that the\nremaining branches have a distance of at most `maxDistance` from each other.\n\nThe distance between two branches is the minimum total traveled length needed\nto reach one branch from another.\n\nYou are given integers `n`, `maxDistance`, and a 0-indexed 2D array `roads`,\nwhere `roads[i] = [ui, vi, wi]` represents the undirected road between\nbranches `ui` and `vi` with length `wi`.\n\nReturn the number of possible sets of closing branches, so that any branch has\na distance of at most `maxDistance` from any other.\n\nNote that, after closing a branch, the company will no longer have access to\nany roads connected to it.\n\nNote that, multiple roads are allowed.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 26, "difficulty": 1, "eg_cov_prob": 0.8301886792452831}, {"type": "if", "start": 29, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.8867924528301887}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 25, 26, 30, 31, 32, 33, 34, 38, 39, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      log_function('LOOP #1: Entered for loop at line 19-22\\n')\n      if mask >> i & 1:\n        log_function('BRANCH #1: Covered if branch at line 20-21\\n')\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      log_function('LOOP #2: Entered for loop at line 23-27\\n')\n      if mask >> u & 1 and mask >> v & 1:\n        log_function('BRANCH #2: Covered if branch at line 24-26\\n')\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      log_function('LOOP #3: Entered for loop at line 28-35\\n')\n      if mask >> k & 1:\n        log_function('BRANCH #3: Covered if branch at line 29-34\\n')\n        for i in range(n):\n          log_function('LOOP #4: Entered for loop at line 30-35\\n')\n          if mask >> i & 1:\n            log_function('BRANCH #4: Covered if branch at line 31-34\\n')\n            for j in range(n):\n              log_function('LOOP #5: Entered for loop at line 32-35\\n')\n              if mask >> j & 1:\n                log_function('BRANCH #5: Covered if branch at line 33-34\\n')\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      log_function('LOOP #6: Entered for loop at line 36-41\\n')\n      if mask >> i & 1:\n        log_function('BRANCH #6: Covered if branch at line 37-40\\n')\n        for j in range(i + 1, n):\n          log_function('LOOP #7: Entered for loop at line 38-41\\n')\n          if mask >> j & 1:\n            log_function('BRANCH #7: Covered if branch at line 39-40\\n')\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n\ndef log_function(info_str):\n    with open(\"test_logs/Number of Possible Sets of Closing Branches.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #5: Entered for loop at line 32-35\n", "LOOP #4: Entered for loop at line 30-35\n", "BRANCH #4: Covered if branch at line 31-34\n", "LOOP #5: Entered for loop at line 32-35\n", "BRANCH #5: Covered if branch at line 33-34\n"], ["LOOP #3: Entered for loop at line 28-35\n", "BRANCH #3: Covered if branch at line 29-34\n", "LOOP #4: Entered for loop at line 30-35\n", "BRANCH #4: Covered if branch at line 31-34\n", "LOOP #5: Entered for loop at line 32-35\n"], ["BRANCH #2: Covered if branch at line 24-26\n", "LOOP #3: Entered for loop at line 28-35\n", "BRANCH #3: Covered if branch at line 29-34\n", "LOOP #4: Entered for loop at line 30-35\n", "BRANCH #4: Covered if branch at line 31-34\n"], ["LOOP #2: Entered for loop at line 23-27\n", "BRANCH #2: Covered if branch at line 24-26\n", "LOOP #2: Entered for loop at line 23-27\n", "BRANCH #2: Covered if branch at line 24-26\n", "LOOP #3: Entered for loop at line 28-35\n"], ["LOOP #2: Entered for loop at line 23-27\n", "LOOP #2: Entered for loop at line 23-27\n", "LOOP #2: Entered for loop at line 23-27\n", "BRANCH #2: Covered if branch at line 24-26\n", "LOOP #3: Entered for loop at line 28-35\n"], ["LOOP #6: Entered for loop at line 36-41\n", "LOOP #1: Entered for loop at line 19-22\n", "BRANCH #1: Covered if branch at line 20-21\n", "LOOP #3: Entered for loop at line 28-35\n", "BRANCH #3: Covered if branch at line 29-34\n"]], "sampled_condition_paths": [["Line 32: (j in range(n))", "Line 30: (i in range(n))", "Line 31: (mask >> i & 1)", "Line 32: (j in range(n))", "Line 33: (mask >> j & 1)"], ["Line 28: (k in range(n))", "Line 29: (mask >> k & 1)", "Line 30: (i in range(n))", "Line 31: (mask >> i & 1)", "Line 32: (j in range(n))"], ["Line 24: (mask >> u & 1 and mask >> v & 1)", "Line 28: (k in range(n))", "Line 29: (mask >> k & 1)", "Line 30: (i in range(n))", "Line 31: (mask >> i & 1)"], ["Line 23: (u, v, w in roads)", "Line 24: (mask >> u & 1 and mask >> v & 1)", "Line 23: (u, v, w in roads)", "Line 24: (mask >> u & 1 and mask >> v & 1)", "Line 28: (k in range(n))"], ["Line 23: (u, v, w in roads)", "Line 23: (u, v, w in roads)", "Line 23: (u, v, w in roads)", "Line 24: (mask >> u & 1 and mask >> v & 1)", "Line 28: (k in range(n))"], ["Line 36: (i in range(n))", "Line 19: (i in range(n))", "Line 20: (mask >> i & 1)", "Line 28: (k in range(n))", "Line 29: (mask >> k & 1)"]]}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "difficulty": 3, "func_name": "placedCoins", "description": "You are given an undirected tree with `n` nodes labeled from `0` to `n - 1`,\nand rooted at node `0`. You are given a 2D integer array `edges` of length `n\n- 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between\nnodes `ai` and `bi` in the tree.\n\nYou are also given a 0-indexed integer array `cost` of length `n`, where\n`cost[i]` is the cost assigned to the `ith` node.\n\nYou need to place some coins on every node of the tree. The number of coins to\nbe placed at node `i` can be calculated as:\n\n* If size of the subtree of node `i` is less than `3`, place `1` coin.\n* Otherwise, place an amount of coins equal to the maximum product of cost values assigned to `3` distinct nodes in the subtree of node `i`. If this product is negative, place `0` coins.\n\nReturn an array `coin` of size `n` such that `coin[i]` is the number of coins\nplaced at node `i`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [28, 30, 33, 35, 53], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      log_function('BRANCH #1: Covered if branch at line 27-28\\n')\n      return 1\n    if not self.maxPosCosts:\n      log_function('BRANCH #2: Covered if branch at line 29-30\\n')\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      log_function('BRANCH #3: Covered if branch at line 32-33\\n')\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      log_function('BRANCH #4: Covered if branch at line 34-35\\n')\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      log_function('LOOP #1: Entered for loop at line 45-48\\n')\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        log_function('LOOP #2: Entered for loop at line 51-53\\n')\n        if v != prev:\n          log_function('BRANCH #5: Covered if branch at line 52-53\\n')\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Find Number of Coins to Place in Tree Nodes.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [[]], "sampled_condition_paths": [[]]}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "difficulty": 2, "func_name": "minimumCost", "description": "You are given two 0-indexed strings `source` and `target`, both of length `n`\nand consisting of lowercase English letters. You are also given two 0-indexed\ncharacter arrays `original` and `changed`, and an integer array `cost`, where\n`cost[i]` represents the cost of changing the character `original[i]` to the\ncharacter `changed[i]`.\n\nYou start with the string `source`. In one operation, you can pick a character\n`x` from the string and change it to the character `y` at a cost of `z` if\nthere exists any index `j` such that `cost[j] == z`, `original[j] == x`, and\n`changed[j] == y`.\n\nReturn the minimum cost to convert the string `source` to the string `target`\nusing any number of operations. If it is impossible to convert `source` to\n`target`, return `-1`.\n\nNote that there may exist indices `i`, `j` such that `original[j] ==\noriginal[i]` and `changed[j] == changed[i]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.9433962264150944}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 23, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 25, 26, 30, 34], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      log_function('LOOP #1: Entered for loop at line 16-20\\n')\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      log_function('LOOP #2: Entered for loop at line 21-27\\n')\n      for i in range(26):\n        log_function('LOOP #3: Entered for loop at line 22-27\\n')\n        if dist[i][k] < math.inf:\n          log_function('BRANCH #1: Covered if branch at line 23-26\\n')\n          for j in range(26):\n            log_function('LOOP #4: Entered for loop at line 24-27\\n')\n            if dist[k][j] < math.inf:\n              log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      log_function('LOOP #5: Entered for loop at line 28-36\\n')\n      if s == t:\n        log_function('BRANCH #3: Covered if branch at line 29-30\\n')\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        log_function('BRANCH #4: Covered if branch at line 33-34\\n')\n        return -1\n      ans += dist[u][v]\n\n    return ans\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Cost to Convert String I.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 24-27\n", "LOOP #4: Entered for loop at line 24-27\n", "LOOP #4: Entered for loop at line 24-27\n", "LOOP #4: Entered for loop at line 24-27\n", "LOOP #4: Entered for loop at line 24-27\n"], ["LOOP #3: Entered for loop at line 22-27\n", "LOOP #3: Entered for loop at line 22-27\n", "LOOP #3: Entered for loop at line 22-27\n", "LOOP #3: Entered for loop at line 22-27\n", "LOOP #3: Entered for loop at line 22-27\n"]], "sampled_condition_paths": [["Line 24: (j in range(26))", "Line 24: (j in range(26))", "Line 24: (j in range(26))", "Line 24: (j in range(26))", "Line 24: (j in range(26))"], ["Line 22: (i in range(26))", "Line 22: (i in range(26))", "Line 22: (i in range(26))", "Line 22: (i in range(26))", "Line 22: (i in range(26))"]]}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "difficulty": 3, "func_name": "minimumCost", "description": "You are given two 0-indexed strings `source` and `target`, both of length `n`\nand consisting of lowercase English characters. You are also given two\n0-indexed string arrays `original` and `changed`, and an integer array `cost`,\nwhere `cost[i]` represents the cost of converting the string `original[i]` to\nthe string `changed[i]`.\n\nYou start with the string `source`. In one operation, you can pick a substring\n`x` from the string, and change it to `y` at a cost of `z` if there exists any\nindex `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`.\nYou are allowed to do any number of operations, but any pair of operations\nmust satisfy either of these two conditions:\n\n* The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` or `d < a`. In other words, the indices picked in both operations are disjoint.\n* The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` and `b == d`. In other words, the indices picked in both operations are identical.\n\nReturn the minimum cost to convert the string `source` to the string `target`\nusing any number of operations. If it is impossible to convert `source` to\n`target`, return `-1`.\n\nNote that there may exist indices `i`, `j` such that `original[j] ==\noriginal[i]` and `changed[j] == changed[i]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "blocks": [{"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 52, "end": 53, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 58, "end": 59, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [27, 28, 29, 35, 37, 40, 44, 48, 51, 53, 59], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      log_function('LOOP #1: Entered for loop at line 19-23\\n')\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      log_function('LOOP #2: Entered for loop at line 24-30\\n')\n      for i in range(subCount):\n        log_function('LOOP #3: Entered for loop at line 25-30\\n')\n        if dist[i][k] < math.inf:\n          log_function('BRANCH #1: Covered if branch at line 26-29\\n')\n          for j in range(subCount):\n            log_function('LOOP #4: Entered for loop at line 27-30\\n')\n            if dist[k][j] < math.inf:\n              log_function('BRANCH #2: Covered if branch at line 28-29\\n')\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      log_function('LOOP #5: Entered for loop at line 33-49\\n')\n      if dp[i] == math.inf:\n        log_function('BRANCH #3: Covered if branch at line 34-35\\n')\n        continue\n      if s == t:\n        log_function('BRANCH #4: Covered if branch at line 36-37\\n')\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        log_function('LOOP #6: Entered for loop at line 38-49\\n')\n        if i + subLength > len(source):\n          log_function('BRANCH #5: Covered if branch at line 39-40\\n')\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          log_function('BRANCH #6: Covered if branch at line 43-44\\n')\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          log_function('BRANCH #7: Covered if branch at line 47-48\\n')\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      log_function('BRANCH #8: Covered if branch at line 50-51\\n')\n      return -1\n    else:\n      log_function('BRANCH #9: Covered else branch at line 52-53\\n')\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      log_function('LOOP #7: Entered for loop at line 57-59\\n')\n      if s not in subToId:\n        log_function('BRANCH #10: Covered if branch at line 58-59\\n')\n        subToId[s] = len(subToId)\n    return subToId\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Cost to Convert String II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 25-30\n", "LOOP #2: Entered for loop at line 24-30\n", "LOOP #3: Entered for loop at line 25-30\n"], ["LOOP #7: Entered for loop at line 57-59\n", "BRANCH #10: Covered if branch at line 58-59\n", "LOOP #7: Entered for loop at line 57-59\n", "LOOP #7: Entered for loop at line 57-59\n", "BRANCH #10: Covered if branch at line 58-59\n"], ["LOOP #1: Entered for loop at line 19-23\n", "LOOP #2: Entered for loop at line 24-30\n", "LOOP #3: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 25-30\n"], ["LOOP #4: Entered for loop at line 27-30\n", "LOOP #4: Entered for loop at line 27-30\n", "LOOP #4: Entered for loop at line 27-30\n", "LOOP #3: Entered for loop at line 25-30\n", "LOOP #3: Entered for loop at line 25-30\n"], ["LOOP #7: Entered for loop at line 57-59\n", "LOOP #7: Entered for loop at line 57-59\n", "LOOP #7: Entered for loop at line 57-59\n", "LOOP #1: Entered for loop at line 19-23\n", "LOOP #1: Entered for loop at line 19-23\n"], ["LOOP #4: Entered for loop at line 27-30\n", "BRANCH #2: Covered if branch at line 28-29\n", "LOOP #4: Entered for loop at line 27-30\n", "BRANCH #2: Covered if branch at line 28-29\n", "LOOP #4: Entered for loop at line 27-30\n"]], "sampled_condition_paths": [["Line 25: (i in range(subCount))", "Line 25: (i in range(subCount))", "Line 25: (i in range(subCount))", "Line 24: (k in range(subCount))", "Line 25: (i in range(subCount))"], ["Line 57: (s in original + changed)", "Line 58: (s not in subToId)", "Line 57: (s in original + changed)", "Line 57: (s in original + changed)", "Line 58: (s not in subToId)"], ["Line 19: (a, b, c in zip(original, changed, cost))", "Line 24: (k in range(subCount))", "Line 25: (i in range(subCount))", "Line 25: (i in range(subCount))", "Line 25: (i in range(subCount))"], ["Line 27: (j in range(subCount))", "Line 27: (j in range(subCount))", "Line 27: (j in range(subCount))", "Line 25: (i in range(subCount))", "Line 25: (i in range(subCount))"], ["Line 57: (s in original + changed)", "Line 57: (s in original + changed)", "Line 57: (s in original + changed)", "Line 19: (a, b, c in zip(original, changed, cost))", "Line 19: (a, b, c in zip(original, changed, cost))"], ["Line 27: (j in range(subCount))", "Line 28: (dist[k][j] < math.inf)", "Line 27: (j in range(subCount))", "Line 28: (dist[k][j] < math.inf)", "Line 27: (j in range(subCount))"]]}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "difficulty": 3, "func_name": "canMakePalindromeQueries", "description": "You are given a 0-indexed string `s` having an even length `n`.\n\nYou are also given a 0-indexed 2D integer array, `queries`, where `queries[i]\n= [ai, bi, ci, di]`.\n\nFor each query `i`, you are allowed to perform the following operations:\n\n* Rearrange the characters within the substring `s[ai:bi]`, where `0 <= ai <= bi < n / 2`.\n* Rearrange the characters within the substring `s[ci:di]`, where `n / 2 <= ci <= di < n`.\n\nFor each query, your task is to determine whether it is possible to make `s` a\npalindrome by performing the operations.\n\nEach query is answered independently of the others.\n\nReturn a 0-indexed array `answer`, where `answer[i] == true` if it is possible\nto make `s` a palindrome by performing operations specified by the `ith`\nquery, and `false` otherwise.\n\n* A substring is a contiguous sequence of characters within a string.\n* `s[x:y]` represents the substring consisting of characters from the index `x` to index `y` in `s`, both inclusive.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 31, "end": 48, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 55, "end": 56, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 36, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 37, "end": 39, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 40, "end": 42, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 43, "end": 45, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}], "target_lines": [30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 56], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      log_function('LOOP #1: Entered for loop at line 21-49\\n')\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        log_function('BRANCH #1: Covered if branch at line 29-30\\n')\n        ans.append(False)\n      else:\n        log_function('BRANCH #2: Covered else branch at line 31-48\\n')\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          log_function('BRANCH #3: Covered if branch at line 34-36\\n')\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          log_function('BRANCH #4: Covered if branch at line 37-39\\n')\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          log_function('BRANCH #5: Covered if branch at line 40-42\\n')\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          log_function('BRANCH #6: Covered if branch at line 43-45\\n')\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      log_function('LOOP #2: Entered for loop at line 54-57\\n')\n      if i >= j:\n        log_function('BRANCH #7: Covered if branch at line 55-56\\n')\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      log_function('LOOP #3: Entered for loop at line 63-65\\n')\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n\ndef log_function(info_str):\n    with open(\"test_logs/Palindrome Rearrangement Queries.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #1: Entered for loop at line 21-49\n", "BRANCH #1: Covered if branch at line 29-30\n"], ["LOOP #2: Entered for loop at line 54-57\n", "BRANCH #7: Covered if branch at line 55-56\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n"], ["LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n"], ["BRANCH #2: Covered else branch at line 31-48\n", "BRANCH #3: Covered if branch at line 34-36\n", "BRANCH #4: Covered if branch at line 37-39\n", "LOOP #1: Entered for loop at line 21-49\n", "BRANCH #2: Covered else branch at line 31-48\n"], ["LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #3: Entered for loop at line 63-65\n", "LOOP #1: Entered for loop at line 21-49\n", "BRANCH #2: Covered else branch at line 31-48\n"], ["LOOP #2: Entered for loop at line 54-57\n", "LOOP #2: Entered for loop at line 54-57\n", "LOOP #2: Entered for loop at line 54-57\n", "LOOP #2: Entered for loop at line 54-57\n", "BRANCH #7: Covered if branch at line 55-56\n"]], "sampled_condition_paths": [["Line 63: (c in s)", "Line 63: (c in s)", "Line 63: (c in s)", "Line 21: (a, b, c, d in queries)", "Line 29: ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0))"], ["Line 54: (i, j in zip(range(len(s)), reversed(range(len(s)))))", "Line 55: (i >= j)", "Line 63: (c in s)", "Line 63: (c in s)", "Line 63: (c in s)"], ["Line 63: (c in s)", "Line 63: (c in s)", "Line 63: (c in s)", "Line 63: (c in s)", "Line 63: (c in s)"], ["Line 29: NOT ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0))", "Line 31: ", "Line 34: (a > rd)", "Line 37: (rc > b)", "Line 21: (a, b, c, d in queries)", "Line 29: NOT ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0))", "Line 31: "], ["Line 63: (c in s)", "Line 63: (c in s)", "Line 63: (c in s)", "Line 21: (a, b, c, d in queries)", "Line 29: NOT ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0))", "Line 31: "], ["Line 54: (i, j in zip(range(len(s)), reversed(range(len(s)))))", "Line 54: (i, j in zip(range(len(s)), reversed(range(len(s)))))", "Line 54: (i, j in zip(range(len(s)), reversed(range(len(s)))))", "Line 54: (i, j in zip(range(len(s)), reversed(range(len(s)))))", "Line 55: (i >= j)"]]}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "difficulty": 2, "func_name": "minMovesToCaptureTheQueen", "description": "There is a 1-indexed `8 x 8` chessboard containing `3` pieces.\n\nYou are given `6` integers `a`, `b`, `c`, `d`, `e`, and `f` where:\n\n* `(a, b)` denotes the position of the white rook.\n* `(c, d)` denotes the position of the white bishop.\n* `(e, f)` denotes the position of the black queen.\n\nGiven that you can only move the white pieces, return the minimum number of\nmoves required to capture the black queen.\n\nNote that:\n\n* Rooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces.\n* Bishops can move any number of squares diagonally, but cannot jump over other pieces.\n* A rook or a bishop can capture the queen if it is located in a square that they can move to.\n* The queen does not move.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "blocks": [{"type": "if", "start": 13, "end": 17, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 18, "end": 22, "difficulty": 2, "eg_cov_prob": 0.09433962264150944}, {"type": "if", "start": 23, "end": 27, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 28, "end": 32, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 14, "end": 15, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.09433962264150944}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}], "target_lines": [14, 15, 17, 19, 20, 22, 24, 25, 27, 29, 30, 32], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      log_function('BRANCH #1: Covered if branch at line 13-17\\n')\n      if c == a and (b < d < f or b > d > f):\n        log_function('BRANCH #2: Covered if branch at line 14-15\\n')\n        return 2\n      else:\n        log_function('BRANCH #3: Covered else branch at line 16-17\\n')\n        return 1\n    if b == f:\n      log_function('BRANCH #4: Covered if branch at line 18-22\\n')\n      if d == f and (a < c < e or a > c > e):\n        log_function('BRANCH #5: Covered if branch at line 19-20\\n')\n        return 2\n      else:\n        log_function('BRANCH #6: Covered else branch at line 21-22\\n')\n        return 1\n    if c + d == e + f:\n      log_function('BRANCH #7: Covered if branch at line 23-27\\n')\n      if a + b == c + d and (c < a < e or c > a > e):\n        log_function('BRANCH #8: Covered if branch at line 24-25\\n')\n        return 2\n      else:\n        log_function('BRANCH #9: Covered else branch at line 26-27\\n')\n        return 1\n    if c - d == e - f:\n      log_function('BRANCH #10: Covered if branch at line 28-32\\n')\n      if a - b == c - d and (c < a < e or c > a > e):\n        log_function('BRANCH #11: Covered if branch at line 29-30\\n')\n        return 2\n      else:\n        log_function('BRANCH #12: Covered else branch at line 31-32\\n')\n        return 1\n    return 2\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Moves to Capture The Queen.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [[], ["BRANCH #1: Covered if branch at line 13-17\n", "BRANCH #3: Covered else branch at line 16-17\n"]], "sampled_condition_paths": [[], ["Line 13: (a == e)", "Line 14: NOT (c == a and (b < d < f or b > d > f))", "Line 16: "]]}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "difficulty": 2, "func_name": "beautifulIndices", "description": "You are given a 0-indexed string `s`, a string `a`, a string `b`, and an\ninteger `k`.\n\nAn index `i` is beautiful if:\n\n* `0 <= i <= s.length - a.length`\n* `s[i..(i + a.length - 1)] == a`\n* There exists an index `j` such that: \n* `0 <= j <= s.length - b.length`\n* `s[j..(j + b.length - 1)] == b`\n* `|j - i| <= k`\n\nReturn the array that contains beautiful indices in sorted order from smallest\nto largest.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.24528301886792453}, {"type": "if", "start": 43, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 35, "difficulty": 2, "eg_cov_prob": 0.37735849056603776}, {"type": "if", "start": 46, "end": 48, "difficulty": 2, "eg_cov_prob": 0.2830188679245283}, {"type": "if", "start": 49, "end": 50, "difficulty": 1, "eg_cov_prob": 0.9056603773584906}, {"type": "else", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 34, 35, 44, 45, 46, 47, 48, 50, 52], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      log_function('LOOP #1: Entered for loop at line 18-23\\n')\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        log_function('LOOP #2: Entered while loop at line 19-20\\n')\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        log_function('BRANCH #1: Covered if branch at line 21-22\\n')\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        log_function('LOOP #3: Entered for loop at line 30-35\\n')\n        while j > 0 and pattern[j] != pattern[i]:\n          log_function('LOOP #4: Entered while loop at line 31-32\\n')\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          log_function('BRANCH #2: Covered if branch at line 33-35\\n')\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      log_function('LOOP #5: Entered while loop at line 42-52\\n')\n      if s[i] == pattern[j]:\n        log_function('BRANCH #3: Covered if branch at line 43-48\\n')\n        i += 1\n        j += 1\n        if j == len(pattern):\n          log_function('BRANCH #4: Covered if branch at line 46-48\\n')\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        log_function('BRANCH #5: Covered elif branch at line 49-50\\n')\n        j = lps[j - 1]\n      else:\n        log_function('BRANCH #6: Covered else branch at line 51-52\\n')\n        i += 1\n    return res\n\ndef log_function(info_str):\n    with open(\"test_logs/Find Beautiful Indices in the Given Array I.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 43-48\n", "BRANCH #4: Covered if branch at line 46-48\n", "LOOP #5: Entered while loop at line 42-52\n", "BRANCH #6: Covered else branch at line 51-52\n", "LOOP #5: Entered while loop at line 42-52\n"], ["LOOP #3: Entered for loop at line 30-35\n", "LOOP #3: Entered for loop at line 30-35\n", "LOOP #3: Entered for loop at line 30-35\n", "LOOP #3: Entered for loop at line 30-35\n", "LOOP #3: Entered for loop at line 30-35\n"], ["LOOP #5: Entered while loop at line 42-52\n", "BRANCH #3: Covered if branch at line 43-48\n", "LOOP #5: Entered while loop at line 42-52\n", "BRANCH #3: Covered if branch at line 43-48\n", "LOOP #5: Entered while loop at line 42-52\n"]], "sampled_condition_paths": [["Line 43: (s[i] == pattern[j])", "Line 46: (j == len(pattern))", "Line 42: (i < len(s))", "Line 43: NOT (s[i] == pattern[j])", "Line 49: NOT (j != 0)", "Line 51: ", "Line 42: (i < len(s))"], ["Line 30: (i in range(1, len(pattern)))", "Line 30: (i in range(1, len(pattern)))", "Line 30: (i in range(1, len(pattern)))", "Line 30: (i in range(1, len(pattern)))", "Line 30: (i in range(1, len(pattern)))"], ["Line 42: (i < len(s))", "Line 43: (s[i] == pattern[j])", "Line 42: (i < len(s))", "Line 43: (s[i] == pattern[j])", "Line 42: (i < len(s))"]]}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "difficulty": 2, "func_name": "minimumTimeToInitialState", "description": "You are given a 0-indexed string `word` and an integer `k`.\n\nAt every second, you must perform the following operations:\n\n* Remove the first `k` characters of `word`.\n* Add any `k` characters to the end of `word`.\n\nNote that you do not necessarily need to add the same characters that you\nremoved. However, you must perform both operations at every second.\n\nReturn the minimum time greater than zero required for `word` to revert to its\ninitial state.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 33, "end": 35, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}], "target_lines": [19, 30, 34, 35], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      log_function('LOOP #1: Entered for loop at line 17-20\\n')\n      if z[ans * k] >= n - ans * k:\n        log_function('BRANCH #1: Covered if branch at line 18-19\\n')\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      log_function('LOOP #2: Entered for loop at line 28-35\\n')\n      if i < r:\n        log_function('BRANCH #2: Covered if branch at line 29-30\\n')\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        log_function('LOOP #3: Entered while loop at line 31-32\\n')\n        z[i] += 1\n      if i + z[i] > r:\n        log_function('BRANCH #3: Covered if branch at line 33-35\\n')\n        l = i\n        r = i + z[i]\n    return z\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Time to Revert Word to Initial State I.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #3: Covered if branch at line 33-35\n", "LOOP #2: Entered for loop at line 28-35\n", "LOOP #3: Entered while loop at line 31-32\n", "LOOP #3: Entered while loop at line 31-32\n", "LOOP #3: Entered while loop at line 31-32\n"], ["LOOP #3: Entered while loop at line 31-32\n", "BRANCH #3: Covered if branch at line 33-35\n", "LOOP #2: Entered for loop at line 28-35\n", "LOOP #2: Entered for loop at line 28-35\n", "LOOP #3: Entered while loop at line 31-32\n"], ["BRANCH #3: Covered if branch at line 33-35\n", "LOOP #2: Entered for loop at line 28-35\n", "BRANCH #3: Covered if branch at line 33-35\n", "LOOP #2: Entered for loop at line 28-35\n", "BRANCH #3: Covered if branch at line 33-35\n"], ["LOOP #2: Entered for loop at line 28-35\n", "LOOP #3: Entered while loop at line 31-32\n", "LOOP #3: Entered while loop at line 31-32\n", "LOOP #3: Entered while loop at line 31-32\n", "BRANCH #3: Covered if branch at line 33-35\n"], ["LOOP #3: Entered while loop at line 31-32\n", "LOOP #3: Entered while loop at line 31-32\n", "BRANCH #3: Covered if branch at line 33-35\n", "LOOP #2: Entered for loop at line 28-35\n", "BRANCH #2: Covered if branch at line 29-30\n"]], "sampled_condition_paths": [["Line 33: (i + z[i] > r)", "Line 28: (i in range(1, n))", "Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])"], ["Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 33: (i + z[i] > r)", "Line 28: (i in range(1, n))", "Line 28: (i in range(1, n))", "Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])"], ["Line 33: (i + z[i] > r)", "Line 28: (i in range(1, n))", "Line 33: (i + z[i] > r)", "Line 28: (i in range(1, n))", "Line 33: (i + z[i] > r)"], ["Line 28: (i in range(1, n))", "Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 33: (i + z[i] > r)"], ["Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 31: (i + z[i] < n and s[z[i]] == s[i + z[i]])", "Line 33: (i + z[i] > r)", "Line 28: (i in range(1, n))", "Line 29: (i < r)"]]}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "difficulty": 2, "func_name": "resultGrid", "description": "You are given a 0-indexed `m x n` grid `image` which represents a grayscale\nimage, where `image[i][j]` represents a pixel with intensity in the\nrange`[0..255]`. You are also given a non-negative integer `threshold`.\n\nTwo pixels `image[a][b]` and `image[c][d]` are said to be adjacent if `|a - c|\n+ |b - d| == 1`.\n\nA region is a `3 x 3` subgrid where the absolute difference in intensity\nbetween any two adjacent pixels is less than or equal to `threshold`.\n\nAll pixels in a region belong to that region, note that a pixel can belong to\nmultiple regions.\n\nYou need to calculate a 0-indexed `m x n` grid `result`, where `result[i][j]`\nis the average intensity of the region to which `image[i][j]` belongs, rounded\ndown to the nearest integer. If `image[i][j]` belongs to multiple regions,\n`result[i][j]` is the average of the rounded down average intensities of these\nregions, rounded down to the nearest integer. If `image[i][j]` does not belong\nto any region, `result[i][j]` is equal to `image[i][j]`.\n\nReturn the grid `result`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "blocks": [{"type": "if", "start": 20, "end": 25, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 37, "end": 38, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}], "target_lines": [21, 22, 23, 24, 25, 30, 38, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      log_function('LOOP #1: Entered for loop at line 18-26\\n')\n      for j in range(n - 2):\n        log_function('LOOP #2: Entered for loop at line 19-26\\n')\n        if self._isRegion(image, i, j, threshold):\n          log_function('BRANCH #1: Covered if branch at line 20-25\\n')\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            log_function('LOOP #3: Entered for loop at line 22-26\\n')\n            for y in range(j, j + 3):\n              log_function('LOOP #4: Entered for loop at line 23-26\\n')\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      log_function('LOOP #5: Entered for loop at line 27-31\\n')\n      for j in range(n):\n        log_function('LOOP #6: Entered for loop at line 28-31\\n')\n        if counts[i][j] > 0:\n          log_function('BRANCH #2: Covered if branch at line 29-30\\n')\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      log_function('LOOP #7: Entered for loop at line 35-40\\n')\n      for y in range(j, j + 3):\n        log_function('LOOP #8: Entered for loop at line 36-40\\n')\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          log_function('BRANCH #3: Covered if branch at line 37-38\\n')\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          log_function('BRANCH #4: Covered if branch at line 39-40\\n')\n          return False\n    return True\n\ndef log_function(info_str):\n    with open(\"test_logs/Find the Grid of Region Average.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [[]], "sampled_condition_paths": [[]]}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "difficulty": 2, "func_name": "longestCommonPrefix", "description": "You are given two arrays with positive integers `arr1` and `arr2`.\n\nA prefix of a positive integer is an integer formed by one or more of its\ndigits, starting from its leftmost digit. For example, `123` is a prefix of\nthe integer `12345`, while `234` is not.\n\nA common prefix of two integers `a` and `b` is an integer `c`, such that `c`\nis a prefix of both `a` and `b`. For example, `5655359` and `56554` have a\ncommon prefix `565` while `1223` and `43456` do not have a common prefix.\n\nYou need to find the length of the longest common prefix between all pairs of\nintegers `(x, y)` such that `x` belongs to `arr1` and `y` belongs to `arr2`.\n\nReturn the length of the longest common prefix among all pairs. If no common\nprefix exists among them, return `0`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "blocks": [{"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [31], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      log_function('LOOP #1: Entered for loop at line 22-23\\n')\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      log_function('LOOP #2: Entered for loop at line 29-33\\n')\n      if c not in node.children:\n        log_function('BRANCH #1: Covered if branch at line 30-31\\n')\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      log_function('LOOP #3: Entered for loop at line 41-43\\n')\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n\ndef log_function(info_str):\n    with open(\"test_logs/Find the Length of the Longest Common Prefix.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 41-43\n", "LOOP #1: Entered for loop at line 22-23\n", "LOOP #1: Entered for loop at line 22-23\n", "LOOP #3: Entered for loop at line 41-43\n", "LOOP #1: Entered for loop at line 22-23\n"], ["BRANCH #1: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 29-33\n", "BRANCH #1: Covered if branch at line 30-31\n", "LOOP #2: Entered for loop at line 29-33\n", "BRANCH #1: Covered if branch at line 30-31\n"], ["LOOP #1: Entered for loop at line 22-23\n", "LOOP #2: Entered for loop at line 29-33\n", "LOOP #2: Entered for loop at line 29-33\n", "LOOP #2: Entered for loop at line 29-33\n", "LOOP #2: Entered for loop at line 29-33\n"], ["LOOP #1: Entered for loop at line 22-23\n", "LOOP #3: Entered for loop at line 41-43\n", "LOOP #1: Entered for loop at line 22-23\n", "LOOP #3: Entered for loop at line 41-43\n", "LOOP #1: Entered for loop at line 22-23\n"]], "sampled_condition_paths": [["Line 41: (num in arr1)", "Line 22: (c in word)", "Line 22: (c in word)", "Line 41: (num in arr1)", "Line 22: (c in word)"], ["Line 30: (c not in node.children)", "Line 29: (c in word)", "Line 30: (c not in node.children)", "Line 29: (c in word)", "Line 30: (c not in node.children)"], ["Line 22: (c in word)", "Line 29: (c in word)", "Line 29: (c in word)", "Line 29: (c in word)", "Line 29: (c in word)"], ["Line 22: (c in word)", "Line 41: (num in arr1)", "Line 22: (c in word)", "Line 41: (num in arr1)", "Line 22: (c in word)"]]}
{"task_num": 3044, "task_title": "Most Frequent Prime", "difficulty": 2, "func_name": "mostFrequentPrime", "description": "You are given a `m x n` 0-indexed 2D matrix `mat`. From every cell, you can\ncreate numbers in the following way:\n\n* There could be at most `8` paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.\n* Select a path from them and append digits in this path to the number being formed by traveling in this direction.\n* Note that numbers are generated at every step, for example, if the digits along the path are `1, 9, 1`, then there will be three numbers generated along the way: `1, 19, 191`.\n\nReturn the most frequent prime number greater than `10` out of all the numbers\ncreated by traversing the matrix or `-1` if no such prime number exists. If\nthere are multiple prime numbers with the highest frequency, then return the\nlargest among them.\n\nNote: It is invalid to change the direction during the move.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "blocks": [{"type": "if", "start": 35, "end": 36, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}], "target_lines": [31, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      log_function('LOOP #1: Entered for loop at line 22-34\\n')\n      for j in range(n):\n        log_function('LOOP #2: Entered for loop at line 23-34\\n')\n        for dx, dy in dirs:\n          log_function('LOOP #3: Entered for loop at line 24-34\\n')\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            log_function('LOOP #4: Entered while loop at line 28-34\\n')\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              log_function('BRANCH #1: Covered if branch at line 30-31\\n')\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      log_function('BRANCH #2: Covered if branch at line 35-36\\n')\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n\ndef log_function(info_str):\n    with open(\"test_logs/Most Frequent Prime.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered while loop at line 28-34\n", "LOOP #4: Entered while loop at line 28-34\n", "LOOP #3: Entered for loop at line 24-34\n", "LOOP #4: Entered while loop at line 28-34\n", "LOOP #4: Entered while loop at line 28-34\n"], ["LOOP #4: Entered while loop at line 28-34\n", "LOOP #3: Entered for loop at line 24-34\n", "LOOP #4: Entered while loop at line 28-34\n", "LOOP #4: Entered while loop at line 28-34\n", "BRANCH #1: Covered if branch at line 30-31\n"], ["LOOP #4: Entered while loop at line 28-34\n", "LOOP #3: Entered for loop at line 24-34\n", "LOOP #4: Entered while loop at line 28-34\n", "LOOP #3: Entered for loop at line 24-34\n", "LOOP #4: Entered while loop at line 28-34\n"], ["LOOP #3: Entered for loop at line 24-34\n", "LOOP #4: Entered while loop at line 28-34\n", "LOOP #3: Entered for loop at line 24-34\n", "LOOP #4: Entered while loop at line 28-34\n", "LOOP #3: Entered for loop at line 24-34\n"]], "sampled_condition_paths": [["Line 28: (0 <= x < m and 0 <= y < n)", "Line 28: (0 <= x < m and 0 <= y < n)", "Line 24: (dx, dy in dirs)", "Line 28: (0 <= x < m and 0 <= y < n)", "Line 28: (0 <= x < m and 0 <= y < n)"], ["Line 28: (0 <= x < m and 0 <= y < n)", "Line 24: (dx, dy in dirs)", "Line 28: (0 <= x < m and 0 <= y < n)", "Line 28: (0 <= x < m and 0 <= y < n)", "Line 30: (num > 10 and isPrime(num))"], ["Line 28: (0 <= x < m and 0 <= y < n)", "Line 24: (dx, dy in dirs)", "Line 28: (0 <= x < m and 0 <= y < n)", "Line 24: (dx, dy in dirs)", "Line 28: (0 <= x < m and 0 <= y < n)"], ["Line 24: (dx, dy in dirs)", "Line 28: (0 <= x < m and 0 <= y < n)", "Line 24: (dx, dy in dirs)", "Line 28: (0 <= x < m and 0 <= y < n)", "Line 24: (dx, dy in dirs)"]]}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "difficulty": 3, "func_name": "resultArray", "description": "You are given a 1-indexed array of integers `nums` of length `n`.\n\nWe define a function `greaterCount` such that `greaterCount(arr, val)` returns\nthe number of elements in `arr` that are strictly greater than `val`.\n\nYou need to distribute all the elements of `nums` between two arrays `arr1`\nand `arr2` using `n` operations. In the first operation, append `nums[1]` to\n`arr1`. In the second operation, append `nums[2]` to `arr2`. Afterwards, in\nthe `ith` operation:\n\n* If `greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i])`, append `nums[i]` to `arr1`.\n* If `greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i])`, append `nums[i]` to `arr2`.\n* If `greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i])`, append `nums[i]` to the array with a lesser number of elements.\n* If there is still a tie, append `nums[i]` to `arr1`.\n\nThe array `result` is formed by concatenating the arrays `arr1` and `arr2`.\nFor example, if `arr1 == [1,2,3]` and `arr2 == [4,5,6]`, then `result =\n[1,2,3,4,5,6]`.\n\nReturn the integer array `result`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "blocks": [{"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 54, "end": 55, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 56, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [51, 53, 55, 57], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      log_function('LOOP #1: Entered while loop at line 16-19\\n')\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      log_function('LOOP #2: Entered while loop at line 22-24\\n')\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      log_function('LOOP #3: Entered for loop at line 47-58\\n')\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        log_function('BRANCH #1: Covered if branch at line 50-51\\n')\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        log_function('BRANCH #2: Covered elif branch at line 52-53\\n')\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        log_function('BRANCH #3: Covered elif branch at line 54-55\\n')\n        add(nums[i], arr2, tree2)\n      else:\n        log_function('BRANCH #4: Covered else branch at line 56-57\\n')\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      log_function('LOOP #4: Entered for loop at line 64-66\\n')\n      rank += 1\n      ranks[num] = rank\n    return ranks\n\ndef log_function(info_str):\n    with open(\"test_logs/Distribute Elements Into Two Arrays II.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #4: Entered for loop at line 64-66\n", "LOOP #4: Entered for loop at line 64-66\n", "LOOP #4: Entered for loop at line 64-66\n", "LOOP #1: Entered while loop at line 16-19\n", "LOOP #1: Entered while loop at line 16-19\n"], ["LOOP #1: Entered while loop at line 16-19\n", "LOOP #1: Entered while loop at line 16-19\n", "LOOP #3: Entered for loop at line 47-58\n", "LOOP #2: Entered while loop at line 22-24\n", "LOOP #2: Entered while loop at line 22-24\n"], ["LOOP #2: Entered while loop at line 22-24\n", "BRANCH #4: Covered else branch at line 56-57\n", "LOOP #1: Entered while loop at line 16-19\n", "LOOP #3: Entered for loop at line 47-58\n", "LOOP #2: Entered while loop at line 22-24\n"], ["LOOP #4: Entered for loop at line 64-66\n", "LOOP #1: Entered while loop at line 16-19\n", "LOOP #1: Entered while loop at line 16-19\n", "LOOP #1: Entered while loop at line 16-19\n", "LOOP #3: Entered for loop at line 47-58\n"], ["LOOP #3: Entered for loop at line 47-58\n", "LOOP #2: Entered while loop at line 22-24\n", "LOOP #2: Entered while loop at line 22-24\n", "BRANCH #4: Covered else branch at line 56-57\n", "LOOP #1: Entered while loop at line 16-19\n"]], "sampled_condition_paths": [["Line 64: (num in sorted(set(nums)))", "Line 64: (num in sorted(set(nums)))", "Line 64: (num in sorted(set(nums)))", "Line 16: (i < len(self.sums))", "Line 16: (i < len(self.sums))"], ["Line 16: (i < len(self.sums))", "Line 16: (i < len(self.sums))", "Line 47: (i in range(2, len(nums)))", "Line 22: (i > 0)", "Line 22: (i > 0)"], ["Line 22: (i > 0)", "Line 50: NOT (greaterCount1 > greaterCount2)", "Line 52: NOT (greaterCount1 < greaterCount2)", "Line 54: NOT (len(arr1) > len(arr2))", "Line 56: ", "Line 16: (i < len(self.sums))", "Line 47: (i in range(2, len(nums)))", "Line 22: (i > 0)"], ["Line 64: (num in sorted(set(nums)))", "Line 16: (i < len(self.sums))", "Line 16: (i < len(self.sums))", "Line 16: (i < len(self.sums))", "Line 47: (i in range(2, len(nums)))"], ["Line 47: (i in range(2, len(nums)))", "Line 22: (i > 0)", "Line 22: (i > 0)", "Line 50: NOT (greaterCount1 > greaterCount2)", "Line 52: NOT (greaterCount1 < greaterCount2)", "Line 54: NOT (len(arr1) > len(arr2))", "Line 56: ", "Line 16: (i < len(self.sums))"]]}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "difficulty": 1, "func_name": "minimumSubarrayLength", "description": "You are given an array `nums` of non-negative integers and an integer `k`.\n\nAn array is called special if the bitwise `OR` of all of its elements is at\nleast `k`.\n\nReturn the length of the shortest special non-empty subarray of `nums`, or\nreturn `-1` if no special subarray exists.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "blocks": [{"type": "if", "start": 29, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [30, 31, 32, 38, 39, 40], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      log_function('LOOP #1: Entered for loop at line 18-24\\n')\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        log_function('LOOP #2: Entered while loop at line 20-24\\n')\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      log_function('LOOP #3: Entered for loop at line 28-32\\n')\n      if num >> i & 1:\n        log_function('BRANCH #1: Covered if branch at line 29-32\\n')\n        count[i] += 1\n        if count[i] == 1:\n          log_function('BRANCH #2: Covered if branch at line 31-32\\n')\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      log_function('LOOP #4: Entered for loop at line 36-40\\n')\n      if num >> i & 1:\n        log_function('BRANCH #3: Covered if branch at line 37-40\\n')\n        count[i] -= 1\n        if count[i] == 0:\n          log_function('BRANCH #4: Covered if branch at line 39-40\\n')\n          ors -= 1 << i\n    return ors\n\ndef log_function(info_str):\n    with open(\"test_logs/Shortest Subarray With OR at Least K I.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #3: Entered for loop at line 28-32\n", "LOOP #3: Entered for loop at line 28-32\n", "LOOP #3: Entered for loop at line 28-32\n", "LOOP #3: Entered for loop at line 28-32\n", "LOOP #3: Entered for loop at line 28-32\n"], ["LOOP #3: Entered for loop at line 28-32\n", "LOOP #3: Entered for loop at line 28-32\n", "LOOP #1: Entered for loop at line 18-24\n", "LOOP #3: Entered for loop at line 28-32\n", "LOOP #3: Entered for loop at line 28-32\n"], ["LOOP #3: Entered for loop at line 28-32\n", "LOOP #2: Entered while loop at line 20-24\n", "LOOP #4: Entered for loop at line 36-40\n", "LOOP #4: Entered for loop at line 36-40\n", "BRANCH #3: Covered if branch at line 37-40\n"]], "sampled_condition_paths": [["Line 28: (i in range(30))", "Line 28: (i in range(30))", "Line 28: (i in range(30))", "Line 28: (i in range(30))", "Line 28: (i in range(30))"], ["Line 28: (i in range(30))", "Line 28: (i in range(30))", "Line 18: (r, num in enumerate(nums))", "Line 28: (i in range(30))", "Line 28: (i in range(30))"], ["Line 28: (i in range(30))", "Line 20: (ors >= k and l <= r)", "Line 36: (i in range(30))", "Line 36: (i in range(30))", "Line 37: (num >> i & 1)"]]}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "difficulty": 3, "func_name": "minimumDistance", "description": "You are given a array `points` representing integer coordinates of some points\non a 2D plane, where `points[i] = [xi, yi]`.\n\nThe distance between two points is defined as their Manhattan distance.\n\nReturn the minimum possible value for maximum distance between any two points\nby removing exactly one point.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "blocks": [{"type": "if", "start": 46, "end": 47, "difficulty": 1, "eg_cov_prob": 0.7735849056603774}, {"type": "else", "start": 48, "end": 49, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [30, 34, 35, 37, 38, 40, 41, 43, 44, 47, 49], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      log_function('LOOP #1: Entered for loop at line 28-45\\n')\n      if i == excludedIndex:\n        log_function('BRANCH #1: Covered if branch at line 29-30\\n')\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        log_function('BRANCH #2: Covered if branch at line 33-35\\n')\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        log_function('BRANCH #3: Covered if branch at line 36-38\\n')\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        log_function('BRANCH #4: Covered if branch at line 39-41\\n')\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        log_function('BRANCH #5: Covered if branch at line 42-44\\n')\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      log_function('BRANCH #6: Covered if branch at line 46-47\\n')\n      return [minSumIndex, maxSumIndex]\n    else:\n      log_function('BRANCH #7: Covered else branch at line 48-49\\n')\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimize Manhattan Distances.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 33-35\n", "BRANCH #3: Covered if branch at line 36-38\n", "BRANCH #4: Covered if branch at line 39-41\n", "BRANCH #5: Covered if branch at line 42-44\n", "LOOP #1: Entered for loop at line 28-45\n"], ["LOOP #1: Entered for loop at line 28-45\n", "BRANCH #6: Covered if branch at line 46-47\n", "LOOP #1: Entered for loop at line 28-45\n", "BRANCH #1: Covered if branch at line 29-30\n", "LOOP #1: Entered for loop at line 28-45\n"], ["BRANCH #4: Covered if branch at line 39-41\n", "LOOP #1: Entered for loop at line 28-45\n", "BRANCH #1: Covered if branch at line 29-30\n", "LOOP #1: Entered for loop at line 28-45\n", "BRANCH #2: Covered if branch at line 33-35\n"], ["BRANCH #4: Covered if branch at line 39-41\n", "BRANCH #5: Covered if branch at line 42-44\n", "LOOP #1: Entered for loop at line 28-45\n", "BRANCH #6: Covered if branch at line 46-47\n", "LOOP #1: Entered for loop at line 28-45\n"]], "sampled_condition_paths": [["Line 33: (summ < minSum)", "Line 36: (summ > maxSum)", "Line 39: (diff < minDiff)", "Line 42: (diff > maxDiff)", "Line 28: (i, (x, y) in enumerate(points))"], ["Line 28: (i, (x, y) in enumerate(points))", "Line 46: (maxSum - minSum >= maxDiff - minDiff)", "Line 28: (i, (x, y) in enumerate(points))", "Line 29: (i == excludedIndex)", "Line 28: (i, (x, y) in enumerate(points))"], ["Line 39: (diff < minDiff)", "Line 28: (i, (x, y) in enumerate(points))", "Line 29: (i == excludedIndex)", "Line 28: (i, (x, y) in enumerate(points))", "Line 33: (summ < minSum)"], ["Line 39: (diff < minDiff)", "Line 42: (diff > maxDiff)", "Line 28: (i, (x, y) in enumerate(points))", "Line 46: (maxSum - minSum >= maxDiff - minDiff)", "Line 28: (i, (x, y) in enumerate(points))"]]}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "difficulty": 3, "func_name": "minimumCost", "description": "There is an undirected weighted graph with `n` vertices labeled from `0` to `n\n- 1`.\n\nYou are given the integer `n` and an array `edges`, where `edges[i] = [ui, vi,\nwi]` indicates that there is an edge between vertices `ui` and `vi` with a\nweight of `wi`.\n\nA walk on a graph is a sequence of vertices and edges. The walk starts and\nends with a vertex, and each edge connects the vertex that comes before it and\nthe vertex that comes after it. It's important to note that a walk may visit\nthe same edge or vertex more than once.\n\nThe cost of a walk starting at node `u` and ending at node `v` is defined as\nthe bitwise `AND` of the weights of the edges traversed during the walk. In\nother words, if the sequence of edge weights encountered during the walk is\n`w0, w1, w2, ..., wk`, then the cost is calculated as `w0 & w1 & w2 & ... &\nwk`, where `&` denotes the bitwise `AND` operator.\n\nYou are also given a 2D array `query`, where `query[i] = [si, ti]`. For each\nquery, you need to find the minimum cost of the walk starting at vertex `si`\nand ending at vertex `ti`. If there exists no such walk, the answer is `-1`.\n\nReturn the array `answer`, where `answer[i]` denotes the minimum cost of a\nwalk for query `i`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.7358490566037735}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}, {"type": "else", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 29, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 26, 28, 30, 31, 35, 39, 41, 45], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      log_function('BRANCH #1: Covered if branch at line 23-24\\n')\n      return\n    if self.rank[i] < self.rank[j]:\n      log_function('BRANCH #2: Covered if branch at line 25-26\\n')\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      log_function('BRANCH #3: Covered elif branch at line 27-28\\n')\n      self.id[j] = i\n    else:\n      log_function('BRANCH #4: Covered else branch at line 29-31\\n')\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      log_function('BRANCH #5: Covered if branch at line 34-35\\n')\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      log_function('BRANCH #6: Covered if branch at line 38-39\\n')\n      return self.weight[i]\n    else:\n      log_function('BRANCH #7: Covered else branch at line 40-41\\n')\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      log_function('BRANCH #8: Covered if branch at line 44-45\\n')\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      log_function('LOOP #1: Entered for loop at line 53-55\\n')\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Cost Walk in Weighted Graph.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 53-55\n", "BRANCH #3: Covered elif branch at line 27-28\n", "BRANCH #8: Covered if branch at line 44-45\n", "BRANCH #8: Covered if branch at line 44-45\n", "BRANCH #6: Covered if branch at line 38-39\n"], ["LOOP #1: Entered for loop at line 53-55\n", "BRANCH #8: Covered if branch at line 44-45\n", "BRANCH #1: Covered if branch at line 23-24\n", "LOOP #1: Entered for loop at line 53-55\n", "BRANCH #8: Covered if branch at line 44-45\n"], ["BRANCH #3: Covered elif branch at line 27-28\n", "LOOP #1: Entered for loop at line 53-55\n", "BRANCH #3: Covered elif branch at line 27-28\n", "BRANCH #8: Covered if branch at line 44-45\n", "BRANCH #8: Covered if branch at line 44-45\n"], ["BRANCH #1: Covered if branch at line 23-24\n", "LOOP #1: Entered for loop at line 53-55\n", "BRANCH #8: Covered if branch at line 44-45\n", "BRANCH #1: Covered if branch at line 23-24\n", "BRANCH #8: Covered if branch at line 44-45\n"]], "sampled_condition_paths": [["Line 53: (u, v, w in edges)", "Line 25: NOT (self.rank[i] < self.rank[j])", "Line 27: (self.rank[i] > self.rank[j])", "Line 44: (self.id[u] != u)", "Line 44: (self.id[u] != u)", "Line 38: (i == j)"], ["Line 53: (u, v, w in edges)", "Line 44: (self.id[u] != u)", "Line 23: (i == j)", "Line 53: (u, v, w in edges)", "Line 44: (self.id[u] != u)"], ["Line 25: NOT (self.rank[i] < self.rank[j])", "Line 27: (self.rank[i] > self.rank[j])", "Line 53: (u, v, w in edges)", "Line 25: NOT (self.rank[i] < self.rank[j])", "Line 27: (self.rank[i] > self.rank[j])", "Line 44: (self.id[u] != u)", "Line 44: (self.id[u] != u)"], ["Line 23: (i == j)", "Line 53: (u, v, w in edges)", "Line 44: (self.id[u] != u)", "Line 23: (i == j)", "Line 44: (self.id[u] != u)"]]}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "difficulty": 2, "func_name": "minimumTime", "description": "There is an undirected graph of `n` nodes. You are given a 2D array `edges`,\nwhere `edges[i] = [ui, vi, lengthi]` describes an edge between node `ui` and\nnode `vi` with a traversal time of `lengthi` units.\n\nAdditionally, you are given an array `disappear`, where `disappear[i]` denotes\nthe time when the node `i` disappears from the graph and you won't be able to\nvisit it.\n\nNotice that the graph might be disconnected and might contain multiple edges.\n\nReturn the array `answer`, with `answer[i]` denoting the minimum units of time\nrequired to reach node `i` from node 0. If node `i` is unreachable from node 0\nthen `answer[i]` is `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.1509433962264151}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 40, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 1, "eg_cov_prob": 0.660377358490566}], "target_lines": [30, 33, 34, 39, 41], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      log_function('LOOP #1: Entered for loop at line 15-18\\n')\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      log_function('LOOP #2: Entered while loop at line 27-35\\n')\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        log_function('BRANCH #1: Covered if branch at line 29-30\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #3: Entered for loop at line 31-35\\n')\n        if d + w < disappear[v] and d + w < dist[v]:\n          log_function('BRANCH #2: Covered if branch at line 32-34\\n')\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      log_function('LOOP #4: Entered for loop at line 37-41\\n')\n      if d != math.inf:\n        log_function('BRANCH #3: Covered if branch at line 38-39\\n')\n        res.append(d)\n      else:\n        log_function('BRANCH #4: Covered else branch at line 40-41\\n')\n        res.append(-1)\n    return res\n\ndef log_function(info_str):\n    with open(\"test_logs/Minimum Time to Visit Disappearing Nodes.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["LOOP #1: Entered for loop at line 15-18\n", "LOOP #2: Entered while loop at line 27-35\n", "LOOP #3: Entered for loop at line 31-35\n", "BRANCH #2: Covered if branch at line 32-34\n", "LOOP #3: Entered for loop at line 31-35\n"], ["LOOP #2: Entered while loop at line 27-35\n", "LOOP #3: Entered for loop at line 31-35\n", "LOOP #4: Entered for loop at line 37-41\n", "BRANCH #3: Covered if branch at line 38-39\n", "LOOP #4: Entered for loop at line 37-41\n"], ["LOOP #4: Entered for loop at line 37-41\n", "BRANCH #3: Covered if branch at line 38-39\n", "LOOP #4: Entered for loop at line 37-41\n", "BRANCH #4: Covered else branch at line 40-41\n", "LOOP #4: Entered for loop at line 37-41\n"], ["LOOP #3: Entered for loop at line 31-35\n", "BRANCH #2: Covered if branch at line 32-34\n", "LOOP #3: Entered for loop at line 31-35\n", "BRANCH #2: Covered if branch at line 32-34\n", "LOOP #2: Entered while loop at line 27-35\n"]], "sampled_condition_paths": [["Line 15: (u, v, w in edges)", "Line 27: (minHeap)", "Line 31: (v, w in graph[u])", "Line 32: (d + w < disappear[v] and d + w < dist[v])", "Line 31: (v, w in graph[u])"], ["Line 27: (minHeap)", "Line 31: (v, w in graph[u])", "Line 37: (d in dist)", "Line 38: (d != math.inf)", "Line 37: (d in dist)"], ["Line 37: (d in dist)", "Line 38: (d != math.inf)", "Line 37: (d in dist)", "Line 38: NOT (d != math.inf)", "Line 40: ", "Line 37: (d in dist)"], ["Line 31: (v, w in graph[u])", "Line 32: (d + w < disappear[v] and d + w < dist[v])", "Line 31: (v, w in graph[u])", "Line 32: (d + w < disappear[v] and d + w < dist[v])", "Line 27: (minHeap)"]]}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "difficulty": 3, "func_name": "findAnswer", "description": "You are given an undirected weighted graph of `n` nodes numbered from 0 to `n\n- 1`. The graph consists of `m` edges represented by a 2D array `edges`, where\n`edges[i] = [ai, bi, wi]` indicates that there is an edge between nodes `ai`\nand `bi` with weight `wi`.\n\nConsider all the shortest paths from node 0 to node `n - 1` in the graph. You\nneed to find a boolean array `answer` where `answer[i]` is `true` if the edge\n`edges[i]` is part of at least one shortest path. Otherwise, `answer[i]` is\n`false`.\n\nReturn the array `answer`.\n\nNote that the graph may not be connected.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.7547169811320755}, {"type": "if", "start": 34, "end": 36, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}], "target_lines": [32, 35, 36], "python_solution_instrumented": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      log_function('LOOP #1: Entered for loop at line 15-18\\n')\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      log_function('LOOP #2: Entered while loop at line 29-37\\n')\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        log_function('BRANCH #1: Covered if branch at line 31-32\\n')\n        continue\n      for v, w in graph[u]:\n        log_function('LOOP #3: Entered for loop at line 33-37\\n')\n        if d + w < dist[v]:\n          log_function('BRANCH #2: Covered if branch at line 34-36\\n')\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n\ndef log_function(info_str):\n    with open(\"test_logs/Find Edges in Shortest Paths.log\", \"a\") as file:\n        file.write(info_str)\n", "sampled_paths": [["BRANCH #2: Covered if branch at line 34-36\n", "LOOP #2: Entered while loop at line 29-37\n", "LOOP #3: Entered for loop at line 33-37\n", "LOOP #3: Entered for loop at line 33-37\n", "LOOP #3: Entered for loop at line 33-37\n"], ["LOOP #3: Entered for loop at line 33-37\n", "BRANCH #2: Covered if branch at line 34-36\n", "LOOP #2: Entered while loop at line 29-37\n", "LOOP #3: Entered for loop at line 33-37\n", "LOOP #3: Entered for loop at line 33-37\n"], ["LOOP #2: Entered while loop at line 29-37\n", "LOOP #3: Entered for loop at line 33-37\n", "LOOP #3: Entered for loop at line 33-37\n", "LOOP #2: Entered while loop at line 29-37\n", "BRANCH #1: Covered if branch at line 31-32\n"], ["BRANCH #2: Covered if branch at line 34-36\n", "LOOP #3: Entered for loop at line 33-37\n", "BRANCH #2: Covered if branch at line 34-36\n", "LOOP #3: Entered for loop at line 33-37\n", "BRANCH #2: Covered if branch at line 34-36\n"]], "sampled_condition_paths": [["Line 34: (d + w < dist[v])", "Line 29: (minHeap)", "Line 33: (v, w in graph[u])", "Line 33: (v, w in graph[u])", "Line 33: (v, w in graph[u])"], ["Line 33: (v, w in graph[u])", "Line 34: (d + w < dist[v])", "Line 29: (minHeap)", "Line 33: (v, w in graph[u])", "Line 33: (v, w in graph[u])"], ["Line 29: (minHeap)", "Line 33: (v, w in graph[u])", "Line 33: (v, w in graph[u])", "Line 29: (minHeap)", "Line 31: (d > dist[u])"], ["Line 34: (d + w < dist[v])", "Line 33: (v, w in graph[u])", "Line 34: (d + w < dist[v])", "Line 33: (v, w in graph[u])", "Line 34: (d + w < dist[v])"]]}
